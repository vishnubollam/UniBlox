"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execProgram = execProgram;
exports.createAssembly = createAssembly;
exports.prepareDefaultEnvironment = prepareDefaultEnvironment;
exports.prepareContext = prepareContext;
exports.guessExecutable = guessExecutable;
exports.spaceAvailableForContext = spaceAvailableForContext;
const childProcess = require("child_process");
const os = require("os");
const path = require("path");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs-extra");
const semver = require("semver");
const user_configuration_1 = require("../../cli/user-configuration");
const version_1 = require("../../cli/version");
const logging_1 = require("../../logging");
const error_1 = require("../../toolkit/error");
const tree_1 = require("../../tree");
const objects_1 = require("../../util/objects");
const rwlock_1 = require("../util/rwlock");
/** Invokes the cloud executable and returns JSON output */
async function execProgram(aws, config) {
    const env = await prepareDefaultEnvironment(aws);
    const context = await prepareContext(config.settings, config.context.all, env);
    const build = config.settings.get(['build']);
    if (build) {
        await exec(build);
    }
    const app = config.settings.get(['app']);
    if (!app) {
        throw new error_1.ToolkitError(`--app is required either in command-line, in ${user_configuration_1.PROJECT_CONFIG} or in ${user_configuration_1.USER_DEFAULTS}`);
    }
    // bypass "synth" if app points to a cloud assembly
    if (await fs.pathExists(app) && (await fs.stat(app)).isDirectory()) {
        (0, logging_1.debug)('--app points to a cloud assembly, so we bypass synth');
        // Acquire a read lock on this directory
        const lock = await new rwlock_1.RWLock(app).acquireRead();
        return { assembly: createAssembly(app), lock };
    }
    const commandLine = await guessExecutable(app);
    const outdir = config.settings.get(['output']);
    if (!outdir) {
        throw new error_1.ToolkitError('unexpected: --output is required');
    }
    if (typeof outdir !== 'string') {
        throw new error_1.ToolkitError(`--output takes a string, got ${JSON.stringify(outdir)}`);
    }
    try {
        await fs.mkdirp(outdir);
    }
    catch (error) {
        throw new error_1.ToolkitError(`Could not create output directory ${outdir} (${error.message})`);
    }
    (0, logging_1.debug)('outdir:', outdir);
    env[cxapi.OUTDIR_ENV] = outdir;
    // Acquire a lock on the output directory
    const writerLock = await new rwlock_1.RWLock(outdir).acquireWrite();
    try {
        // Send version information
        env[cxapi.CLI_ASM_VERSION_ENV] = cxschema.Manifest.version();
        env[cxapi.CLI_VERSION_ENV] = (0, version_1.versionNumber)();
        (0, logging_1.debug)('env:', env);
        const envVariableSizeLimit = os.platform() === 'win32' ? 32760 : 131072;
        const [smallContext, overflow] = (0, objects_1.splitBySize)(context, spaceAvailableForContext(env, envVariableSizeLimit));
        // Store the safe part in the environment variable
        env[cxapi.CONTEXT_ENV] = JSON.stringify(smallContext);
        // If there was any overflow, write it to a temporary file
        let contextOverflowLocation;
        if (Object.keys(overflow !== null && overflow !== void 0 ? overflow : {}).length > 0) {
            const contextDir = await fs.mkdtemp(path.join(os.tmpdir(), 'cdk-context'));
            contextOverflowLocation = path.join(contextDir, 'context-overflow.json');
            fs.writeJSONSync(contextOverflowLocation, overflow);
            env[cxapi.CONTEXT_OVERFLOW_LOCATION_ENV] = contextOverflowLocation;
        }
        await exec(commandLine.join(' '));
        const assembly = createAssembly(outdir);
        contextOverflowCleanup(contextOverflowLocation, assembly);
        return { assembly, lock: await writerLock.convertToReaderLock() };
    }
    catch (e) {
        await writerLock.release();
        throw e;
    }
    async function exec(commandAndArgs) {
        return new Promise((ok, fail) => {
            // We use a slightly lower-level interface to:
            //
            // - Pass arguments in an array instead of a string, to get around a
            //   number of quoting issues introduced by the intermediate shell layer
            //   (which would be different between Linux and Windows).
            //
            // - Inherit stderr from controlling terminal. We don't use the captured value
            //   anyway, and if the subprocess is printing to it for debugging purposes the
            //   user gets to see it sooner. Plus, capturing doesn't interact nicely with some
            //   processes like Maven.
            const proc = childProcess.spawn(commandAndArgs, {
                stdio: ['ignore', 'inherit', 'inherit'],
                detached: false,
                shell: true,
                env: {
                    ...process.env,
                    ...env,
                },
            });
            proc.on('error', fail);
            proc.on('exit', code => {
                if (code === 0) {
                    return ok();
                }
                else {
                    (0, logging_1.debug)('failed command:', commandAndArgs);
                    return fail(new error_1.ToolkitError(`Subprocess exited with error ${code}`));
                }
            });
        });
    }
}
/**
 * Creates an assembly with error handling
 */
function createAssembly(appDir) {
    try {
        return new cxapi.CloudAssembly(appDir, {
            // We sort as we deploy
            topoSort: false,
        });
    }
    catch (error) {
        if (error.message.includes(cxschema.VERSION_MISMATCH)) {
            // this means the CLI version is too old.
            // we instruct the user to upgrade.
            throw new error_1.ToolkitError(`This CDK CLI is not compatible with the CDK library used by your application. Please upgrade the CLI to the latest version.\n(${error.message})`);
        }
        throw error;
    }
}
/**
 * If we don't have region/account defined in context, we fall back to the default SDK behavior
 * where region is retrieved from ~/.aws/config and account is based on default credentials provider
 * chain and then STS is queried.
 *
 * This is done opportunistically: for example, if we can't access STS for some reason or the region
 * is not configured, the context value will be 'null' and there could failures down the line. In
 * some cases, synthesis does not require region/account information at all, so that might be perfectly
 * fine in certain scenarios.
 *
 * @param context The context key/value bash.
 */
async function prepareDefaultEnvironment(aws, logFn = logging_1.debug) {
    var _a;
    const env = {};
    env[cxapi.DEFAULT_REGION_ENV] = aws.defaultRegion;
    await logFn(`Setting "${cxapi.DEFAULT_REGION_ENV}" environment variable to`, env[cxapi.DEFAULT_REGION_ENV]);
    const accountId = (_a = (await aws.defaultAccount())) === null || _a === void 0 ? void 0 : _a.accountId;
    if (accountId) {
        env[cxapi.DEFAULT_ACCOUNT_ENV] = accountId;
        await logFn(`Setting "${cxapi.DEFAULT_ACCOUNT_ENV}" environment variable to`, env[cxapi.DEFAULT_ACCOUNT_ENV]);
    }
    return env;
}
/**
 * Settings related to synthesis are read from context.
 * The merging of various configuration sources like cli args or cdk.json has already happened.
 * We now need to set the final values to the context.
 */
async function prepareContext(settings, context, env) {
    var _a, _b, _c, _d, _e, _f;
    const debugMode = (_a = settings.get(['debug'])) !== null && _a !== void 0 ? _a : true;
    if (debugMode) {
        env.CDK_DEBUG = 'true';
    }
    const pathMetadata = (_b = settings.get(['pathMetadata'])) !== null && _b !== void 0 ? _b : true;
    if (pathMetadata) {
        context[cxapi.PATH_METADATA_ENABLE_CONTEXT] = true;
    }
    const assetMetadata = (_c = settings.get(['assetMetadata'])) !== null && _c !== void 0 ? _c : true;
    if (assetMetadata) {
        context[cxapi.ASSET_RESOURCE_METADATA_ENABLED_CONTEXT] = true;
    }
    const versionReporting = (_d = settings.get(['versionReporting'])) !== null && _d !== void 0 ? _d : true;
    if (versionReporting) {
        context[cxapi.ANALYTICS_REPORTING_ENABLED_CONTEXT] = true;
    }
    // We need to keep on doing this for framework version from before this flag was deprecated.
    if (!versionReporting) {
        context['aws:cdk:disable-version-reporting'] = true;
    }
    const stagingEnabled = (_e = settings.get(['staging'])) !== null && _e !== void 0 ? _e : true;
    if (!stagingEnabled) {
        context[cxapi.DISABLE_ASSET_STAGING_CONTEXT] = true;
    }
    const bundlingStacks = (_f = settings.get(['bundlingStacks'])) !== null && _f !== void 0 ? _f : ['**'];
    context[cxapi.BUNDLING_STACKS] = bundlingStacks;
    (0, logging_1.debug)('context:', context);
    return context;
}
/**
 * Make sure the 'app' is an array
 *
 * If it's a string, split on spaces as a trivial way of tokenizing the command line.
 */
function appToArray(app) {
    return typeof app === 'string' ? app.split(' ') : app;
}
/**
 * Execute the given file with the same 'node' process as is running the current process
 */
function executeNode(scriptFile) {
    return [process.execPath, scriptFile];
}
/**
 * Mapping of extensions to command-line generators
 */
const EXTENSION_MAP = new Map([
    ['.js', executeNode],
]);
/**
 * Guess the executable from the command-line argument
 *
 * Only do this if the file is NOT marked as executable. If it is,
 * we'll defer to the shebang inside the file itself.
 *
 * If we're on Windows, we ALWAYS take the handler, since it's hard to
 * verify if registry associations have or have not been set up for this
 * file type, so we'll assume the worst and take control.
 */
async function guessExecutable(app) {
    const commandLine = appToArray(app);
    if (commandLine.length === 1) {
        let fstat;
        try {
            fstat = await fs.stat(commandLine[0]);
        }
        catch {
            (0, logging_1.debug)(`Not a file: '${commandLine[0]}'. Using '${commandLine}' as command-line`);
            return commandLine;
        }
        // eslint-disable-next-line no-bitwise
        const isExecutable = (fstat.mode & fs.constants.X_OK) !== 0;
        const isWindows = process.platform === 'win32';
        const handler = EXTENSION_MAP.get(path.extname(commandLine[0]));
        if (handler && (!isExecutable || isWindows)) {
            return handler(commandLine[0]);
        }
    }
    return commandLine;
}
function contextOverflowCleanup(location, assembly) {
    if (location) {
        fs.removeSync(path.dirname(location));
        const tree = (0, tree_1.loadTree)(assembly);
        const frameworkDoesNotSupportContextOverflow = (0, tree_1.some)(tree, node => {
            var _a, _b;
            const fqn = (_a = node.constructInfo) === null || _a === void 0 ? void 0 : _a.fqn;
            const version = (_b = node.constructInfo) === null || _b === void 0 ? void 0 : _b.version;
            return (fqn === 'aws-cdk-lib.App' && version != null && semver.lte(version, '2.38.0'))
                || fqn === '@aws-cdk/core.App'; // v1
        });
        // We're dealing with an old version of the framework here. It is unaware of the temporary
        // file, which means that it will ignore the context overflow.
        if (frameworkDoesNotSupportContextOverflow) {
            (0, logging_1.warning)('Part of the context could not be sent to the application. Please update the AWS CDK library to the latest version.');
        }
    }
}
function spaceAvailableForContext(env, limit) {
    const size = (value) => value != null ? Buffer.byteLength(value) : 0;
    const usedSpace = Object.entries(env)
        .map(([k, v]) => k === cxapi.CONTEXT_ENV ? size(k) : size(k) + size(v))
        .reduce((a, b) => a + b, 0);
    return Math.max(0, limit - usedSpace);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhlYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImV4ZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUF1QkEsa0NBaUhDO0FBS0Qsd0NBY0M7QUFjRCw4REFnQkM7QUFPRCx3Q0FnQ0M7QUFxQ0QsMENBc0JDO0FBc0JELDREQVFDO0FBelRELDhDQUE4QztBQUM5Qyx5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLDJEQUEyRDtBQUMzRCx5Q0FBeUM7QUFDekMsK0JBQStCO0FBQy9CLGlDQUFpQztBQUNqQyxxRUFBNEY7QUFDNUYsK0NBQWtEO0FBQ2xELDJDQUErQztBQUMvQywrQ0FBbUQ7QUFDbkQscUNBQTRDO0FBQzVDLGdEQUFpRDtBQUdqRCwyQ0FBK0M7QUFPL0MsMkRBQTJEO0FBQ3BELEtBQUssVUFBVSxXQUFXLENBQUMsR0FBZ0IsRUFBRSxNQUFxQjtJQUN2RSxNQUFNLEdBQUcsR0FBRyxNQUFNLHlCQUF5QixDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pELE1BQU0sT0FBTyxHQUFHLE1BQU0sY0FBYyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFFL0UsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQzdDLElBQUksS0FBSyxFQUFFLENBQUM7UUFDVixNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNwQixDQUFDO0lBRUQsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNULE1BQU0sSUFBSSxvQkFBWSxDQUFDLGdEQUFnRCxtQ0FBYyxVQUFVLGtDQUFhLEVBQUUsQ0FBQyxDQUFDO0lBQ2xILENBQUM7SUFFRCxtREFBbUQ7SUFDbkQsSUFBSSxNQUFNLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDO1FBQ25FLElBQUEsZUFBSyxFQUFDLHNEQUFzRCxDQUFDLENBQUM7UUFFOUQsd0NBQXdDO1FBQ3hDLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxlQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFakQsT0FBTyxFQUFFLFFBQVEsRUFBRSxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDakQsQ0FBQztJQUVELE1BQU0sV0FBVyxHQUFHLE1BQU0sZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRS9DLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUMvQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDWixNQUFNLElBQUksb0JBQVksQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFDRCxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQy9CLE1BQU0sSUFBSSxvQkFBWSxDQUFDLGdDQUFnQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNuRixDQUFDO0lBQ0QsSUFBSSxDQUFDO1FBQ0gsTUFBTSxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFBQyxPQUFPLEtBQVUsRUFBRSxDQUFDO1FBQ3BCLE1BQU0sSUFBSSxvQkFBWSxDQUFDLHFDQUFxQyxNQUFNLEtBQUssS0FBSyxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7SUFDM0YsQ0FBQztJQUVELElBQUEsZUFBSyxFQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUN6QixHQUFHLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLE1BQU0sQ0FBQztJQUUvQix5Q0FBeUM7SUFDekMsTUFBTSxVQUFVLEdBQUcsTUFBTSxJQUFJLGVBQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUUzRCxJQUFJLENBQUM7UUFDSCwyQkFBMkI7UUFDM0IsR0FBRyxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDN0QsR0FBRyxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsR0FBRyxJQUFBLHVCQUFhLEdBQUUsQ0FBQztRQUU3QyxJQUFBLGVBQUssRUFBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFFbkIsTUFBTSxvQkFBb0IsR0FBRyxFQUFFLENBQUMsUUFBUSxFQUFFLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztRQUN4RSxNQUFNLENBQUMsWUFBWSxFQUFFLFFBQVEsQ0FBQyxHQUFHLElBQUEscUJBQVcsRUFBQyxPQUFPLEVBQUUsd0JBQXdCLENBQUMsR0FBRyxFQUFFLG9CQUFvQixDQUFDLENBQUMsQ0FBQztRQUUzRyxrREFBa0Q7UUFDbEQsR0FBRyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRXRELDBEQUEwRDtRQUMxRCxJQUFJLHVCQUF1QixDQUFDO1FBQzVCLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLGFBQVIsUUFBUSxjQUFSLFFBQVEsR0FBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDM0MsTUFBTSxVQUFVLEdBQUcsTUFBTSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDM0UsdUJBQXVCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztZQUN6RSxFQUFFLENBQUMsYUFBYSxDQUFDLHVCQUF1QixFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3BELEdBQUcsQ0FBQyxLQUFLLENBQUMsNkJBQTZCLENBQUMsR0FBRyx1QkFBdUIsQ0FBQztRQUNyRSxDQUFDO1FBRUQsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRWxDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV4QyxzQkFBc0IsQ0FBQyx1QkFBdUIsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUUxRCxPQUFPLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxNQUFNLFVBQVUsQ0FBQyxtQkFBbUIsRUFBRSxFQUFFLENBQUM7SUFDcEUsQ0FBQztJQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7UUFDWCxNQUFNLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUMzQixNQUFNLENBQUMsQ0FBQztJQUNWLENBQUM7SUFFRCxLQUFLLFVBQVUsSUFBSSxDQUFDLGNBQXNCO1FBQ3hDLE9BQU8sSUFBSSxPQUFPLENBQU8sQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUU7WUFDcEMsOENBQThDO1lBQzlDLEVBQUU7WUFDRixvRUFBb0U7WUFDcEUsd0VBQXdFO1lBQ3hFLDBEQUEwRDtZQUMxRCxFQUFFO1lBQ0YsOEVBQThFO1lBQzlFLCtFQUErRTtZQUMvRSxrRkFBa0Y7WUFDbEYsMEJBQTBCO1lBQzFCLE1BQU0sSUFBSSxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFFO2dCQUM5QyxLQUFLLEVBQUUsQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQztnQkFDdkMsUUFBUSxFQUFFLEtBQUs7Z0JBQ2YsS0FBSyxFQUFFLElBQUk7Z0JBQ1gsR0FBRyxFQUFFO29CQUNILEdBQUcsT0FBTyxDQUFDLEdBQUc7b0JBQ2QsR0FBRyxHQUFHO2lCQUNQO2FBQ0YsQ0FBQyxDQUFDO1lBRUgsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFFdkIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQUU7Z0JBQ3JCLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRSxDQUFDO29CQUNmLE9BQU8sRUFBRSxFQUFFLENBQUM7Z0JBQ2QsQ0FBQztxQkFBTSxDQUFDO29CQUNOLElBQUEsZUFBSyxFQUFDLGlCQUFpQixFQUFFLGNBQWMsQ0FBQyxDQUFDO29CQUN6QyxPQUFPLElBQUksQ0FBQyxJQUFJLG9CQUFZLENBQUMsZ0NBQWdDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDeEUsQ0FBQztZQUNILENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0FBQ0gsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsY0FBYyxDQUFDLE1BQWM7SUFDM0MsSUFBSSxDQUFDO1FBQ0gsT0FBTyxJQUFJLEtBQUssQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFO1lBQ3JDLHVCQUF1QjtZQUN2QixRQUFRLEVBQUUsS0FBSztTQUNoQixDQUFDLENBQUM7SUFDTCxDQUFDO0lBQUMsT0FBTyxLQUFVLEVBQUUsQ0FBQztRQUNwQixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUM7WUFDdEQseUNBQXlDO1lBQ3pDLG1DQUFtQztZQUNuQyxNQUFNLElBQUksb0JBQVksQ0FBQyxpSUFBaUksS0FBSyxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDNUssQ0FBQztRQUNELE1BQU0sS0FBSyxDQUFDO0lBQ2QsQ0FBQztBQUNILENBQUM7QUFFRDs7Ozs7Ozs7Ozs7R0FXRztBQUNJLEtBQUssVUFBVSx5QkFBeUIsQ0FDN0MsR0FBZ0IsRUFDaEIsUUFBNEMsZUFBSzs7SUFFakQsTUFBTSxHQUFHLEdBQThCLEVBQUcsQ0FBQztJQUUzQyxHQUFHLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsR0FBRyxDQUFDLGFBQWEsQ0FBQztJQUNsRCxNQUFNLEtBQUssQ0FBQyxZQUFZLEtBQUssQ0FBQyxrQkFBa0IsMkJBQTJCLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7SUFFNUcsTUFBTSxTQUFTLEdBQUcsTUFBQSxDQUFDLE1BQU0sR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDLDBDQUFFLFNBQVMsQ0FBQztJQUMxRCxJQUFJLFNBQVMsRUFBRSxDQUFDO1FBQ2QsR0FBRyxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLFNBQVMsQ0FBQztRQUMzQyxNQUFNLEtBQUssQ0FBQyxZQUFZLEtBQUssQ0FBQyxtQkFBbUIsMkJBQTJCLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7SUFDaEgsQ0FBQztJQUVELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSSxLQUFLLFVBQVUsY0FBYyxDQUFDLFFBQWtCLEVBQUUsT0FBNkIsRUFBRSxHQUF5Qzs7SUFDL0gsTUFBTSxTQUFTLEdBQVksTUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsbUNBQUksSUFBSSxDQUFDO0lBQzNELElBQUksU0FBUyxFQUFFLENBQUM7UUFDZCxHQUFHLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQztJQUN6QixDQUFDO0lBRUQsTUFBTSxZQUFZLEdBQVksTUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsbUNBQUksSUFBSSxDQUFDO0lBQ3JFLElBQUksWUFBWSxFQUFFLENBQUM7UUFDakIsT0FBTyxDQUFDLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxHQUFHLElBQUksQ0FBQztJQUNyRCxDQUFDO0lBRUQsTUFBTSxhQUFhLEdBQVksTUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsbUNBQUksSUFBSSxDQUFDO0lBQ3ZFLElBQUksYUFBYSxFQUFFLENBQUM7UUFDbEIsT0FBTyxDQUFDLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxHQUFHLElBQUksQ0FBQztJQUNoRSxDQUFDO0lBRUQsTUFBTSxnQkFBZ0IsR0FBWSxNQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLG1DQUFJLElBQUksQ0FBQztJQUM3RSxJQUFJLGdCQUFnQixFQUFFLENBQUM7UUFBQyxPQUFPLENBQUMsS0FBSyxDQUFDLG1DQUFtQyxDQUFDLEdBQUcsSUFBSSxDQUFDO0lBQUMsQ0FBQztJQUNwRiw0RkFBNEY7SUFDNUYsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFBQyxPQUFPLENBQUMsbUNBQW1DLENBQUMsR0FBRyxJQUFJLENBQUM7SUFBQyxDQUFDO0lBRS9FLE1BQU0sY0FBYyxHQUFHLE1BQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLG1DQUFJLElBQUksQ0FBQztJQUN6RCxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDcEIsT0FBTyxDQUFDLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxHQUFHLElBQUksQ0FBQztJQUN0RCxDQUFDO0lBRUQsTUFBTSxjQUFjLEdBQUcsTUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxtQ0FBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2xFLE9BQU8sQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLEdBQUcsY0FBYyxDQUFDO0lBRWhELElBQUEsZUFBSyxFQUFDLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUUzQixPQUFPLE9BQU8sQ0FBQztBQUNqQixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsVUFBVSxDQUFDLEdBQVE7SUFDMUIsT0FBTyxPQUFPLEdBQUcsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUN4RCxDQUFDO0FBSUQ7O0dBRUc7QUFDSCxTQUFTLFdBQVcsQ0FBQyxVQUFrQjtJQUNyQyxPQUFPLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUN4QyxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLGFBQWEsR0FBRyxJQUFJLEdBQUcsQ0FBMkI7SUFDdEQsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDO0NBQ3JCLENBQUMsQ0FBQztBQUVIOzs7Ozs7Ozs7R0FTRztBQUNJLEtBQUssVUFBVSxlQUFlLENBQUMsR0FBVztJQUMvQyxNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDcEMsSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQzdCLElBQUksS0FBSyxDQUFDO1FBRVYsSUFBSSxDQUFDO1lBQ0gsS0FBSyxHQUFHLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4QyxDQUFDO1FBQUMsTUFBTSxDQUFDO1lBQ1AsSUFBQSxlQUFLLEVBQUMsZ0JBQWdCLFdBQVcsQ0FBQyxDQUFDLENBQUMsYUFBYSxXQUFXLG1CQUFtQixDQUFDLENBQUM7WUFDakYsT0FBTyxXQUFXLENBQUM7UUFDckIsQ0FBQztRQUVELHNDQUFzQztRQUN0QyxNQUFNLFlBQVksR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDNUQsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPLENBQUM7UUFFL0MsTUFBTSxPQUFPLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEUsSUFBSSxPQUFPLElBQUksQ0FBQyxDQUFDLFlBQVksSUFBSSxTQUFTLENBQUMsRUFBRSxDQUFDO1lBQzVDLE9BQU8sT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLENBQUM7SUFDSCxDQUFDO0lBQ0QsT0FBTyxXQUFXLENBQUM7QUFDckIsQ0FBQztBQUVELFNBQVMsc0JBQXNCLENBQUMsUUFBNEIsRUFBRSxRQUE2QjtJQUN6RixJQUFJLFFBQVEsRUFBRSxDQUFDO1FBQ2IsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFFdEMsTUFBTSxJQUFJLEdBQUcsSUFBQSxlQUFRLEVBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEMsTUFBTSxzQ0FBc0MsR0FBRyxJQUFBLFdBQUksRUFBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUU7O1lBQy9ELE1BQU0sR0FBRyxHQUFHLE1BQUEsSUFBSSxDQUFDLGFBQWEsMENBQUUsR0FBRyxDQUFDO1lBQ3BDLE1BQU0sT0FBTyxHQUFHLE1BQUEsSUFBSSxDQUFDLGFBQWEsMENBQUUsT0FBTyxDQUFDO1lBQzVDLE9BQU8sQ0FBQyxHQUFHLEtBQUssaUJBQWlCLElBQUksT0FBTyxJQUFJLElBQUksSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQzttQkFDakYsR0FBRyxLQUFLLG1CQUFtQixDQUFDLENBQUMsS0FBSztRQUN6QyxDQUFDLENBQUMsQ0FBQztRQUVILDBGQUEwRjtRQUMxRiw4REFBOEQ7UUFDOUQsSUFBSSxzQ0FBc0MsRUFBRSxDQUFDO1lBQzNDLElBQUEsaUJBQU8sRUFBQyxvSEFBb0gsQ0FBQyxDQUFDO1FBQ2hJLENBQUM7SUFDSCxDQUFDO0FBQ0gsQ0FBQztBQUVELFNBQWdCLHdCQUF3QixDQUFDLEdBQThCLEVBQUUsS0FBYTtJQUNwRixNQUFNLElBQUksR0FBRyxDQUFDLEtBQWEsRUFBRSxFQUFFLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTdFLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO1NBQ2xDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RFLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFOUIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxLQUFLLEdBQUcsU0FBUyxDQUFDLENBQUM7QUFDeEMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNoaWxkUHJvY2VzcyBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBjeHNjaGVtYSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHsgQ29uZmlndXJhdGlvbiwgUFJPSkVDVF9DT05GSUcsIFVTRVJfREVGQVVMVFMgfSBmcm9tICcuLi8uLi9jbGkvdXNlci1jb25maWd1cmF0aW9uJztcbmltcG9ydCB7IHZlcnNpb25OdW1iZXIgfSBmcm9tICcuLi8uLi9jbGkvdmVyc2lvbic7XG5pbXBvcnQgeyBkZWJ1Zywgd2FybmluZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yIH0gZnJvbSAnLi4vLi4vdG9vbGtpdC9lcnJvcic7XG5pbXBvcnQgeyBsb2FkVHJlZSwgc29tZSB9IGZyb20gJy4uLy4uL3RyZWUnO1xuaW1wb3J0IHsgc3BsaXRCeVNpemUgfSBmcm9tICcuLi8uLi91dGlsL29iamVjdHMnO1xuaW1wb3J0IHsgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBTZXR0aW5ncyB9IGZyb20gJy4uL3NldHRpbmdzJztcbmltcG9ydCB7IFJXTG9jaywgSUxvY2sgfSBmcm9tICcuLi91dGlsL3J3bG9jayc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhlY1Byb2dyYW1SZXN1bHQge1xuICByZWFkb25seSBhc3NlbWJseTogY3hhcGkuQ2xvdWRBc3NlbWJseTtcbiAgcmVhZG9ubHkgbG9jazogSUxvY2s7XG59XG5cbi8qKiBJbnZva2VzIHRoZSBjbG91ZCBleGVjdXRhYmxlIGFuZCByZXR1cm5zIEpTT04gb3V0cHV0ICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY1Byb2dyYW0oYXdzOiBTZGtQcm92aWRlciwgY29uZmlnOiBDb25maWd1cmF0aW9uKTogUHJvbWlzZTxFeGVjUHJvZ3JhbVJlc3VsdD4ge1xuICBjb25zdCBlbnYgPSBhd2FpdCBwcmVwYXJlRGVmYXVsdEVudmlyb25tZW50KGF3cyk7XG4gIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBwcmVwYXJlQ29udGV4dChjb25maWcuc2V0dGluZ3MsIGNvbmZpZy5jb250ZXh0LmFsbCwgZW52KTtcblxuICBjb25zdCBidWlsZCA9IGNvbmZpZy5zZXR0aW5ncy5nZXQoWydidWlsZCddKTtcbiAgaWYgKGJ1aWxkKSB7XG4gICAgYXdhaXQgZXhlYyhidWlsZCk7XG4gIH1cblxuICBjb25zdCBhcHAgPSBjb25maWcuc2V0dGluZ3MuZ2V0KFsnYXBwJ10pO1xuICBpZiAoIWFwcCkge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYC0tYXBwIGlzIHJlcXVpcmVkIGVpdGhlciBpbiBjb21tYW5kLWxpbmUsIGluICR7UFJPSkVDVF9DT05GSUd9IG9yIGluICR7VVNFUl9ERUZBVUxUU31gKTtcbiAgfVxuXG4gIC8vIGJ5cGFzcyBcInN5bnRoXCIgaWYgYXBwIHBvaW50cyB0byBhIGNsb3VkIGFzc2VtYmx5XG4gIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKGFwcCkgJiYgKGF3YWl0IGZzLnN0YXQoYXBwKSkuaXNEaXJlY3RvcnkoKSkge1xuICAgIGRlYnVnKCctLWFwcCBwb2ludHMgdG8gYSBjbG91ZCBhc3NlbWJseSwgc28gd2UgYnlwYXNzIHN5bnRoJyk7XG5cbiAgICAvLyBBY3F1aXJlIGEgcmVhZCBsb2NrIG9uIHRoaXMgZGlyZWN0b3J5XG4gICAgY29uc3QgbG9jayA9IGF3YWl0IG5ldyBSV0xvY2soYXBwKS5hY3F1aXJlUmVhZCgpO1xuXG4gICAgcmV0dXJuIHsgYXNzZW1ibHk6IGNyZWF0ZUFzc2VtYmx5KGFwcCksIGxvY2sgfTtcbiAgfVxuXG4gIGNvbnN0IGNvbW1hbmRMaW5lID0gYXdhaXQgZ3Vlc3NFeGVjdXRhYmxlKGFwcCk7XG5cbiAgY29uc3Qgb3V0ZGlyID0gY29uZmlnLnNldHRpbmdzLmdldChbJ291dHB1dCddKTtcbiAgaWYgKCFvdXRkaXIpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCd1bmV4cGVjdGVkOiAtLW91dHB1dCBpcyByZXF1aXJlZCcpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3V0ZGlyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYC0tb3V0cHV0IHRha2VzIGEgc3RyaW5nLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvdXRkaXIpfWApO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgZnMubWtkaXJwKG91dGRpcik7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBDb3VsZCBub3QgY3JlYXRlIG91dHB1dCBkaXJlY3RvcnkgJHtvdXRkaXJ9ICgke2Vycm9yLm1lc3NhZ2V9KWApO1xuICB9XG5cbiAgZGVidWcoJ291dGRpcjonLCBvdXRkaXIpO1xuICBlbnZbY3hhcGkuT1VURElSX0VOVl0gPSBvdXRkaXI7XG5cbiAgLy8gQWNxdWlyZSBhIGxvY2sgb24gdGhlIG91dHB1dCBkaXJlY3RvcnlcbiAgY29uc3Qgd3JpdGVyTG9jayA9IGF3YWl0IG5ldyBSV0xvY2sob3V0ZGlyKS5hY3F1aXJlV3JpdGUoKTtcblxuICB0cnkge1xuICAgIC8vIFNlbmQgdmVyc2lvbiBpbmZvcm1hdGlvblxuICAgIGVudltjeGFwaS5DTElfQVNNX1ZFUlNJT05fRU5WXSA9IGN4c2NoZW1hLk1hbmlmZXN0LnZlcnNpb24oKTtcbiAgICBlbnZbY3hhcGkuQ0xJX1ZFUlNJT05fRU5WXSA9IHZlcnNpb25OdW1iZXIoKTtcblxuICAgIGRlYnVnKCdlbnY6JywgZW52KTtcblxuICAgIGNvbnN0IGVudlZhcmlhYmxlU2l6ZUxpbWl0ID0gb3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJyA/IDMyNzYwIDogMTMxMDcyO1xuICAgIGNvbnN0IFtzbWFsbENvbnRleHQsIG92ZXJmbG93XSA9IHNwbGl0QnlTaXplKGNvbnRleHQsIHNwYWNlQXZhaWxhYmxlRm9yQ29udGV4dChlbnYsIGVudlZhcmlhYmxlU2l6ZUxpbWl0KSk7XG5cbiAgICAvLyBTdG9yZSB0aGUgc2FmZSBwYXJ0IGluIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICAgIGVudltjeGFwaS5DT05URVhUX0VOVl0gPSBKU09OLnN0cmluZ2lmeShzbWFsbENvbnRleHQpO1xuXG4gICAgLy8gSWYgdGhlcmUgd2FzIGFueSBvdmVyZmxvdywgd3JpdGUgaXQgdG8gYSB0ZW1wb3JhcnkgZmlsZVxuICAgIGxldCBjb250ZXh0T3ZlcmZsb3dMb2NhdGlvbjtcbiAgICBpZiAoT2JqZWN0LmtleXMob3ZlcmZsb3cgPz8ge30pLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNvbnRleHREaXIgPSBhd2FpdCBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2Nkay1jb250ZXh0JykpO1xuICAgICAgY29udGV4dE92ZXJmbG93TG9jYXRpb24gPSBwYXRoLmpvaW4oY29udGV4dERpciwgJ2NvbnRleHQtb3ZlcmZsb3cuanNvbicpO1xuICAgICAgZnMud3JpdGVKU09OU3luYyhjb250ZXh0T3ZlcmZsb3dMb2NhdGlvbiwgb3ZlcmZsb3cpO1xuICAgICAgZW52W2N4YXBpLkNPTlRFWFRfT1ZFUkZMT1dfTE9DQVRJT05fRU5WXSA9IGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uO1xuICAgIH1cblxuICAgIGF3YWl0IGV4ZWMoY29tbWFuZExpbmUuam9pbignICcpKTtcblxuICAgIGNvbnN0IGFzc2VtYmx5ID0gY3JlYXRlQXNzZW1ibHkob3V0ZGlyKTtcblxuICAgIGNvbnRleHRPdmVyZmxvd0NsZWFudXAoY29udGV4dE92ZXJmbG93TG9jYXRpb24sIGFzc2VtYmx5KTtcblxuICAgIHJldHVybiB7IGFzc2VtYmx5LCBsb2NrOiBhd2FpdCB3cml0ZXJMb2NrLmNvbnZlcnRUb1JlYWRlckxvY2soKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgYXdhaXQgd3JpdGVyTG9jay5yZWxlYXNlKCk7XG4gICAgdGhyb3cgZTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGV4ZWMoY29tbWFuZEFuZEFyZ3M6IHN0cmluZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigob2ssIGZhaWwpID0+IHtcbiAgICAgIC8vIFdlIHVzZSBhIHNsaWdodGx5IGxvd2VyLWxldmVsIGludGVyZmFjZSB0bzpcbiAgICAgIC8vXG4gICAgICAvLyAtIFBhc3MgYXJndW1lbnRzIGluIGFuIGFycmF5IGluc3RlYWQgb2YgYSBzdHJpbmcsIHRvIGdldCBhcm91bmQgYVxuICAgICAgLy8gICBudW1iZXIgb2YgcXVvdGluZyBpc3N1ZXMgaW50cm9kdWNlZCBieSB0aGUgaW50ZXJtZWRpYXRlIHNoZWxsIGxheWVyXG4gICAgICAvLyAgICh3aGljaCB3b3VsZCBiZSBkaWZmZXJlbnQgYmV0d2VlbiBMaW51eCBhbmQgV2luZG93cykuXG4gICAgICAvL1xuICAgICAgLy8gLSBJbmhlcml0IHN0ZGVyciBmcm9tIGNvbnRyb2xsaW5nIHRlcm1pbmFsLiBXZSBkb24ndCB1c2UgdGhlIGNhcHR1cmVkIHZhbHVlXG4gICAgICAvLyAgIGFueXdheSwgYW5kIGlmIHRoZSBzdWJwcm9jZXNzIGlzIHByaW50aW5nIHRvIGl0IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgdGhlXG4gICAgICAvLyAgIHVzZXIgZ2V0cyB0byBzZWUgaXQgc29vbmVyLiBQbHVzLCBjYXB0dXJpbmcgZG9lc24ndCBpbnRlcmFjdCBuaWNlbHkgd2l0aCBzb21lXG4gICAgICAvLyAgIHByb2Nlc3NlcyBsaWtlIE1hdmVuLlxuICAgICAgY29uc3QgcHJvYyA9IGNoaWxkUHJvY2Vzcy5zcGF3bihjb21tYW5kQW5kQXJncywge1xuICAgICAgICBzdGRpbzogWydpZ25vcmUnLCAnaW5oZXJpdCcsICdpbmhlcml0J10sXG4gICAgICAgIGRldGFjaGVkOiBmYWxzZSxcbiAgICAgICAgc2hlbGw6IHRydWUsXG4gICAgICAgIGVudjoge1xuICAgICAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgICAgIC4uLmVudixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBwcm9jLm9uKCdlcnJvcicsIGZhaWwpO1xuXG4gICAgICBwcm9jLm9uKCdleGl0JywgY29kZSA9PiB7XG4gICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG9rKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ2ZhaWxlZCBjb21tYW5kOicsIGNvbW1hbmRBbmRBcmdzKTtcbiAgICAgICAgICByZXR1cm4gZmFpbChuZXcgVG9vbGtpdEVycm9yKGBTdWJwcm9jZXNzIGV4aXRlZCB3aXRoIGVycm9yICR7Y29kZX1gKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhc3NlbWJseSB3aXRoIGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBc3NlbWJseShhcHBEaXI6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgY3hhcGkuQ2xvdWRBc3NlbWJseShhcHBEaXIsIHtcbiAgICAgIC8vIFdlIHNvcnQgYXMgd2UgZGVwbG95XG4gICAgICB0b3BvU29ydDogZmFsc2UsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhjeHNjaGVtYS5WRVJTSU9OX01JU01BVENIKSkge1xuICAgICAgLy8gdGhpcyBtZWFucyB0aGUgQ0xJIHZlcnNpb24gaXMgdG9vIG9sZC5cbiAgICAgIC8vIHdlIGluc3RydWN0IHRoZSB1c2VyIHRvIHVwZ3JhZGUuXG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBUaGlzIENESyBDTEkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgQ0RLIGxpYnJhcnkgdXNlZCBieSB5b3VyIGFwcGxpY2F0aW9uLiBQbGVhc2UgdXBncmFkZSB0aGUgQ0xJIHRvIHRoZSBsYXRlc3QgdmVyc2lvbi5cXG4oJHtlcnJvci5tZXNzYWdlfSlgKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBJZiB3ZSBkb24ndCBoYXZlIHJlZ2lvbi9hY2NvdW50IGRlZmluZWQgaW4gY29udGV4dCwgd2UgZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IFNESyBiZWhhdmlvclxuICogd2hlcmUgcmVnaW9uIGlzIHJldHJpZXZlZCBmcm9tIH4vLmF3cy9jb25maWcgYW5kIGFjY291bnQgaXMgYmFzZWQgb24gZGVmYXVsdCBjcmVkZW50aWFscyBwcm92aWRlclxuICogY2hhaW4gYW5kIHRoZW4gU1RTIGlzIHF1ZXJpZWQuXG4gKlxuICogVGhpcyBpcyBkb25lIG9wcG9ydHVuaXN0aWNhbGx5OiBmb3IgZXhhbXBsZSwgaWYgd2UgY2FuJ3QgYWNjZXNzIFNUUyBmb3Igc29tZSByZWFzb24gb3IgdGhlIHJlZ2lvblxuICogaXMgbm90IGNvbmZpZ3VyZWQsIHRoZSBjb250ZXh0IHZhbHVlIHdpbGwgYmUgJ251bGwnIGFuZCB0aGVyZSBjb3VsZCBmYWlsdXJlcyBkb3duIHRoZSBsaW5lLiBJblxuICogc29tZSBjYXNlcywgc3ludGhlc2lzIGRvZXMgbm90IHJlcXVpcmUgcmVnaW9uL2FjY291bnQgaW5mb3JtYXRpb24gYXQgYWxsLCBzbyB0aGF0IG1pZ2h0IGJlIHBlcmZlY3RseVxuICogZmluZSBpbiBjZXJ0YWluIHNjZW5hcmlvcy5cbiAqXG4gKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCBrZXkvdmFsdWUgYmFzaC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZXBhcmVEZWZhdWx0RW52aXJvbm1lbnQoXG4gIGF3czogU2RrUHJvdmlkZXIsXG4gIGxvZ0ZuOiAobXNnOiBzdHJpbmcsIC4uLmFyZ3M6IGFueSkgPT4gYW55ID0gZGVidWcsXG4pOiBQcm9taXNlPHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0+IHtcbiAgY29uc3QgZW52OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0geyB9O1xuXG4gIGVudltjeGFwaS5ERUZBVUxUX1JFR0lPTl9FTlZdID0gYXdzLmRlZmF1bHRSZWdpb247XG4gIGF3YWl0IGxvZ0ZuKGBTZXR0aW5nIFwiJHtjeGFwaS5ERUZBVUxUX1JFR0lPTl9FTlZ9XCIgZW52aXJvbm1lbnQgdmFyaWFibGUgdG9gLCBlbnZbY3hhcGkuREVGQVVMVF9SRUdJT05fRU5WXSk7XG5cbiAgY29uc3QgYWNjb3VudElkID0gKGF3YWl0IGF3cy5kZWZhdWx0QWNjb3VudCgpKT8uYWNjb3VudElkO1xuICBpZiAoYWNjb3VudElkKSB7XG4gICAgZW52W2N4YXBpLkRFRkFVTFRfQUNDT1VOVF9FTlZdID0gYWNjb3VudElkO1xuICAgIGF3YWl0IGxvZ0ZuKGBTZXR0aW5nIFwiJHtjeGFwaS5ERUZBVUxUX0FDQ09VTlRfRU5WfVwiIGVudmlyb25tZW50IHZhcmlhYmxlIHRvYCwgZW52W2N4YXBpLkRFRkFVTFRfQUNDT1VOVF9FTlZdKTtcbiAgfVxuXG4gIHJldHVybiBlbnY7XG59XG5cbi8qKlxuICogU2V0dGluZ3MgcmVsYXRlZCB0byBzeW50aGVzaXMgYXJlIHJlYWQgZnJvbSBjb250ZXh0LlxuICogVGhlIG1lcmdpbmcgb2YgdmFyaW91cyBjb25maWd1cmF0aW9uIHNvdXJjZXMgbGlrZSBjbGkgYXJncyBvciBjZGsuanNvbiBoYXMgYWxyZWFkeSBoYXBwZW5lZC5cbiAqIFdlIG5vdyBuZWVkIHRvIHNldCB0aGUgZmluYWwgdmFsdWVzIHRvIHRoZSBjb250ZXh0LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUNvbnRleHQoc2V0dGluZ3M6IFNldHRpbmdzLCBjb250ZXh0OiB7W2tleTogc3RyaW5nXTogYW55fSwgZW52OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZH0pIHtcbiAgY29uc3QgZGVidWdNb2RlOiBib29sZWFuID0gc2V0dGluZ3MuZ2V0KFsnZGVidWcnXSkgPz8gdHJ1ZTtcbiAgaWYgKGRlYnVnTW9kZSkge1xuICAgIGVudi5DREtfREVCVUcgPSAndHJ1ZSc7XG4gIH1cblxuICBjb25zdCBwYXRoTWV0YWRhdGE6IGJvb2xlYW4gPSBzZXR0aW5ncy5nZXQoWydwYXRoTWV0YWRhdGEnXSkgPz8gdHJ1ZTtcbiAgaWYgKHBhdGhNZXRhZGF0YSkge1xuICAgIGNvbnRleHRbY3hhcGkuUEFUSF9NRVRBREFUQV9FTkFCTEVfQ09OVEVYVF0gPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgYXNzZXRNZXRhZGF0YTogYm9vbGVhbiA9IHNldHRpbmdzLmdldChbJ2Fzc2V0TWV0YWRhdGEnXSkgPz8gdHJ1ZTtcbiAgaWYgKGFzc2V0TWV0YWRhdGEpIHtcbiAgICBjb250ZXh0W2N4YXBpLkFTU0VUX1JFU09VUkNFX01FVEFEQVRBX0VOQUJMRURfQ09OVEVYVF0gPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgdmVyc2lvblJlcG9ydGluZzogYm9vbGVhbiA9IHNldHRpbmdzLmdldChbJ3ZlcnNpb25SZXBvcnRpbmcnXSkgPz8gdHJ1ZTtcbiAgaWYgKHZlcnNpb25SZXBvcnRpbmcpIHsgY29udGV4dFtjeGFwaS5BTkFMWVRJQ1NfUkVQT1JUSU5HX0VOQUJMRURfQ09OVEVYVF0gPSB0cnVlOyB9XG4gIC8vIFdlIG5lZWQgdG8ga2VlcCBvbiBkb2luZyB0aGlzIGZvciBmcmFtZXdvcmsgdmVyc2lvbiBmcm9tIGJlZm9yZSB0aGlzIGZsYWcgd2FzIGRlcHJlY2F0ZWQuXG4gIGlmICghdmVyc2lvblJlcG9ydGluZykgeyBjb250ZXh0Wydhd3M6Y2RrOmRpc2FibGUtdmVyc2lvbi1yZXBvcnRpbmcnXSA9IHRydWU7IH1cblxuICBjb25zdCBzdGFnaW5nRW5hYmxlZCA9IHNldHRpbmdzLmdldChbJ3N0YWdpbmcnXSkgPz8gdHJ1ZTtcbiAgaWYgKCFzdGFnaW5nRW5hYmxlZCkge1xuICAgIGNvbnRleHRbY3hhcGkuRElTQUJMRV9BU1NFVF9TVEFHSU5HX0NPTlRFWFRdID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGJ1bmRsaW5nU3RhY2tzID0gc2V0dGluZ3MuZ2V0KFsnYnVuZGxpbmdTdGFja3MnXSkgPz8gWycqKiddO1xuICBjb250ZXh0W2N4YXBpLkJVTkRMSU5HX1NUQUNLU10gPSBidW5kbGluZ1N0YWNrcztcblxuICBkZWJ1ZygnY29udGV4dDonLCBjb250ZXh0KTtcblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBNYWtlIHN1cmUgdGhlICdhcHAnIGlzIGFuIGFycmF5XG4gKlxuICogSWYgaXQncyBhIHN0cmluZywgc3BsaXQgb24gc3BhY2VzIGFzIGEgdHJpdmlhbCB3YXkgb2YgdG9rZW5pemluZyB0aGUgY29tbWFuZCBsaW5lLlxuICovXG5mdW5jdGlvbiBhcHBUb0FycmF5KGFwcDogYW55KSB7XG4gIHJldHVybiB0eXBlb2YgYXBwID09PSAnc3RyaW5nJyA/IGFwcC5zcGxpdCgnICcpIDogYXBwO1xufVxuXG50eXBlIENvbW1hbmRHZW5lcmF0b3IgPSAoZmlsZTogc3RyaW5nKSA9PiBzdHJpbmdbXTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBmaWxlIHdpdGggdGhlIHNhbWUgJ25vZGUnIHByb2Nlc3MgYXMgaXMgcnVubmluZyB0aGUgY3VycmVudCBwcm9jZXNzXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVOb2RlKHNjcmlwdEZpbGU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIFtwcm9jZXNzLmV4ZWNQYXRoLCBzY3JpcHRGaWxlXTtcbn1cblxuLyoqXG4gKiBNYXBwaW5nIG9mIGV4dGVuc2lvbnMgdG8gY29tbWFuZC1saW5lIGdlbmVyYXRvcnNcbiAqL1xuY29uc3QgRVhURU5TSU9OX01BUCA9IG5ldyBNYXA8c3RyaW5nLCBDb21tYW5kR2VuZXJhdG9yPihbXG4gIFsnLmpzJywgZXhlY3V0ZU5vZGVdLFxuXSk7XG5cbi8qKlxuICogR3Vlc3MgdGhlIGV4ZWN1dGFibGUgZnJvbSB0aGUgY29tbWFuZC1saW5lIGFyZ3VtZW50XG4gKlxuICogT25seSBkbyB0aGlzIGlmIHRoZSBmaWxlIGlzIE5PVCBtYXJrZWQgYXMgZXhlY3V0YWJsZS4gSWYgaXQgaXMsXG4gKiB3ZSdsbCBkZWZlciB0byB0aGUgc2hlYmFuZyBpbnNpZGUgdGhlIGZpbGUgaXRzZWxmLlxuICpcbiAqIElmIHdlJ3JlIG9uIFdpbmRvd3MsIHdlIEFMV0FZUyB0YWtlIHRoZSBoYW5kbGVyLCBzaW5jZSBpdCdzIGhhcmQgdG9cbiAqIHZlcmlmeSBpZiByZWdpc3RyeSBhc3NvY2lhdGlvbnMgaGF2ZSBvciBoYXZlIG5vdCBiZWVuIHNldCB1cCBmb3IgdGhpc1xuICogZmlsZSB0eXBlLCBzbyB3ZSdsbCBhc3N1bWUgdGhlIHdvcnN0IGFuZCB0YWtlIGNvbnRyb2wuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBndWVzc0V4ZWN1dGFibGUoYXBwOiBzdHJpbmcpIHtcbiAgY29uc3QgY29tbWFuZExpbmUgPSBhcHBUb0FycmF5KGFwcCk7XG4gIGlmIChjb21tYW5kTGluZS5sZW5ndGggPT09IDEpIHtcbiAgICBsZXQgZnN0YXQ7XG5cbiAgICB0cnkge1xuICAgICAgZnN0YXQgPSBhd2FpdCBmcy5zdGF0KGNvbW1hbmRMaW5lWzBdKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGRlYnVnKGBOb3QgYSBmaWxlOiAnJHtjb21tYW5kTGluZVswXX0nLiBVc2luZyAnJHtjb21tYW5kTGluZX0nIGFzIGNvbW1hbmQtbGluZWApO1xuICAgICAgcmV0dXJuIGNvbW1hbmRMaW5lO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgY29uc3QgaXNFeGVjdXRhYmxlID0gKGZzdGF0Lm1vZGUgJiBmcy5jb25zdGFudHMuWF9PSykgIT09IDA7XG4gICAgY29uc3QgaXNXaW5kb3dzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBFWFRFTlNJT05fTUFQLmdldChwYXRoLmV4dG5hbWUoY29tbWFuZExpbmVbMF0pKTtcbiAgICBpZiAoaGFuZGxlciAmJiAoIWlzRXhlY3V0YWJsZSB8fCBpc1dpbmRvd3MpKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcihjb21tYW5kTGluZVswXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb21tYW5kTGluZTtcbn1cblxuZnVuY3Rpb24gY29udGV4dE92ZXJmbG93Q2xlYW51cChsb2NhdGlvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBhc3NlbWJseTogY3hhcGkuQ2xvdWRBc3NlbWJseSkge1xuICBpZiAobG9jYXRpb24pIHtcbiAgICBmcy5yZW1vdmVTeW5jKHBhdGguZGlybmFtZShsb2NhdGlvbikpO1xuXG4gICAgY29uc3QgdHJlZSA9IGxvYWRUcmVlKGFzc2VtYmx5KTtcbiAgICBjb25zdCBmcmFtZXdvcmtEb2VzTm90U3VwcG9ydENvbnRleHRPdmVyZmxvdyA9IHNvbWUodHJlZSwgbm9kZSA9PiB7XG4gICAgICBjb25zdCBmcW4gPSBub2RlLmNvbnN0cnVjdEluZm8/LmZxbjtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBub2RlLmNvbnN0cnVjdEluZm8/LnZlcnNpb247XG4gICAgICByZXR1cm4gKGZxbiA9PT0gJ2F3cy1jZGstbGliLkFwcCcgJiYgdmVyc2lvbiAhPSBudWxsICYmIHNlbXZlci5sdGUodmVyc2lvbiwgJzIuMzguMCcpKVxuICAgICAgICB8fCBmcW4gPT09ICdAYXdzLWNkay9jb3JlLkFwcCc7IC8vIHYxXG4gICAgfSk7XG5cbiAgICAvLyBXZSdyZSBkZWFsaW5nIHdpdGggYW4gb2xkIHZlcnNpb24gb2YgdGhlIGZyYW1ld29yayBoZXJlLiBJdCBpcyB1bmF3YXJlIG9mIHRoZSB0ZW1wb3JhcnlcbiAgICAvLyBmaWxlLCB3aGljaCBtZWFucyB0aGF0IGl0IHdpbGwgaWdub3JlIHRoZSBjb250ZXh0IG92ZXJmbG93LlxuICAgIGlmIChmcmFtZXdvcmtEb2VzTm90U3VwcG9ydENvbnRleHRPdmVyZmxvdykge1xuICAgICAgd2FybmluZygnUGFydCBvZiB0aGUgY29udGV4dCBjb3VsZCBub3QgYmUgc2VudCB0byB0aGUgYXBwbGljYXRpb24uIFBsZWFzZSB1cGRhdGUgdGhlIEFXUyBDREsgbGlicmFyeSB0byB0aGUgbGF0ZXN0IHZlcnNpb24uJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGFjZUF2YWlsYWJsZUZvckNvbnRleHQoZW52OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LCBsaW1pdDogbnVtYmVyKSB7XG4gIGNvbnN0IHNpemUgPSAodmFsdWU6IHN0cmluZykgPT4gdmFsdWUgIT0gbnVsbCA/IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlKSA6IDA7XG5cbiAgY29uc3QgdXNlZFNwYWNlID0gT2JqZWN0LmVudHJpZXMoZW52KVxuICAgIC5tYXAoKFtrLCB2XSkgPT4gayA9PT0gY3hhcGkuQ09OVEVYVF9FTlYgPyBzaXplKGspIDogc2l6ZShrKSArIHNpemUodikpXG4gICAgLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuXG4gIHJldHVybiBNYXRoLm1heCgwLCBsaW1pdCAtIHVzZWRTcGFjZSk7XG59XG4iXX0=