"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassifiedChanges = exports.EcsHotswapProperties = exports.HotswapPropertyOverrides = exports.HotswappableChangeCandidate = exports.HotswapMode = exports.ICON = void 0;
exports.transformObjectKeys = transformObjectKeys;
exports.lowerCaseFirstCharacter = lowerCaseFirstCharacter;
exports.classifyChanges = classifyChanges;
exports.reportNonHotswappableChange = reportNonHotswappableChange;
exports.reportNonHotswappableResource = reportNonHotswappableResource;
const error_1 = require("../../toolkit/error");
exports.ICON = 'âœ¨';
var HotswapMode;
(function (HotswapMode) {
    /**
     * Will fall back to CloudFormation when a non-hotswappable change is detected
     */
    HotswapMode["FALL_BACK"] = "fall-back";
    /**
     * Will not fall back to CloudFormation when a non-hotswappable change is detected
     */
    HotswapMode["HOTSWAP_ONLY"] = "hotswap-only";
    /**
     * Will not attempt to hotswap anything and instead go straight to CloudFormation
     */
    HotswapMode["FULL_DEPLOYMENT"] = "full-deployment";
})(HotswapMode || (exports.HotswapMode = HotswapMode = {}));
/**
 * Represents a change that can be hotswapped.
 */
class HotswappableChangeCandidate {
    constructor(logicalId, oldValue, newValue, propertyUpdates) {
        this.logicalId = logicalId;
        this.oldValue = oldValue;
        this.newValue = newValue;
        this.propertyUpdates = propertyUpdates;
    }
}
exports.HotswappableChangeCandidate = HotswappableChangeCandidate;
/**
 * Represents configuration property overrides for hotswap deployments
 */
class HotswapPropertyOverrides {
    constructor(ecsHotswapProperties) {
        this.ecsHotswapProperties = ecsHotswapProperties;
    }
}
exports.HotswapPropertyOverrides = HotswapPropertyOverrides;
/**
 * Represents configuration properties for ECS hotswap deployments
 */
class EcsHotswapProperties {
    constructor(minimumHealthyPercent, maximumHealthyPercent) {
        if (minimumHealthyPercent !== undefined && minimumHealthyPercent < 0) {
            throw new error_1.ToolkitError('hotswap-ecs-minimum-healthy-percent can\'t be a negative number');
        }
        if (maximumHealthyPercent !== undefined && maximumHealthyPercent < 0) {
            throw new error_1.ToolkitError('hotswap-ecs-maximum-healthy-percent can\'t be a negative number');
        }
        // In order to preserve the current behaviour, when minimumHealthyPercent is not defined, it will be set to the currently default value of 0
        if (minimumHealthyPercent == undefined) {
            this.minimumHealthyPercent = 0;
        }
        else {
            this.minimumHealthyPercent = minimumHealthyPercent;
        }
        this.maximumHealthyPercent = maximumHealthyPercent;
    }
    /**
     * Check if any hotswap properties are defined
     * @returns true if all properties are undefined, false otherwise
    */
    isEmpty() {
        return this.minimumHealthyPercent === 0 && this.maximumHealthyPercent === undefined;
    }
}
exports.EcsHotswapProperties = EcsHotswapProperties;
/**
 * This function transforms all keys (recursively) in the provided `val` object.
 *
 * @param val The object whose keys need to be transformed.
 * @param transform The function that will be applied to each key.
 * @param exclude The keys that will not be transformed and copied to output directly
 * @returns A new object with the same values as `val`, but with all keys transformed according to `transform`.
 */
function transformObjectKeys(val, transform, exclude = {}) {
    if (val == null || typeof val !== 'object') {
        return val;
    }
    if (Array.isArray(val)) {
        // For arrays we just pass parent's exclude object directly
        // since it makes no sense to specify different exclude options for each array element
        return val.map((input) => transformObjectKeys(input, transform, exclude));
    }
    const ret = {};
    for (const [k, v] of Object.entries(val)) {
        const childExclude = exclude[k];
        if (childExclude === true) {
            // we don't transform this object if the key is specified in exclude
            ret[transform(k)] = v;
        }
        else {
            ret[transform(k)] = transformObjectKeys(v, transform, childExclude);
        }
    }
    return ret;
}
/**
 * This function lower cases the first character of the string provided.
 */
function lowerCaseFirstCharacter(str) {
    return str.length > 0 ? `${str[0].toLowerCase()}${str.slice(1)}` : str;
}
class ClassifiedChanges {
    constructor(change, hotswappableProps, nonHotswappableProps) {
        this.change = change;
        this.hotswappableProps = hotswappableProps;
        this.nonHotswappableProps = nonHotswappableProps;
    }
    reportNonHotswappablePropertyChanges(ret) {
        const nonHotswappablePropNames = Object.keys(this.nonHotswappableProps);
        if (nonHotswappablePropNames.length > 0) {
            const tagOnlyChange = nonHotswappablePropNames.length === 1 && nonHotswappablePropNames[0] === 'Tags';
            reportNonHotswappableChange(ret, this.change, this.nonHotswappableProps, tagOnlyChange
                ? 'Tags are not hotswappable'
                : `resource properties '${nonHotswappablePropNames}' are not hotswappable on this resource type`);
        }
    }
    get namesOfHotswappableProps() {
        return Object.keys(this.hotswappableProps);
    }
}
exports.ClassifiedChanges = ClassifiedChanges;
function classifyChanges(xs, hotswappablePropNames) {
    const hotswappableProps = {};
    const nonHotswappableProps = {};
    for (const [name, propDiff] of Object.entries(xs.propertyUpdates)) {
        if (hotswappablePropNames.includes(name)) {
            hotswappableProps[name] = propDiff;
        }
        else {
            nonHotswappableProps[name] = propDiff;
        }
    }
    return new ClassifiedChanges(xs, hotswappableProps, nonHotswappableProps);
}
function reportNonHotswappableChange(ret, change, nonHotswappableProps, reason, hotswapOnlyVisible) {
    let hotswapOnlyVisibility = true;
    if (hotswapOnlyVisible === false) {
        hotswapOnlyVisibility = false;
    }
    ret.push({
        hotswappable: false,
        rejectedChanges: Object.keys(nonHotswappableProps !== null && nonHotswappableProps !== void 0 ? nonHotswappableProps : change.propertyUpdates),
        logicalId: change.logicalId,
        resourceType: change.newValue.Type,
        reason,
        hotswapOnlyVisible: hotswapOnlyVisibility,
    });
}
function reportNonHotswappableResource(change, reason) {
    return [
        {
            hotswappable: false,
            rejectedChanges: Object.keys(change.propertyUpdates),
            logicalId: change.logicalId,
            resourceType: change.newValue.Type,
            reason,
        },
    ];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tbW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQTJKQSxrREFvQkM7QUFLRCwwREFFQztBQStCRCwwQ0FhQztBQUVELGtFQW1CQztBQUVELHNFQWFDO0FBclFELCtDQUFtRDtBQUd0QyxRQUFBLElBQUksR0FBRyxHQUFHLENBQUM7QUE4Q3hCLElBQVksV0FlWDtBQWZELFdBQVksV0FBVztJQUNyQjs7T0FFRztJQUNILHNDQUF1QixDQUFBO0lBRXZCOztPQUVHO0lBQ0gsNENBQTZCLENBQUE7SUFFN0I7O09BRUc7SUFDSCxrREFBbUMsQ0FBQTtBQUNyQyxDQUFDLEVBZlcsV0FBVywyQkFBWCxXQUFXLFFBZXRCO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLDJCQUEyQjtJQXFCdEMsWUFBbUIsU0FBaUIsRUFBRSxRQUFrQixFQUFFLFFBQWtCLEVBQUUsZUFBMEI7UUFDdEcsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFDM0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7SUFDekMsQ0FBQztDQUNGO0FBM0JELGtFQTJCQztBQUlEOztHQUVHO0FBQ0gsTUFBYSx3QkFBd0I7SUFJbkMsWUFBb0Isb0JBQTJDO1FBQzdELElBQUksQ0FBQyxvQkFBb0IsR0FBRyxvQkFBb0IsQ0FBQztJQUNuRCxDQUFDO0NBQ0Y7QUFQRCw0REFPQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxvQkFBb0I7SUFNL0IsWUFBb0IscUJBQThCLEVBQUUscUJBQThCO1FBQ2hGLElBQUkscUJBQXFCLEtBQUssU0FBUyxJQUFJLHFCQUFxQixHQUFHLENBQUMsRUFBRyxDQUFDO1lBQ3RFLE1BQU0sSUFBSSxvQkFBWSxDQUFDLGlFQUFpRSxDQUFDLENBQUM7UUFDNUYsQ0FBQztR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S0FBSyxFQUFFLENBQUM7UUFDakMscUJBQXFCLEdBQUcsS0FBSyxDQUFDO0lBQ2hDLENBQUM7SUFDRCxHQUFHLENBQUMsSUFBSSxDQUFDO1FBQ1AsWUFBWSxFQUFFLEtBQUs7UUFDbkIsZUFBZSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0JBQW9CLGFBQXBCLG9CQUFvQixjQUFwQixvQkFBb0IsR0FBSSxNQUFNLENBQUMsZUFBZSxDQUFDO1FBQzVFLFNBQVMsRUFBRSxNQUFNLENBQUMsU0FBUztRQUMzQixZQUFZLEVBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJO1FBQ2xDLE1BQU07UUFDTixrQkFBa0IsRUFBRSxxQkFBcUI7S0FDMUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELFNBQWdCLDZCQUE2QixDQUMzQyxNQUFtQyxFQUNuQyxNQUFlO0lBRWYsT0FBTztRQUNMO1lBQ0UsWUFBWSxFQUFFLEtBQUs7WUFDbkIsZUFBZSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQztZQUNwRCxTQUFTLEVBQUUsTUFBTSxDQUFDLFNBQVM7WUFDM0IsWUFBWSxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSTtZQUNsQyxNQUFNO1NBQ1A7S0FDRixDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgUHJvcGVydHlEaWZmZXJlbmNlLCBSZXNvdXJjZSB9IGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yIH0gZnJvbSAnLi4vLi4vdG9vbGtpdC9lcnJvcic7XG5pbXBvcnQgdHlwZSB7IFNESyB9IGZyb20gJy4uL2F3cy1hdXRoJztcblxuZXhwb3J0IGNvbnN0IElDT04gPSAn4pyoJztcblxuZXhwb3J0IGludGVyZmFjZSBIb3Rzd2FwcGFibGVDaGFuZ2Uge1xuICByZWFkb25seSBob3Rzd2FwcGFibGU6IHRydWU7XG4gIHJlYWRvbmx5IHJlc291cmNlVHlwZTogc3RyaW5nO1xuICByZWFkb25seSBwcm9wc0NoYW5nZWQ6IEFycmF5PHN0cmluZz47XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgc2VydmljZSBiZWluZyBob3Rzd2FwcGVkLlxuICAgKiBVc2VkIHRvIHNldCBhIGN1c3RvbSBVc2VyLUFnZW50IGZvciBTREsgY2FsbHMuXG4gICAqL1xuICByZWFkb25seSBzZXJ2aWNlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lcyBvZiB0aGUgcmVzb3VyY2VzIGJlaW5nIGhvdHN3YXBwZWQuXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZU5hbWVzOiBzdHJpbmdbXTtcblxuICByZWFkb25seSBhcHBseTogKHNkazogU0RLKSA9PiBQcm9taXNlPHZvaWQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vbkhvdHN3YXBwYWJsZUNoYW5nZSB7XG4gIHJlYWRvbmx5IGhvdHN3YXBwYWJsZTogZmFsc2U7XG4gIHJlYWRvbmx5IHJlc291cmNlVHlwZTogc3RyaW5nO1xuICByZWFkb25seSByZWplY3RlZENoYW5nZXM6IEFycmF5PHN0cmluZz47XG4gIHJlYWRvbmx5IGxvZ2ljYWxJZDogc3RyaW5nO1xuICAvKipcbiAgICogVGVsbHMgdGhlIHVzZXIgZXhhY3RseSB3aHkgdGhpcyBjaGFuZ2Ugd2FzIGRlZW1lZCBub24taG90c3dhcHBhYmxlIGFuZCB3aGF0IGl0cyBsb2dpY2FsIElEIGlzLlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCBgcmVhc29uYCB3aWxsIGJlIGF1dG9maWxsZWQgdG8gc3RhdGUgdGhhdCB0aGUgcHJvcGVydGllcyBsaXN0ZWQgaW4gYHJlamVjdGVkQ2hhbmdlc2AgYXJlIG5vdCBob3Rzd2FwcGFibGUuXG4gICAqL1xuICByZWFkb25seSByZWFzb24/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0byBzaG93IHRoaXMgY2hhbmdlIHdoZW4gbGlzdGluZyBub24taG90c3dhcHBhYmxlIGNoYW5nZXMgaW4gSE9UU1dBUF9PTkxZIG1vZGUuIERvZXMgbm90IGFmZmVjdFxuICAgKiBsaXN0aW5nIGluIEZBTExfQkFDSyBtb2RlLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBob3Rzd2FwT25seVZpc2libGU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBDaGFuZ2VIb3Rzd2FwUmVzdWx0ID0gQXJyYXk8SG90c3dhcHBhYmxlQ2hhbmdlIHwgTm9uSG90c3dhcHBhYmxlQ2hhbmdlPjtcblxuZXhwb3J0IGludGVyZmFjZSBDbGFzc2lmaWVkUmVzb3VyY2VDaGFuZ2VzIHtcbiAgaG90c3dhcHBhYmxlQ2hhbmdlczogSG90c3dhcHBhYmxlQ2hhbmdlW107XG4gIG5vbkhvdHN3YXBwYWJsZUNoYW5nZXM6IE5vbkhvdHN3YXBwYWJsZUNoYW5nZVtdO1xufVxuXG5leHBvcnQgZW51bSBIb3Rzd2FwTW9kZSB7XG4gIC8qKlxuICAgKiBXaWxsIGZhbGwgYmFjayB0byBDbG91ZEZvcm1hdGlvbiB3aGVuIGEgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2UgaXMgZGV0ZWN0ZWRcbiAgICovXG4gIEZBTExfQkFDSyA9ICdmYWxsLWJhY2snLFxuXG4gIC8qKlxuICAgKiBXaWxsIG5vdCBmYWxsIGJhY2sgdG8gQ2xvdWRGb3JtYXRpb24gd2hlbiBhIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlIGlzIGRldGVjdGVkXG4gICAqL1xuICBIT1RTV0FQX09OTFkgPSAnaG90c3dhcC1vbmx5JyxcblxuICAvKipcbiAgICogV2lsbCBub3QgYXR0ZW1wdCB0byBob3Rzd2FwIGFueXRoaW5nIGFuZCBpbnN0ZWFkIGdvIHN0cmFpZ2h0IHRvIENsb3VkRm9ybWF0aW9uXG4gICAqL1xuICBGVUxMX0RFUExPWU1FTlQgPSAnZnVsbC1kZXBsb3ltZW50Jyxcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhbmdlIHRoYXQgY2FuIGJlIGhvdHN3YXBwZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUge1xuICAvKipcbiAgICogVGhlIGxvZ2ljYWwgSUQgb2YgdGhlIHJlc291cmNlIHdoaWNoIGlzIGJlaW5nIGNoYW5nZWRcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBsb2dpY2FsSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHZhbHVlIHRoZSByZXNvdXJjZSBpcyBiZWluZyB1cGRhdGVkIGZyb21cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBvbGRWYWx1ZTogUmVzb3VyY2U7XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSB0aGUgcmVzb3VyY2UgaXMgYmVpbmcgdXBkYXRlZCB0b1xuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IG5ld1ZhbHVlOiBSZXNvdXJjZTtcblxuICAvKipcbiAgICogVGhlIGNoYW5nZXMgbWFkZSB0byB0aGUgcmVzb3VyY2UgcHJvcGVydGllc1xuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHByb3BlcnR5VXBkYXRlczogUHJvcERpZmZzO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihsb2dpY2FsSWQ6IHN0cmluZywgb2xkVmFsdWU6IFJlc291cmNlLCBuZXdWYWx1ZTogUmVzb3VyY2UsIHByb3BlcnR5VXBkYXRlczogUHJvcERpZmZzKSB7XG4gICAgdGhpcy5sb2dpY2FsSWQgPSBsb2dpY2FsSWQ7XG4gICAgdGhpcy5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuICAgIHRoaXMubmV3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB0aGlzLnByb3BlcnR5VXBkYXRlcyA9IHByb3BlcnR5VXBkYXRlcztcbiAgfVxufVxuXG50eXBlIEV4Y2x1ZGUgPSB7IFtrZXk6IHN0cmluZ106IEV4Y2x1ZGUgfCB0cnVlIH07XG5cbi8qKlxuICogUmVwcmVzZW50cyBjb25maWd1cmF0aW9uIHByb3BlcnR5IG92ZXJyaWRlcyBmb3IgaG90c3dhcCBkZXBsb3ltZW50c1xuICovXG5leHBvcnQgY2xhc3MgSG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzIHtcbiAgLy8gRWFjaCBzdXBwb3J0ZWQgcmVzb3VyY2UgdHlwZSB3aWxsIGhhdmUgaXRzIG93biBwcm9wZXJ0aWVzLiBDdXJyZW50bHkgdGhpcyBpcyBFQ1NcbiAgZWNzSG90c3dhcFByb3BlcnRpZXM/OiBFY3NIb3Rzd2FwUHJvcGVydGllcztcblxuICBwdWJsaWMgY29uc3RydWN0b3IgKGVjc0hvdHN3YXBQcm9wZXJ0aWVzPzogRWNzSG90c3dhcFByb3BlcnRpZXMpIHtcbiAgICB0aGlzLmVjc0hvdHN3YXBQcm9wZXJ0aWVzID0gZWNzSG90c3dhcFByb3BlcnRpZXM7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBmb3IgRUNTIGhvdHN3YXAgZGVwbG95bWVudHNcbiAqL1xuZXhwb3J0IGNsYXNzIEVjc0hvdHN3YXBQcm9wZXJ0aWVzIHtcbiAgLy8gVGhlIGxvd2VyIGxpbWl0IG9uIHRoZSBudW1iZXIgb2YgeW91ciBzZXJ2aWNlJ3MgdGFza3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgUlVOTklORyBzdGF0ZSBkdXJpbmcgYSBkZXBsb3ltZW50LCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGRlc2lyZWRDb3VudFxuICByZWFkb25seSBtaW5pbXVtSGVhbHRoeVBlcmNlbnQ/OiBudW1iZXI7XG4gIC8vIFRoZSB1cHBlciBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIHlvdXIgc2VydmljZSdzIHRhc2tzIHRoYXQgYXJlIGFsbG93ZWQgaW4gdGhlIFJVTk5JTkcgb3IgUEVORElORyBzdGF0ZSBkdXJpbmcgYSBkZXBsb3ltZW50LCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGRlc2lyZWRDb3VudFxuICByZWFkb25seSBtYXhpbXVtSGVhbHRoeVBlcmNlbnQ/OiBudW1iZXI7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yIChtaW5pbXVtSGVhbHRoeVBlcmNlbnQ/OiBudW1iZXIsIG1heGltdW1IZWFsdGh5UGVyY2VudD86IG51bWJlcikge1xuICAgIGlmIChtaW5pbXVtSGVhbHRoeVBlcmNlbnQgIT09IHVuZGVmaW5lZCAmJiBtaW5pbXVtSGVhbHRoeVBlcmNlbnQgPCAwICkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignaG90c3dhcC1lY3MtbWluaW11bS1oZWFsdGh5LXBlcmNlbnQgY2FuXFwndCBiZSBhIG5lZ2F0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAobWF4aW11bUhlYWx0aHlQZXJjZW50ICE9PSB1bmRlZmluZWQgJiYgbWF4aW11bUhlYWx0aHlQZXJjZW50IDwgMCApIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ2hvdHN3YXAtZWNzLW1heGltdW0taGVhbHRoeS1wZXJjZW50IGNhblxcJ3QgYmUgYSBuZWdhdGl2ZSBudW1iZXInKTtcbiAgICB9XG4gICAgLy8gSW4gb3JkZXIgdG8gcHJlc2VydmUgdGhlIGN1cnJlbnQgYmVoYXZpb3VyLCB3aGVuIG1pbmltdW1IZWFsdGh5UGVyY2VudCBpcyBub3QgZGVmaW5lZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnRseSBkZWZhdWx0IHZhbHVlIG9mIDBcbiAgICBpZiAobWluaW11bUhlYWx0aHlQZXJjZW50ID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5taW5pbXVtSGVhbHRoeVBlcmNlbnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1pbmltdW1IZWFsdGh5UGVyY2VudCA9IG1pbmltdW1IZWFsdGh5UGVyY2VudDtcbiAgICB9XG4gICAgdGhpcy5tYXhpbXVtSGVhbHRoeVBlcmNlbnQgPSBtYXhpbXVtSGVhbHRoeVBlcmNlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW55IGhvdHN3YXAgcHJvcGVydGllcyBhcmUgZGVmaW5lZFxuICAgKiBAcmV0dXJucyB0cnVlIGlmIGFsbCBwcm9wZXJ0aWVzIGFyZSB1bmRlZmluZWQsIGZhbHNlIG90aGVyd2lzZVxuICAqL1xuICBwdWJsaWMgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5taW5pbXVtSGVhbHRoeVBlcmNlbnQgPT09IDAgJiYgdGhpcy5tYXhpbXVtSGVhbHRoeVBlcmNlbnQgPT09IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gdHJhbnNmb3JtcyBhbGwga2V5cyAocmVjdXJzaXZlbHkpIGluIHRoZSBwcm92aWRlZCBgdmFsYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbCBUaGUgb2JqZWN0IHdob3NlIGtleXMgbmVlZCB0byBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB0cmFuc2Zvcm0gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGVhY2gga2V5LlxuICogQHBhcmFtIGV4Y2x1ZGUgVGhlIGtleXMgdGhhdCB3aWxsIG5vdCBiZSB0cmFuc2Zvcm1lZCBhbmQgY29waWVkIHRvIG91dHB1dCBkaXJlY3RseVxuICogQHJldHVybnMgQSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIGB2YWxgLCBidXQgd2l0aCBhbGwga2V5cyB0cmFuc2Zvcm1lZCBhY2NvcmRpbmcgdG8gYHRyYW5zZm9ybWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1PYmplY3RLZXlzKHZhbDogYW55LCB0cmFuc2Zvcm06IChzdHI6IHN0cmluZykgPT4gc3RyaW5nLCBleGNsdWRlOiBFeGNsdWRlID0ge30pOiBhbnkge1xuICBpZiAodmFsID09IG51bGwgfHwgdHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAvLyBGb3IgYXJyYXlzIHdlIGp1c3QgcGFzcyBwYXJlbnQncyBleGNsdWRlIG9iamVjdCBkaXJlY3RseVxuICAgIC8vIHNpbmNlIGl0IG1ha2VzIG5vIHNlbnNlIHRvIHNwZWNpZnkgZGlmZmVyZW50IGV4Y2x1ZGUgb3B0aW9ucyBmb3IgZWFjaCBhcnJheSBlbGVtZW50XG4gICAgcmV0dXJuIHZhbC5tYXAoKGlucHV0OiBhbnkpID0+IHRyYW5zZm9ybU9iamVjdEtleXMoaW5wdXQsIHRyYW5zZm9ybSwgZXhjbHVkZSkpO1xuICB9XG4gIGNvbnN0IHJldDogeyBbazogc3RyaW5nXTogYW55IH0gPSB7fTtcbiAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModmFsKSkge1xuICAgIGNvbnN0IGNoaWxkRXhjbHVkZSA9IGV4Y2x1ZGVba107XG4gICAgaWYgKGNoaWxkRXhjbHVkZSA9PT0gdHJ1ZSkge1xuICAgICAgLy8gd2UgZG9uJ3QgdHJhbnNmb3JtIHRoaXMgb2JqZWN0IGlmIHRoZSBrZXkgaXMgc3BlY2lmaWVkIGluIGV4Y2x1ZGVcbiAgICAgIHJldFt0cmFuc2Zvcm0oayldID0gdjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0W3RyYW5zZm9ybShrKV0gPSB0cmFuc2Zvcm1PYmplY3RLZXlzKHYsIHRyYW5zZm9ybSwgY2hpbGRFeGNsdWRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGxvd2VyIGNhc2VzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZyBwcm92aWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvd2VyQ2FzZUZpcnN0Q2hhcmFjdGVyKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0ci5sZW5ndGggPiAwID8gYCR7c3RyWzBdLnRvTG93ZXJDYXNlKCl9JHtzdHIuc2xpY2UoMSl9YCA6IHN0cjtcbn1cblxuZXhwb3J0IHR5cGUgUHJvcERpZmZzID0gUmVjb3JkPHN0cmluZywgUHJvcGVydHlEaWZmZXJlbmNlPGFueT4+O1xuXG5leHBvcnQgY2xhc3MgQ2xhc3NpZmllZENoYW5nZXMge1xuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLFxuICAgIHB1YmxpYyByZWFkb25seSBob3Rzd2FwcGFibGVQcm9wczogUHJvcERpZmZzLFxuICAgIHB1YmxpYyByZWFkb25seSBub25Ib3Rzd2FwcGFibGVQcm9wczogUHJvcERpZmZzLFxuICApIHt9XG5cbiAgcHVibGljIHJlcG9ydE5vbkhvdHN3YXBwYWJsZVByb3BlcnR5Q2hhbmdlcyhyZXQ6IENoYW5nZUhvdHN3YXBSZXN1bHQpOiB2b2lkIHtcbiAgICBjb25zdCBub25Ib3Rzd2FwcGFibGVQcm9wTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLm5vbkhvdHN3YXBwYWJsZVByb3BzKTtcbiAgICBpZiAobm9uSG90c3dhcHBhYmxlUHJvcE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRhZ09ubHlDaGFuZ2UgPSBub25Ib3Rzd2FwcGFibGVQcm9wTmFtZXMubGVuZ3RoID09PSAxICYmIG5vbkhvdHN3YXBwYWJsZVByb3BOYW1lc1swXSA9PT0gJ1RhZ3MnO1xuICAgICAgcmVwb3J0Tm9uSG90c3dhcHBhYmxlQ2hhbmdlKFxuICAgICAgICByZXQsXG4gICAgICAgIHRoaXMuY2hhbmdlLFxuICAgICAgICB0aGlzLm5vbkhvdHN3YXBwYWJsZVByb3BzLFxuICAgICAgICB0YWdPbmx5Q2hhbmdlXG4gICAgICAgICAgPyAnVGFncyBhcmUgbm90IGhvdHN3YXBwYWJsZSdcbiAgICAgICAgICA6IGByZXNvdXJjZSBwcm9wZXJ0aWVzICcke25vbkhvdHN3YXBwYWJsZVByb3BOYW1lc30nIGFyZSBub3QgaG90c3dhcHBhYmxlIG9uIHRoaXMgcmVzb3VyY2UgdHlwZWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgbmFtZXNPZkhvdHN3YXBwYWJsZVByb3BzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5ob3Rzd2FwcGFibGVQcm9wcyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzaWZ5Q2hhbmdlcyh4czogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBob3Rzd2FwcGFibGVQcm9wTmFtZXM6IHN0cmluZ1tdKTogQ2xhc3NpZmllZENoYW5nZXMge1xuICBjb25zdCBob3Rzd2FwcGFibGVQcm9wczogUHJvcERpZmZzID0ge307XG4gIGNvbnN0IG5vbkhvdHN3YXBwYWJsZVByb3BzOiBQcm9wRGlmZnMgPSB7fTtcblxuICBmb3IgKGNvbnN0IFtuYW1lLCBwcm9wRGlmZl0gb2YgT2JqZWN0LmVudHJpZXMoeHMucHJvcGVydHlVcGRhdGVzKSkge1xuICAgIGlmIChob3Rzd2FwcGFibGVQcm9wTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgIGhvdHN3YXBwYWJsZVByb3BzW25hbWVdID0gcHJvcERpZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vbkhvdHN3YXBwYWJsZVByb3BzW25hbWVdID0gcHJvcERpZmY7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBDbGFzc2lmaWVkQ2hhbmdlcyh4cywgaG90c3dhcHBhYmxlUHJvcHMsIG5vbkhvdHN3YXBwYWJsZVByb3BzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShcbiAgcmV0OiBDaGFuZ2VIb3Rzd2FwUmVzdWx0LFxuICBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSxcbiAgbm9uSG90c3dhcHBhYmxlUHJvcHM/OiBQcm9wRGlmZnMsXG4gIHJlYXNvbj86IHN0cmluZyxcbiAgaG90c3dhcE9ubHlWaXNpYmxlPzogYm9vbGVhbixcbik6IHZvaWQge1xuICBsZXQgaG90c3dhcE9ubHlWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgaWYgKGhvdHN3YXBPbmx5VmlzaWJsZSA9PT0gZmFsc2UpIHtcbiAgICBob3Rzd2FwT25seVZpc2liaWxpdHkgPSBmYWxzZTtcbiAgfVxuICByZXQucHVzaCh7XG4gICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICByZWplY3RlZENoYW5nZXM6IE9iamVjdC5rZXlzKG5vbkhvdHN3YXBwYWJsZVByb3BzID8/IGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXMpLFxuICAgIGxvZ2ljYWxJZDogY2hhbmdlLmxvZ2ljYWxJZCxcbiAgICByZXNvdXJjZVR5cGU6IGNoYW5nZS5uZXdWYWx1ZS5UeXBlLFxuICAgIHJlYXNvbixcbiAgICBob3Rzd2FwT25seVZpc2libGU6IGhvdHN3YXBPbmx5VmlzaWJpbGl0eSxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBvcnROb25Ib3Rzd2FwcGFibGVSZXNvdXJjZShcbiAgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsXG4gIHJlYXNvbj86IHN0cmluZyxcbik6IENoYW5nZUhvdHN3YXBSZXN1bHQge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgICByZWplY3RlZENoYW5nZXM6IE9iamVjdC5rZXlzKGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXMpLFxuICAgICAgbG9naWNhbElkOiBjaGFuZ2UubG9naWNhbElkLFxuICAgICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICAgIHJlYXNvbixcbiAgICB9LFxuICBdO1xufVxuIl19