"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableEcsServiceChange = isHotswappableEcsServiceChange;
const common_1 = require("./common");
async function isHotswappableEcsServiceChange(logicalId, change, evaluateCfnTemplate, hotswapPropertyOverrides) {
    // the only resource change we can evaluate here is an ECS TaskDefinition
    if (change.newValue.Type !== 'AWS::ECS::TaskDefinition') {
        return [];
    }
    const ret = [];
    // We only allow a change in the ContainerDefinitions of the TaskDefinition for now -
    // it contains the image and environment variables, so seems like a safe bet for now.
    // We might revisit this decision in the future though!
    const classifiedChanges = (0, common_1.classifyChanges)(change, ['ContainerDefinitions']);
    classifiedChanges.reportNonHotswappablePropertyChanges(ret);
    // find all ECS Services that reference the TaskDefinition that changed
    const resourcesReferencingTaskDef = evaluateCfnTemplate.findReferencesTo(logicalId);
    const ecsServiceResourcesReferencingTaskDef = resourcesReferencingTaskDef.filter((r) => r.Type === 'AWS::ECS::Service');
    const ecsServicesReferencingTaskDef = new Array();
    for (const ecsServiceResource of ecsServiceResourcesReferencingTaskDef) {
        const serviceArn = await evaluateCfnTemplate.findPhysicalNameFor(ecsServiceResource.LogicalId);
        if (serviceArn) {
            ecsServicesReferencingTaskDef.push({ serviceArn });
        }
    }
    if (ecsServicesReferencingTaskDef.length === 0) {
        // if there are no resources referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        (0, common_1.reportNonHotswappableChange)(ret, change, undefined, 'No ECS services reference the changed task definition', false);
    }
    if (resourcesReferencingTaskDef.length > ecsServicesReferencingTaskDef.length) {
        // if something besides an ECS Service is referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        const nonEcsServiceTaskDefRefs = resourcesReferencingTaskDef.filter((r) => r.Type !== 'AWS::ECS::Service');
        for (const taskRef of nonEcsServiceTaskDefRefs) {
            (0, common_1.reportNonHotswappableChange)(ret, change, undefined, `A resource '${taskRef.LogicalId}' with Type '${taskRef.Type}' that is not an ECS Service was found referencing the changed TaskDefinition '${logicalId}'`);
        }
    }
    const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
    if (namesOfHotswappableChanges.length > 0) {
        const taskDefinitionResource = await prepareTaskDefinitionChange(evaluateCfnTemplate, logicalId, change);
        ret.push({
            hotswappable: true,
            resourceType: change.newValue.Type,
            propsChanged: namesOfHotswappableChanges,
            service: 'ecs-service',
            resourceNames: [
                `ECS Task Definition '${await taskDefinitionResource.Family}'`,
                ...ecsServicesReferencingTaskDef.map((ecsService) => `ECS Service '${ecsService.serviceArn.split('/')[2]}'`),
            ],
            apply: async (sdk) => {
                // Step 1 - update the changed TaskDefinition, creating a new TaskDefinition Revision
                // we need to lowercase the evaluated TaskDef from CloudFormation,
                // as the AWS SDK uses lowercase property names for these
                var _a;
                // The SDK requires more properties here than its worth doing explicit typing for
                // instead, just use all the old values in the diff to fill them in implicitly
                const lowercasedTaskDef = (0, common_1.transformObjectKeys)(taskDefinitionResource, common_1.lowerCaseFirstCharacter, {
                    // All the properties that take arbitrary string as keys i.e. { "string" : "string" }
                    // https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RegisterTaskDefinition.html#API_RegisterTaskDefinition_RequestSyntax
                    ContainerDefinitions: {
                        DockerLabels: true,
                        FirelensConfiguration: {
                            Options: true,
                        },
                        LogConfiguration: {
                            Options: true,
                        },
                    },
                    Volumes: {
                        DockerVolumeConfiguration: {
                            DriverOpts: true,
                            Labels: true,
                        },
                    },
                });
                const registerTaskDefResponse = await sdk.ecs().registerTaskDefinition(lowercasedTaskDef);
                const taskDefRevArn = (_a = registerTaskDefResponse.taskDefinition) === null || _a === void 0 ? void 0 : _a.taskDefinitionArn;
                let ecsHotswapProperties = hotswapPropertyOverrides.ecsHotswapProperties;
                let minimumHealthyPercent = ecsHotswapProperties === null || ecsHotswapProperties === void 0 ? void 0 : ecsHotswapProperties.minimumHealthyPercent;
                let maximumHealthyPercent = ecsHotswapProperties === null || ecsHotswapProperties === void 0 ? void 0 : ecsHotswapProperties.maximumHealthyPercent;
                // Step 2 - update the services using that TaskDefinition to point to the new TaskDefinition Revision
                // Forcing New Deployment and setting Minimum Healthy Percent to 0.
                // As CDK HotSwap is development only, this seems the most efficient way to ensure all tasks are replaced immediately, regardless of original amount
                // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
                await Promise.all(ecsServicesReferencingTaskDef.map(async (service) => {
                    var _a;
                    const cluster = service.serviceArn.split('/')[1];
                    const update = await sdk.ecs().updateService({
                        service: service.serviceArn,
                        taskDefinition: taskDefRevArn,
                        cluster,
                        forceNewDeployment: true,
                        deploymentConfiguration: {
                            minimumHealthyPercent: minimumHealthyPercent !== undefined ? minimumHealthyPercent : 0,
                            maximumPercent: maximumHealthyPercent !== undefined ? maximumHealthyPercent : undefined,
                        },
                    });
                    await sdk.ecs().waitUntilServicesStable({
                        cluster: (_a = update.service) === null || _a === void 0 ? void 0 : _a.clusterArn,
                        services: [service.serviceArn],
                    });
                }));
            },
        });
    }
    return ret;
}
async function prepareTaskDefinitionChange(evaluateCfnTemplate, logicalId, change) {
    var _a;
    const taskDefinitionResource = {
        ...change.oldValue.Properties,
        ContainerDefinitions: (_a = change.newValue.Properties) === null || _a === void 0 ? void 0 : _a.ContainerDefinitions,
    };
    // first, let's get the name of the family
    const familyNameOrArn = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, taskDefinitionResource === null || taskDefinitionResource === void 0 ? void 0 : taskDefinitionResource.Family);
    if (!familyNameOrArn) {
        // if the Family property has not been provided, and we can't find it in the current Stack,
        // this means hotswapping is not possible
        return;
    }
    // the physical name of the Task Definition in CloudFormation includes its current revision number at the end,
    // remove it if needed
    const familyNameOrArnParts = familyNameOrArn.split(':');
    const family = familyNameOrArnParts.length > 1
        ? // familyNameOrArn is actually an ARN, of the format 'arn:aws:ecs:region:account:task-definition/<family-name>:<revision-nr>'
            // so, take the 6th element, at index 5, and split it on '/'
            familyNameOrArnParts[5].split('/')[1]
        : // otherwise, familyNameOrArn is just the simple name evaluated from the CloudFormation template
            familyNameOrArn;
    // then, let's evaluate the body of the remainder of the TaskDef (without the Family property)
    return {
        ...(await evaluateCfnTemplate.evaluateCfnExpression({
            ...(taskDefinitionResource !== null && taskDefinitionResource !== void 0 ? taskDefinitionResource : {}),
            Family: undefined,
        })),
        Family: family,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNzLXNlcnZpY2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZWNzLXNlcnZpY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBV0Esd0VBNEhDO0FBdklELHFDQU9rQjtBQUlYLEtBQUssVUFBVSw4QkFBOEIsQ0FDbEQsU0FBaUIsRUFDakIsTUFBbUMsRUFDbkMsbUJBQW1ELEVBQ25ELHdCQUFrRDtJQUVsRCx5RUFBeUU7SUFDekUsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSywwQkFBMEIsRUFBRSxDQUFDO1FBQ3hELE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUVELE1BQU0sR0FBRyxHQUF3QixFQUFFLENBQUM7SUFFcEMscUZBQXFGO0lBQ3JGLHFGQUFxRjtJQUNyRix1REFBdUQ7SUFDdkQsTUFBTSxpQkFBaUIsR0FBRyxJQUFBLHdCQUFlLEVBQUMsTUFBTSxFQUFFLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDO0lBQzVFLGlCQUFpQixDQUFDLG9DQUFvQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRTVELHVFQUF1RTtJQUN2RSxNQUFNLDJCQUEyQixHQUFHLG1CQUFtQixDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3BGLE1BQU0scUNBQXFDLEdBQUcsMkJBQTJCLENBQUMsTUFBTSxDQUM5RSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxtQkFBbUIsQ0FDdEMsQ0FBQztJQUNGLE1BQU0sNkJBQTZCLEdBQUcsSUFBSSxLQUFLLEVBQWMsQ0FBQztJQUM5RCxLQUFLLE1BQU0sa0JBQWtCLElBQUkscUNBQXFDLEVBQUUsQ0FBQztRQUN2RSxNQUFNLFVBQVUsR0FBRyxNQUFNLG1CQUFtQixDQUFDLG1CQUFtQixDQUFDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQy9GLElBQUksVUFBVSxFQUFFLENBQUM7WUFDZiw2QkFBNkIsQ0FBQyxJQUFJLENBQUMs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c0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgdHlwZSBDaGFuZ2VIb3Rzd2FwUmVzdWx0LFxuICBjbGFzc2lmeUNoYW5nZXMsXG4gIHR5cGUgSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLFxuICBIb3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsIGxvd2VyQ2FzZUZpcnN0Q2hhcmFjdGVyLFxuICByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UsXG4gIHRyYW5zZm9ybU9iamVjdEtleXMsXG59IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB0eXBlIHsgU0RLIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHR5cGUgeyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUgfSBmcm9tICcuLi9ldmFsdWF0ZS1jbG91ZGZvcm1hdGlvbi10ZW1wbGF0ZSc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc0hvdHN3YXBwYWJsZUVjc1NlcnZpY2VDaGFuZ2UoXG4gIGxvZ2ljYWxJZDogc3RyaW5nLFxuICBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSxcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXM6IEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbik6IFByb21pc2U8Q2hhbmdlSG90c3dhcFJlc3VsdD4ge1xuICAvLyB0aGUgb25seSByZXNvdXJjZSBjaGFuZ2Ugd2UgY2FuIGV2YWx1YXRlIGhlcmUgaXMgYW4gRUNTIFRhc2tEZWZpbml0aW9uXG4gIGlmIChjaGFuZ2UubmV3VmFsdWUuVHlwZSAhPT0gJ0FXUzo6RUNTOjpUYXNrRGVmaW5pdGlvbicpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCByZXQ6IENoYW5nZUhvdHN3YXBSZXN1bHQgPSBbXTtcblxuICAvLyBXZSBvbmx5IGFsbG93IGEgY2hhbmdlIGluIHRoZSBDb250YWluZXJEZWZpbml0aW9ucyBvZiB0aGUgVGFza0RlZmluaXRpb24gZm9yIG5vdyAtXG4gIC8vIGl0IGNvbnRhaW5zIHRoZSBpbWFnZSBhbmQgZW52aXJvbm1lbnQgdmFyaWFibGVzLCBzbyBzZWVtcyBsaWtlIGEgc2FmZSBiZXQgZm9yIG5vdy5cbiAgLy8gV2UgbWlnaHQgcmV2aXNpdCB0aGlzIGRlY2lzaW9uIGluIHRoZSBmdXR1cmUgdGhvdWdoIVxuICBjb25zdCBjbGFzc2lmaWVkQ2hhbmdlcyA9IGNsYXNzaWZ5Q2hhbmdlcyhjaGFuZ2UsIFsnQ29udGFpbmVyRGVmaW5pdGlvbnMnXSk7XG4gIGNsYXNzaWZpZWRDaGFuZ2VzLnJlcG9ydE5vbkhvdHN3YXBwYWJsZVByb3BlcnR5Q2hhbmdlcyhyZXQpO1xuXG4gIC8vIGZpbmQgYWxsIEVDUyBTZXJ2aWNlcyB0aGF0IHJlZmVyZW5jZSB0aGUgVGFza0RlZmluaXRpb24gdGhhdCBjaGFuZ2VkXG4gIGNvbnN0IHJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZiA9IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZFJlZmVyZW5jZXNUbyhsb2dpY2FsSWQpO1xuICBjb25zdCBlY3NTZXJ2aWNlUmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmID0gcmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmZpbHRlcihcbiAgICAocikgPT4gci5UeXBlID09PSAnQVdTOjpFQ1M6OlNlcnZpY2UnLFxuICApO1xuICBjb25zdCBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZiA9IG5ldyBBcnJheTxFY3NTZXJ2aWNlPigpO1xuICBmb3IgKGNvbnN0IGVjc1NlcnZpY2VSZXNvdXJjZSBvZiBlY3NTZXJ2aWNlUmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmKSB7XG4gICAgY29uc3Qgc2VydmljZUFybiA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZFBoeXNpY2FsTmFtZUZvcihlY3NTZXJ2aWNlUmVzb3VyY2UuTG9naWNhbElkKTtcbiAgICBpZiAoc2VydmljZUFybikge1xuICAgICAgZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYucHVzaCh7IHNlcnZpY2VBcm4gfSk7XG4gICAgfVxuICB9XG4gIGlmIChlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5sZW5ndGggPT09IDApIHtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcmVzb3VyY2VzIHJlZmVyZW5jaW5nIHRoZSBUYXNrRGVmaW5pdGlvbixcbiAgICAvLyBob3Rzd2FwIGlzIG5vdCBwb3NzaWJsZSBpbiBGQUxMX0JBQ0sgbW9kZVxuICAgIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShyZXQsIGNoYW5nZSwgdW5kZWZpbmVkLCAnTm8gRUNTIHNlcnZpY2VzIHJlZmVyZW5jZSB0aGUgY2hhbmdlZCB0YXNrIGRlZmluaXRpb24nLCBmYWxzZSk7XG4gIH1cbiAgaWYgKHJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZi5sZW5ndGggPiBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5sZW5ndGgpIHtcbiAgICAvLyBpZiBzb21ldGhpbmcgYmVzaWRlcyBhbiBFQ1MgU2VydmljZSBpcyByZWZlcmVuY2luZyB0aGUgVGFza0RlZmluaXRpb24sXG4gICAgLy8gaG90c3dhcCBpcyBub3QgcG9zc2libGUgaW4gRkFMTF9CQUNLIG1vZGVcbiAgICBjb25zdCBub25FY3NTZXJ2aWNlVGFza0RlZlJlZnMgPSByZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYuZmlsdGVyKChyKSA9PiByLlR5cGUgIT09ICdBV1M6OkVDUzo6U2VydmljZScpO1xuICAgIGZvciAoY29uc3QgdGFza1JlZiBvZiBub25FY3NTZXJ2aWNlVGFza0RlZlJlZnMpIHtcbiAgICAgIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShcbiAgICAgICAgcmV0LFxuICAgICAgICBjaGFuZ2UsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgYEEgcmVzb3VyY2UgJyR7dGFza1JlZi5Mb2dpY2FsSWR9JyB3aXRoIFR5cGUgJyR7dGFza1JlZi5UeXBlfScgdGhhdCBpcyBub3QgYW4gRUNTIFNlcnZpY2Ugd2FzIGZvdW5kIHJlZmVyZW5jaW5nIHRoZSBjaGFuZ2VkIFRhc2tEZWZpbml0aW9uICcke2xvZ2ljYWxJZH0nYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmFtZXNPZkhvdHN3YXBwYWJsZUNoYW5nZXMgPSBPYmplY3Qua2V5cyhjbGFzc2lmaWVkQ2hhbmdlcy5ob3Rzd2FwcGFibGVQcm9wcyk7XG4gIGlmIChuYW1lc09mSG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgdGFza0RlZmluaXRpb25SZXNvdXJjZSA9IGF3YWl0IHByZXBhcmVUYXNrRGVmaW5pdGlvbkNoYW5nZShldmFsdWF0ZUNmblRlbXBsYXRlLCBsb2dpY2FsSWQsIGNoYW5nZSk7XG4gICAgcmV0LnB1c2goe1xuICAgICAgaG90c3dhcHBhYmxlOiB0cnVlLFxuICAgICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICAgIHByb3BzQ2hhbmdlZDogbmFtZXNPZkhvdHN3YXBwYWJsZUNoYW5nZXMsXG4gICAgICBzZXJ2aWNlOiAnZWNzLXNlcnZpY2UnLFxuICAgICAgcmVzb3VyY2VOYW1lczogW1xuICAgICAgICBgRUNTIFRhc2sgRGVmaW5pdGlvbiAnJHthd2FpdCB0YXNrRGVmaW5pdGlvblJlc291cmNlLkZhbWlseX0nYCxcbiAgICAgICAgLi4uZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubWFwKChlY3NTZXJ2aWNlKSA9PiBgRUNTIFNlcnZpY2UgJyR7ZWNzU2VydmljZS5zZXJ2aWNlQXJuLnNwbGl0KCcvJylbMl19J2ApLFxuICAgICAgXSxcbiAgICAgIGFwcGx5OiBhc3luYyAoc2RrOiBTREspID0+IHtcbiAgICAgICAgLy8gU3RlcCAxIC0gdXBkYXRlIHRoZSBjaGFuZ2VkIFRhc2tEZWZpbml0aW9uLCBjcmVhdGluZyBhIG5ldyBUYXNrRGVmaW5pdGlvbiBSZXZpc2lvblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGxvd2VyY2FzZSB0aGUgZXZhbHVhdGVkIFRhc2tEZWYgZnJvbSBDbG91ZEZvcm1hdGlvbixcbiAgICAgICAgLy8gYXMgdGhlIEFXUyBTREsgdXNlcyBsb3dlcmNhc2UgcHJvcGVydHkgbmFtZXMgZm9yIHRoZXNlXG5cbiAgICAgICAgLy8gVGhlIFNESyByZXF1aXJlcyBtb3JlIHByb3BlcnRpZXMgaGVyZSB0aGFuIGl0cyB3b3J0aCBkb2luZyBleHBsaWNpdCB0eXBpbmcgZm9yXG4gICAgICAgIC8vIGluc3RlYWQsIGp1c3QgdXNlIGFsbCB0aGUgb2xkIHZhbHVlcyBpbiB0aGUgZGlmZiB0byBmaWxsIHRoZW0gaW4gaW1wbGljaXRseVxuICAgICAgICBjb25zdCBsb3dlcmNhc2VkVGFza0RlZiA9IHRyYW5zZm9ybU9iamVjdEtleXModGFza0RlZmluaXRpb25SZXNvdXJjZSwgbG93ZXJDYXNlRmlyc3RDaGFyYWN0ZXIsIHtcbiAgICAgICAgICAvLyBBbGwgdGhlIHByb3BlcnRpZXMgdGhhdCB0YWtlIGFyYml0cmFyeSBzdHJpbmcgYXMga2V5cyBpLmUuIHsgXCJzdHJpbmdcIiA6IFwic3RyaW5nXCIgfVxuICAgICAgICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25FQ1MvbGF0ZXN0L0FQSVJlZmVyZW5jZS9BUElfUmVnaXN0ZXJUYXNrRGVmaW5pdGlvbi5odG1sI0FQSV9SZWdpc3RlclRhc2tEZWZpbml0aW9uX1JlcXVlc3RTeW50YXhcbiAgICAgICAgICBDb250YWluZXJEZWZpbml0aW9uczoge1xuICAgICAgICAgICAgRG9ja2VyTGFiZWxzOiB0cnVlLFxuICAgICAgICAgICAgRmlyZWxlbnNDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgIE9wdGlvbnM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTG9nQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICBPcHRpb25zOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFZvbHVtZXM6IHtcbiAgICAgICAgICAgIERvY2tlclZvbHVtZUNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgRHJpdmVyT3B0czogdHJ1ZSxcbiAgICAgICAgICAgICAgTGFiZWxzOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJUYXNrRGVmUmVzcG9uc2UgPSBhd2FpdCBzZGsuZWNzKCkucmVnaXN0ZXJUYXNrRGVmaW5pdGlvbihsb3dlcmNhc2VkVGFza0RlZik7XG4gICAgICAgIGNvbnN0IHRhc2tEZWZSZXZBcm4gPSByZWdpc3RlclRhc2tEZWZSZXNwb25zZS50YXNrRGVmaW5pdGlvbj8udGFza0RlZmluaXRpb25Bcm47XG5cbiAgICAgICAgbGV0IGVjc0hvdHN3YXBQcm9wZXJ0aWVzID0gaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLmVjc0hvdHN3YXBQcm9wZXJ0aWVzO1xuICAgICAgICBsZXQgbWluaW11bUhlYWx0aHlQZXJjZW50ID0gZWNzSG90c3dhcFByb3BlcnRpZXM/Lm1pbmltdW1IZWFsdGh5UGVyY2VudDtcbiAgICAgICAgbGV0IG1heGltdW1IZWFsdGh5UGVyY2VudCA9IGVjc0hvdHN3YXBQcm9wZXJ0aWVzPy5tYXhpbXVtSGVhbHRoeVBlcmNlbnQ7XG5cbiAgICAgICAgLy8gU3RlcCAyIC0gdXBkYXRlIHRoZSBzZXJ2aWNlcyB1c2luZyB0aGF0IFRhc2tEZWZpbml0aW9uIHRvIHBvaW50IHRvIHRoZSBuZXcgVGFza0RlZmluaXRpb24gUmV2aXNpb25cbiAgICAgICAgLy8gRm9yY2luZyBOZXcgRGVwbG95bWVudCBhbmQgc2V0dGluZyBNaW5pbXVtIEhlYWx0aHkgUGVyY2VudCB0byAwLlxuICAgICAgICAvLyBBcyBDREsgSG90U3dhcCBpcyBkZXZlbG9wbWVudCBvbmx5LCB0aGlzIHNlZW1zIHRoZSBtb3N0IGVmZmljaWVudCB3YXkgdG8gZW5zdXJlIGFsbCB0YXNrcyBhcmUgcmVwbGFjZWQgaW1tZWRpYXRlbHksIHJlZ2FyZGxlc3Mgb2Ygb3JpZ2luYWwgYW1vdW50XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAY2RrbGFicy9wcm9taXNlYWxsLW5vLXVuYm91bmRlZC1wYXJhbGxlbGlzbVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5tYXAoYXN5bmMgKHNlcnZpY2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXIgPSBzZXJ2aWNlLnNlcnZpY2VBcm4uc3BsaXQoJy8nKVsxXTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IGF3YWl0IHNkay5lY3MoKS51cGRhdGVTZXJ2aWNlKHtcbiAgICAgICAgICAgICAgc2VydmljZTogc2VydmljZS5zZXJ2aWNlQXJuLFxuICAgICAgICAgICAgICB0YXNrRGVmaW5pdGlvbjogdGFza0RlZlJldkFybixcbiAgICAgICAgICAgICAgY2x1c3RlcixcbiAgICAgICAgICAgICAgZm9yY2VOZXdEZXBsb3ltZW50OiB0cnVlLFxuICAgICAgICAgICAgICBkZXBsb3ltZW50Q29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgIG1pbmltdW1IZWFsdGh5UGVyY2VudDogbWluaW11bUhlYWx0aHlQZXJjZW50ICE9PSB1bmRlZmluZWQgPyBtaW5pbXVtSGVhbHRoeVBlcmNlbnQgOiAwLFxuICAgICAgICAgICAgICAgIG1heGltdW1QZXJjZW50OiBtYXhpbXVtSGVhbHRoeVBlcmNlbnQgIT09IHVuZGVmaW5lZCA/IG1heGltdW1IZWFsdGh5UGVyY2VudCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBzZGsuZWNzKCkud2FpdFVudGlsU2VydmljZXNTdGFibGUoe1xuICAgICAgICAgICAgICBjbHVzdGVyOiB1cGRhdGUuc2VydmljZT8uY2x1c3RlckFybixcbiAgICAgICAgICAgICAgc2VydmljZXM6IFtzZXJ2aWNlLnNlcnZpY2VBcm5dLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuaW50ZXJmYWNlIEVjc1NlcnZpY2Uge1xuICByZWFkb25seSBzZXJ2aWNlQXJuOiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVUYXNrRGVmaW5pdGlvbkNoYW5nZShcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICBsb2dpY2FsSWQ6IHN0cmluZyxcbiAgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsXG4pIHtcbiAgY29uc3QgdGFza0RlZmluaXRpb25SZXNvdXJjZTogeyBbbmFtZTogc3RyaW5nXTogYW55IH0gPSB7XG4gICAgLi4uY2hhbmdlLm9sZFZhbHVlLlByb3BlcnRpZXMsXG4gICAgQ29udGFpbmVyRGVmaW5pdGlvbnM6IGNoYW5nZS5uZXdWYWx1ZS5Qcm9wZXJ0aWVzPy5Db250YWluZXJEZWZpbml0aW9ucyxcbiAgfTtcbiAgLy8gZmlyc3QsIGxldCdzIGdldCB0aGUgbmFtZSBvZiB0aGUgZmFtaWx5XG4gIGNvbnN0IGZhbWlseU5hbWVPckFybiA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXN0YWJsaXNoUmVzb3VyY2VQaHlzaWNhbE5hbWUoXG4gICAgbG9naWNhbElkLFxuICAgIHRhc2tEZWZpbml0aW9uUmVzb3VyY2U/LkZhbWlseSxcbiAgKTtcbiAgaWYgKCFmYW1pbHlOYW1lT3JBcm4pIHtcbiAgICAvLyBpZiB0aGUgRmFtaWx5IHByb3BlcnR5IGhhcyBub3QgYmVlbiBwcm92aWRlZCwgYW5kIHdlIGNhbid0IGZpbmQgaXQgaW4gdGhlIGN1cnJlbnQgU3RhY2ssXG4gICAgLy8gdGhpcyBtZWFucyBob3Rzd2FwcGluZyBpcyBub3QgcG9zc2libGVcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gdGhlIHBoeXNpY2FsIG5hbWUgb2YgdGhlIFRhc2sgRGVmaW5pdGlvbiBpbiBDbG91ZEZvcm1hdGlvbiBpbmNsdWRlcyBpdHMgY3VycmVudCByZXZpc2lvbiBudW1iZXIgYXQgdGhlIGVuZCxcbiAgLy8gcmVtb3ZlIGl0IGlmIG5lZWRlZFxuICBjb25zdCBmYW1pbHlOYW1lT3JBcm5QYXJ0cyA9IGZhbWlseU5hbWVPckFybi5zcGxpdCgnOicpO1xuICBjb25zdCBmYW1pbHkgPVxuICAgIGZhbWlseU5hbWVPckFyblBhcnRzLmxlbmd0aCA+IDFcbiAgICAgID8gLy8gZmFtaWx5TmFtZU9yQXJuIGlzIGFjdHVhbGx5IGFuIEFSTiwgb2YgdGhlIGZvcm1hdCAnYXJuOmF3czplY3M6cmVnaW9uOmFjY291bnQ6dGFzay1kZWZpbml0aW9uLzxmYW1pbHktbmFtZT46PHJldmlzaW9uLW5yPidcbiAgICAvLyBzbywgdGFrZSB0aGUgNnRoIGVsZW1lbnQsIGF0IGluZGV4IDUsIGFuZCBzcGxpdCBpdCBvbiAnLydcbiAgICAgIGZhbWlseU5hbWVPckFyblBhcnRzWzVdLnNwbGl0KCcvJylbMV1cbiAgICAgIDogLy8gb3RoZXJ3aXNlLCBmYW1pbHlOYW1lT3JBcm4gaXMganVzdCB0aGUgc2ltcGxlIG5hbWUgZXZhbHVhdGVkIGZyb20gdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlXG4gICAgICBmYW1pbHlOYW1lT3JBcm47XG4gIC8vIHRoZW4sIGxldCdzIGV2YWx1YXRlIHRoZSBib2R5IG9mIHRoZSByZW1haW5kZXIgb2YgdGhlIFRhc2tEZWYgKHdpdGhvdXQgdGhlIEZhbWlseSBwcm9wZXJ0eSlcbiAgcmV0dXJuIHtcbiAgICAuLi4oYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24oe1xuICAgICAgLi4uKHRhc2tEZWZpbml0aW9uUmVzb3VyY2UgPz8ge30pLFxuICAgICAgRmFtaWx5OiB1bmRlZmluZWQsXG4gICAgfSkpLFxuICAgIEZhbWlseTogZmFtaWx5LFxuICB9O1xufVxuIl19