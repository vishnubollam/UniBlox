"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.REQUIRED_BY_CFN = void 0;
exports.isHotswappableS3BucketDeploymentChange = isHotswappableS3BucketDeploymentChange;
exports.skipChangeForS3DeployCustomResourcePolicy = skipChangeForS3DeployCustomResourcePolicy;
/**
 * This means that the value is required to exist by CloudFormation's Custom Resource API (or our S3 Bucket Deployment Lambda's API)
 * but the actual value specified is irrelevant
 */
exports.REQUIRED_BY_CFN = 'required-to-be-present-by-cfn';
async function isHotswappableS3BucketDeploymentChange(_logicalId, change, evaluateCfnTemplate) {
    // In old-style synthesis, the policy used by the lambda to copy assets Ref's the assets directly,
    // meaning that the changes made to the Policy are artifacts that can be safely ignored
    const ret = [];
    if (change.newValue.Type !== 'Custom::CDKBucketDeployment') {
        return [];
    }
    // no classification to be done here; all the properties of this custom resource thing are hotswappable
    const customResourceProperties = await evaluateCfnTemplate.evaluateCfnExpression({
        ...change.newValue.Properties,
        ServiceToken: undefined,
    });
    ret.push({
        hotswappable: true,
        resourceType: change.newValue.Type,
        propsChanged: ['*'],
        service: 'custom-s3-deployment',
        resourceNames: [`Contents of S3 Bucket '${customResourceProperties.DestinationBucketName}'`],
        apply: async (sdk) => {
            var _a;
            // note that this gives the ARN of the lambda, not the name. This is fine though, the invoke() sdk call will take either
            const functionName = await evaluateCfnTemplate.evaluateCfnExpression((_a = change.newValue.Properties) === null || _a === void 0 ? void 0 : _a.ServiceToken);
            if (!functionName) {
                return;
            }
            await sdk.lambda().invokeCommand({
                FunctionName: functionName,
                // Lambda refuses to take a direct JSON object and requires it to be stringify()'d
                Payload: JSON.stringify({
                    RequestType: 'Update',
                    ResponseURL: exports.REQUIRED_BY_CFN,
                    PhysicalResourceId: exports.REQUIRED_BY_CFN,
                    StackId: exports.REQUIRED_BY_CFN,
                    RequestId: exports.REQUIRED_BY_CFN,
                    LogicalResourceId: exports.REQUIRED_BY_CFN,
                    ResourceProperties: stringifyObject(customResourceProperties), // JSON.stringify() doesn't turn the actual objects to strings, but the lambda expects strings
                }),
            });
        },
    });
    return ret;
}
async function skipChangeForS3DeployCustomResourcePolicy(iamPolicyLogicalId, change, evaluateCfnTemplate) {
    var _a;
    if (change.newValue.Type !== 'AWS::IAM::Policy') {
        return false;
    }
    const roles = (_a = change.newValue.Properties) === null || _a === void 0 ? void 0 : _a.Roles;
    // If no roles are referenced, the policy is definitely not used for a S3Deployment
    if (!roles || !roles.length) {
        return false;
    }
    // Check if every role this policy is referenced by is only used for a S3Deployment
    for (const role of roles) {
        const roleArn = await evaluateCfnTemplate.evaluateCfnExpression(role);
        const roleLogicalId = await evaluateCfnTemplate.findLogicalIdForPhysicalName(roleArn);
        // We must assume this role is used for something else, because we can't check it
        if (!roleLogicalId) {
            return false;
        }
        // Find all interesting reference to the role
        const roleRefs = evaluateCfnTemplate
            .findReferencesTo(roleLogicalId)
            // we are not interested in the reference from the original policy - it always exists
            .filter((roleRef) => !(roleRef.Type == 'AWS::IAM::Policy' && roleRef.LogicalId === iamPolicyLogicalId));
        // Check if the role is only used for S3Deployment
        // We know this is the case, if S3Deployment -> Lambda -> Role is satisfied for every reference
        // And we have at least one reference.
        const isRoleOnlyForS3Deployment = roleRefs.length >= 1 &&
            roleRefs.every((roleRef) => {
                if (roleRef.Type === 'AWS::Lambda::Function') {
                    const lambdaRefs = evaluateCfnTemplate.findReferencesTo(roleRef.LogicalId);
                    // Every reference must be to the custom resource and at least one reference must be present
                    return (lambdaRefs.length >= 1 && lambdaRefs.every((lambdaRef) => lambdaRef.Type === 'Custom::CDKBucketDeployment'));
                }
                return false;
            });
        // We have determined this role is used for something else, so we can't skip the change
        if (!isRoleOnlyForS3Deployment) {
            return false;
        }
    }
    // We have checked that any use of this policy is only for S3Deployment and we can safely skip it
    return true;
}
function stringifyObject(obj) {
    if (obj == null) {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map(stringifyObject);
    }
    if (typeof obj !== 'object') {
        return obj.toString();
    }
    const ret = {};
    for (const [k, v] of Object.entries(obj)) {
        ret[k] = stringifyObject(v);
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiczMtYnVja2V0LWRlcGxveW1lbnRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiczMtYnVja2V0LWRlcGxveW1lbnRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQVVBLHdGQWlEQztBQUVELDhGQXVEQztBQWhIRDs7O0dBR0c7QUFDVSxRQUFBLGVBQWUsR0FBRywrQkFBK0IsQ0FBQztBQUV4RCxLQUFLLFVBQVUsc0NBQXNDLENBQzFELFVBQWtCLEVBQ2xCLE1BQW1DLEVBQ25DLG1CQUFtRDtJQUVuRCxrR0FBa0c7SUFDbEcsdUZBQXVGO0lBQ3ZGLE1BQU0sR0FBRyxHQUF3QixFQUFFLENBQUM7SUFFcEMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyw2QkFBNkIsRUFBRSxDQUFDO1FBQzNELE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUVELHVHQUF1RztJQUN2RyxNQUFNLHdCQUF3QixHQUFHLE1BQU0sbUJBQW1CLENBQUMscUJBQXFCLENBQUM7UUFDL0UsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVU7UUFDN0IsWUFBWSxFQUFFLFNBQVM7S0FDeEIsQ0FBQyxDQUFDO0lBRUgsR0FBRyxDQUFDLElBQUksQ0FBQztRQUNQLFlBQVksRUFBRSxJQUFJO1FBQ2xCLFlBQVksRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUk7UUFDbEMsWUFBWSxFQUFFLENBQUMsR0FBRyxDQUFDO1FBQ25CLE9BQU8sRUFBRSxzQkFBc0I7UUFDL0IsYUFBYSxFQUFFLENBQUMsMEJBQTBCLHdCQUF3QixDQUFDLHFCQUFxQixHQUFHLENBQUM7UUFDNUYsS0FBSyxFQUFFLEtBQUssRUFBRSxHQUFRLEVBQUUsRUFBRTs7WUFDeEIsd0hBQXdIO1lBQ3hILE1BQU0sWUFBWSxHQUFHLE1BQU0sbUJBQW1CLENBQUMscUJBQXFCLENBQUMsTUFBQSxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVUsMENBQUUsWUFBWSxDQUFDLENBQUM7WUFDL0cs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Q0FBQztBQUVELFNBQVMsZUFBZSxDQUFDLEdBQVE7SUFDL0IsSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7UUFDaEIsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBQ0QsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7UUFDdkIsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFDRCxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQzVCLE9BQU8sR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ3hCLENBQUM7SUFFRCxNQUFNLEdBQUcsR0FBeUIsRUFBRSxDQUFDO0lBQ3JDLEtBQUssTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7UUFDekMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDaGFuZ2VIb3Rzd2FwUmVzdWx0LCBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgdHlwZSB7IFNESyB9IGZyb20gJy4uL2F3cy1hdXRoJztcbmltcG9ydCB0eXBlIHsgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlIH0gZnJvbSAnLi4vZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUnO1xuXG4vKipcbiAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgdmFsdWUgaXMgcmVxdWlyZWQgdG8gZXhpc3QgYnkgQ2xvdWRGb3JtYXRpb24ncyBDdXN0b20gUmVzb3VyY2UgQVBJIChvciBvdXIgUzMgQnVja2V0IERlcGxveW1lbnQgTGFtYmRhJ3MgQVBJKVxuICogYnV0IHRoZSBhY3R1YWwgdmFsdWUgc3BlY2lmaWVkIGlzIGlycmVsZXZhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJFUVVJUkVEX0JZX0NGTiA9ICdyZXF1aXJlZC10by1iZS1wcmVzZW50LWJ5LWNmbic7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc0hvdHN3YXBwYWJsZVMzQnVja2V0RGVwbG95bWVudENoYW5nZShcbiAgX2xvZ2ljYWxJZDogc3RyaW5nLFxuICBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSxcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuKTogUHJvbWlzZTxDaGFuZ2VIb3Rzd2FwUmVzdWx0PiB7XG4gIC8vIEluIG9sZC1zdHlsZSBzeW50aGVzaXMsIHRoZSBwb2xpY3kgdXNlZCBieSB0aGUgbGFtYmRhIHRvIGNvcHkgYXNzZXRzIFJlZidzIHRoZSBhc3NldHMgZGlyZWN0bHksXG4gIC8vIG1lYW5pbmcgdGhhdCB0aGUgY2hhbmdlcyBtYWRlIHRvIHRoZSBQb2xpY3kgYXJlIGFydGlmYWN0cyB0aGF0IGNhbiBiZSBzYWZlbHkgaWdub3JlZFxuICBjb25zdCByZXQ6IENoYW5nZUhvdHN3YXBSZXN1bHQgPSBbXTtcblxuICBpZiAoY2hhbmdlLm5ld1ZhbHVlLlR5cGUgIT09ICdDdXN0b206OkNES0J1Y2tldERlcGxveW1lbnQnKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gbm8gY2xhc3NpZmljYXRpb24gdG8gYmUgZG9uZSBoZXJlOyBhbGwgdGhlIHByb3BlcnRpZXMgb2YgdGhpcyBjdXN0b20gcmVzb3VyY2UgdGhpbmcgYXJlIGhvdHN3YXBwYWJsZVxuICBjb25zdCBjdXN0b21SZXNvdXJjZVByb3BlcnRpZXMgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih7XG4gICAgLi4uY2hhbmdlLm5ld1ZhbHVlLlByb3BlcnRpZXMsXG4gICAgU2VydmljZVRva2VuOiB1bmRlZmluZWQsXG4gIH0pO1xuXG4gIHJldC5wdXNoKHtcbiAgICBob3Rzd2FwcGFibGU6IHRydWUsXG4gICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICBwcm9wc0NoYW5nZWQ6IFsnKiddLFxuICAgIHNlcnZpY2U6ICdjdXN0b20tczMtZGVwbG95bWVudCcsXG4gICAgcmVzb3VyY2VOYW1lczogW2BDb250ZW50cyBvZiBTMyBCdWNrZXQgJyR7Y3VzdG9tUmVzb3VyY2VQcm9wZXJ0aWVzLkRlc3RpbmF0aW9uQnVja2V0TmFtZX0nYF0sXG4gICAgYXBwbHk6IGFzeW5jIChzZGs6IFNESykgPT4ge1xuICAgICAgLy8gbm90ZSB0aGF0IHRoaXMgZ2l2ZXMgdGhlIEFSTiBvZiB0aGUgbGFtYmRhLCBub3QgdGhlIG5hbWUuIFRoaXMgaXMgZmluZSB0aG91Z2gsIHRoZSBpbnZva2UoKSBzZGsgY2FsbCB3aWxsIHRha2UgZWl0aGVyXG4gICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihjaGFuZ2UubmV3VmFsdWUuUHJvcGVydGllcz8uU2VydmljZVRva2VuKTtcbiAgICAgIGlmICghZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgc2RrLmxhbWJkYSgpLmludm9rZUNvbW1hbmQoe1xuICAgICAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgLy8gTGFtYmRhIHJlZnVzZXMgdG8gdGFrZSBhIGRpcmVjdCBKU09OIG9iamVjdCBhbmQgcmVxdWlyZXMgaXQgdG8gYmUgc3RyaW5naWZ5KCknZFxuICAgICAgICBQYXlsb2FkOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgUmVxdWVzdFR5cGU6ICdVcGRhdGUnLFxuICAgICAgICAgIFJlc3BvbnNlVVJMOiBSRVFVSVJFRF9CWV9DRk4sXG4gICAgICAgICAgUGh5c2ljYWxSZXNvdXJjZUlkOiBSRVFVSVJFRF9CWV9DRk4sXG4gICAgICAgICAgU3RhY2tJZDogUkVRVUlSRURfQllfQ0ZOLFxuICAgICAgICAgIFJlcXVlc3RJZDogUkVRVUlSRURfQllfQ0ZOLFxuICAgICAgICAgIExvZ2ljYWxSZXNvdXJjZUlkOiBSRVFVSVJFRF9CWV9DRk4sXG4gICAgICAgICAgUmVzb3VyY2VQcm9wZXJ0aWVzOiBzdHJpbmdpZnlPYmplY3QoY3VzdG9tUmVzb3VyY2VQcm9wZXJ0aWVzKSwgLy8gSlNPTi5zdHJpbmdpZnkoKSBkb2Vzbid0IHR1cm4gdGhlIGFjdHVhbCBvYmplY3RzIHRvIHN0cmluZ3MsIGJ1dCB0aGUgbGFtYmRhIGV4cGVjdHMgc3RyaW5nc1xuICAgICAgICB9KSxcbiAgICAgIH0pO1xuICAgIH0sXG4gIH0pO1xuXG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBza2lwQ2hhbmdlRm9yUzNEZXBsb3lDdXN0b21SZXNvdXJjZVBvbGljeShcbiAgaWFtUG9saWN5TG9naWNhbElkOiBzdHJpbmcsXG4gIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLFxuICBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgaWYgKGNoYW5nZS5uZXdWYWx1ZS5UeXBlICE9PSAnQVdTOjpJQU06OlBvbGljeScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgcm9sZXM6IHN0cmluZ1tdID0gY2hhbmdlLm5ld1ZhbHVlLlByb3BlcnRpZXM/LlJvbGVzO1xuXG4gIC8vIElmIG5vIHJvbGVzIGFyZSByZWZlcmVuY2VkLCB0aGUgcG9saWN5IGlzIGRlZmluaXRlbHkgbm90IHVzZWQgZm9yIGEgUzNEZXBsb3ltZW50XG4gIGlmICghcm9sZXMgfHwgIXJvbGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGV2ZXJ5IHJvbGUgdGhpcyBwb2xpY3kgaXMgcmVmZXJlbmNlZCBieSBpcyBvbmx5IHVzZWQgZm9yIGEgUzNEZXBsb3ltZW50XG4gIGZvciAoY29uc3Qgcm9sZSBvZiByb2xlcykge1xuICAgIGNvbnN0IHJvbGVBcm4gPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihyb2xlKTtcbiAgICBjb25zdCByb2xlTG9naWNhbElkID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5maW5kTG9naWNhbElkRm9yUGh5c2ljYWxOYW1lKHJvbGVBcm4pO1xuXG4gICAgLy8gV2UgbXVzdCBhc3N1bWUgdGhpcyByb2xlIGlzIHVzZWQgZm9yIHNvbWV0aGluZyBlbHNlLCBiZWNhdXNlIHdlIGNhbid0IGNoZWNrIGl0XG4gICAgaWYgKCFyb2xlTG9naWNhbElkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRmluZCBhbGwgaW50ZXJlc3RpbmcgcmVmZXJlbmNlIHRvIHRoZSByb2xlXG4gICAgY29uc3Qgcm9sZVJlZnMgPSBldmFsdWF0ZUNmblRlbXBsYXRlXG4gICAgICAuZmluZFJlZmVyZW5jZXNUbyhyb2xlTG9naWNhbElkKVxuICAgICAgLy8gd2UgYXJlIG5vdCBpbnRlcmVzdGVkIGluIHRoZSByZWZlcmVuY2UgZnJvbSB0aGUgb3JpZ2luYWwgcG9saWN5IC0gaXQgYWx3YXlzIGV4aXN0c1xuICAgICAgLmZpbHRlcigocm9sZVJlZikgPT4gIShyb2xlUmVmLlR5cGUgPT0gJ0FXUzo6SUFNOjpQb2xpY3knICYmIHJvbGVSZWYuTG9naWNhbElkID09PSBpYW1Qb2xpY3lMb2dpY2FsSWQpKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSByb2xlIGlzIG9ubHkgdXNlZCBmb3IgUzNEZXBsb3ltZW50XG4gICAgLy8gV2Uga25vdyB0aGlzIGlzIHRoZSBjYXNlLCBpZiBTM0RlcGxveW1lbnQgLT4gTGFtYmRhIC0+IFJvbGUgaXMgc2F0aXNmaWVkIGZvciBldmVyeSByZWZlcmVuY2VcbiAgICAvLyBBbmQgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgcmVmZXJlbmNlLlxuICAgIGNvbnN0IGlzUm9sZU9ubHlGb3JTM0RlcGxveW1lbnQgPVxuICAgICAgcm9sZVJlZnMubGVuZ3RoID49IDEgJiZcbiAgICAgIHJvbGVSZWZzLmV2ZXJ5KChyb2xlUmVmKSA9PiB7XG4gICAgICAgIGlmIChyb2xlUmVmLlR5cGUgPT09ICdBV1M6OkxhbWJkYTo6RnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29uc3QgbGFtYmRhUmVmcyA9IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZFJlZmVyZW5jZXNUbyhyb2xlUmVmLkxvZ2ljYWxJZCk7XG4gICAgICAgICAgLy8gRXZlcnkgcmVmZXJlbmNlIG11c3QgYmUgdG8gdGhlIGN1c3RvbSByZXNvdXJjZSBhbmQgYXQgbGVhc3Qgb25lIHJlZmVyZW5jZSBtdXN0IGJlIHByZXNlbnRcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbGFtYmRhUmVmcy5sZW5ndGggPj0gMSAmJiBsYW1iZGFSZWZzLmV2ZXJ5KChsYW1iZGFSZWYpID0+IGxhbWJkYVJlZi5UeXBlID09PSAnQ3VzdG9tOjpDREtCdWNrZXREZXBsb3ltZW50JylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgLy8gV2UgaGF2ZSBkZXRlcm1pbmVkIHRoaXMgcm9sZSBpcyB1c2VkIGZvciBzb21ldGhpbmcgZWxzZSwgc28gd2UgY2FuJ3Qgc2tpcCB0aGUgY2hhbmdlXG4gICAgaWYgKCFpc1JvbGVPbmx5Rm9yUzNEZXBsb3ltZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gV2UgaGF2ZSBjaGVja2VkIHRoYXQgYW55IHVzZSBvZiB0aGlzIHBvbGljeSBpcyBvbmx5IGZvciBTM0RlcGxveW1lbnQgYW5kIHdlIGNhbiBzYWZlbHkgc2tpcCBpdFxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0KG9iajogYW55KTogYW55IHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5tYXAoc3RyaW5naWZ5T2JqZWN0KTtcbiAgfVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCk7XG4gIH1cblxuICBjb25zdCByZXQ6IHsgW2s6IHN0cmluZ106IGFueSB9ID0ge307XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICByZXRba10gPSBzdHJpbmdpZnlPYmplY3Qodik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiJdfQ==