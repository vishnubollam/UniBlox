"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableLambdaFunctionChange = isHotswappableLambdaFunctionChange;
const stream_1 = require("stream");
const common_1 = require("./common");
const error_1 = require("../../toolkit/error");
const util_1 = require("../../util");
const evaluate_cloudformation_template_1 = require("../evaluate-cloudformation-template");
// namespace object imports won't work in the bundle for function exports
// eslint-disable-next-line @typescript-eslint/no-require-imports
const archiver = require('archiver');
async function isHotswappableLambdaFunctionChange(logicalId, change, evaluateCfnTemplate) {
    var _a;
    // if the change is for a Lambda Version,
    // ignore it by returning an empty hotswap operation -
    // we will publish a new version when we get to hotswapping the actual Function this Version points to, below
    // (Versions can't be changed in CloudFormation anyway, they're immutable)
    if (change.newValue.Type === 'AWS::Lambda::Version') {
        return [
            {
                hotswappable: true,
                resourceType: 'AWS::Lambda::Version',
                resourceNames: [],
                propsChanged: [],
                service: 'lambda',
                apply: async (_sdk) => { },
            },
        ];
    }
    // we handle Aliases specially too
    if (change.newValue.Type === 'AWS::Lambda::Alias') {
        return classifyAliasChanges(change);
    }
    if (change.newValue.Type !== 'AWS::Lambda::Function') {
        return [];
    }
    const ret = [];
    const classifiedChanges = (0, common_1.classifyChanges)(change, ['Code', 'Environment', 'Description']);
    classifiedChanges.reportNonHotswappablePropertyChanges(ret);
    const functionName = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, (_a = change.newValue.Properties) === null || _a === void 0 ? void 0 : _a.FunctionName);
    const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
    if (namesOfHotswappableChanges.length > 0) {
        ret.push({
            hotswappable: true,
            resourceType: change.newValue.Type,
            propsChanged: namesOfHotswappableChanges,
            service: 'lambda',
            resourceNames: [
                `Lambda Function '${functionName}'`,
                // add Version here if we're publishing a new one
                ...(await renderVersions(logicalId, evaluateCfnTemplate, [`Lambda Version for Function '${functionName}'`])),
                // add any Aliases that we are hotswapping here
                ...(await renderAliases(logicalId, evaluateCfnTemplate, async (alias) => `Lambda Alias '${alias}' for Function '${functionName}'`)),
            ],
            apply: async (sdk) => {
                var _a;
                const lambdaCodeChange = await evaluateLambdaFunctionProps(classifiedChanges.hotswappableProps, (_a = change.newValue.Properties) === null || _a === void 0 ? void 0 : _a.Runtime, evaluateCfnTemplate);
                if (lambdaCodeChange === undefined) {
                    return;
                }
                if (!functionName) {
                    return;
                }
                const { versionsReferencingFunction, aliasesNames } = await versionsAndAliases(logicalId, evaluateCfnTemplate);
                const lambda = sdk.lambda();
                const operations = [];
                if (lambdaCodeChange.code !== undefined || lambdaCodeChange.configurations !== undefined) {
                    if (lambdaCodeChange.code !== undefined) {
                        const updateFunctionCodeResponse = await lambda.updateFunctionCode({
                            FunctionName: functionName,
                            S3Bucket: lambdaCodeChange.code.s3Bucket,
                            S3Key: lambdaCodeChange.code.s3Key,
                            ImageUri: lambdaCodeChange.code.imageUri,
                            ZipFile: lambdaCodeChange.code.functionCodeZip,
                            S3ObjectVersion: lambdaCodeChange.code.s3ObjectVersion,
                        });
                        await waitForLambdasPropertiesUpdateToFinish(updateFunctionCodeResponse, lambda, functionName);
                    }
                    if (lambdaCodeChange.configurations !== undefined) {
                        const updateRequest = {
                            FunctionName: functionName,
                        };
                        if (lambdaCodeChange.configurations.description !== undefined) {
                            updateRequest.Description = lambdaCodeChange.configurations.description;
                        }
                        if (lambdaCodeChange.configurations.environment !== undefined) {
                            updateRequest.Environment = lambdaCodeChange.configurations.environment;
                        }
                        const updateFunctionCodeResponse = await lambda.updateFunctionConfiguration(updateRequest);
                        await waitForLambdasPropertiesUpdateToFinish(updateFunctionCodeResponse, lambda, functionName);
                    }
                    // only if the code changed is there any point in publishing a new Version
                    if (versionsReferencingFunction.length > 0) {
                        const publishVersionPromise = lambda.publishVersion({
                            FunctionName: functionName,
                        });
                        if (aliasesNames.length > 0) {
                            // we need to wait for the Version to finish publishing
                            const versionUpdate = await publishVersionPromise;
                            for (const alias of aliasesNames) {
                                operations.push(lambda.updateAlias({
                                    FunctionName: functionName,
                                    Name: alias,
                                    FunctionVersion: versionUpdate.Version,
                                }));
                            }
                        }
                        else {
                            operations.push(publishVersionPromise);
                        }
                    }
                }
                // run all of our updates in parallel
                // Limited set of updates per function
                // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
                await Promise.all(operations);
            },
        });
    }
    return ret;
}
/**
 * Determines which changes to this Alias are hotswappable or not
 */
function classifyAliasChanges(change) {
    const ret = [];
    const classifiedChanges = (0, common_1.classifyChanges)(change, ['FunctionVersion']);
    classifiedChanges.reportNonHotswappablePropertyChanges(ret);
    const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
    if (namesOfHotswappableChanges.length > 0) {
        ret.push({
            hotswappable: true,
            resourceType: change.newValue.Type,
            propsChanged: [],
            service: 'lambda',
            resourceNames: [],
            apply: async (_sdk) => { },
        });
    }
    return ret;
}
/**
 * Evaluates the hotswappable properties of an AWS::Lambda::Function and
 * Returns a `LambdaFunctionChange` if the change is hotswappable.
 * Returns `undefined` if the change is not hotswappable.
 */
async function evaluateLambdaFunctionProps(hotswappablePropChanges, runtime, evaluateCfnTemplate) {
    /*
     * At first glance, we would want to initialize these using the "previous" values (change.oldValue),
     * in case only one of them changed, like the key, and the Bucket stayed the same.
     * However, that actually fails for old-style synthesis, which uses CFN Parameters!
     * Because the names of the Parameters depend on the hash of the Asset,
     * the Parameters used for the "old" values no longer exist in `assetParams` at this point,
     * which means we don't have the correct values available to evaluate the CFN expression with.
     * Fortunately, the diff will always include both the s3Bucket and s3Key parts of the Lambda's Code property,
     * even if only one of them was actually changed,
     * which means we don't need the "old" values at all, and we can safely initialize these with just `''`.
     */
    let code = undefined;
    let description = undefined;
    let environment = undefined;
    for (const updatedPropName in hotswappablePropChanges) {
        const updatedProp = hotswappablePropChanges[updatedPropName];
        switch (updatedPropName) {
            case 'Code':
                let s3Bucket, s3Key, s3ObjectVersion, imageUri, functionCodeZip;
                for (const newPropName in updatedProp.newValue) {
                    switch (newPropName) {
                        case 'S3Bucket':
                            s3Bucket = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'S3Key':
                            s3Key = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'S3ObjectVersion':
                            s3ObjectVersion = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'ImageUri':
                            imageUri = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'ZipFile':
                            // We must create a zip package containing a file with the inline code
                            const functionCode = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            const functionRuntime = await evaluateCfnTemplate.evaluateCfnExpression(runtime);
                            if (!functionRuntime) {
                                return undefined;
                            }
                            // file extension must be chosen depending on the runtime
                            const codeFileExt = determineCodeFileExtFromRuntime(functionRuntime);
                            functionCodeZip = await zipString(`index.${codeFileExt}`, functionCode);
                            break;
                    }
                }
                code = {
                    s3Bucket,
                    s3Key,
                    s3ObjectVersion,
                    imageUri,
                    functionCodeZip,
                };
                break;
            case 'Description':
                description = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue);
                break;
            case 'Environment':
                environment = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue);
                break;
            default:
                // we will never get here, but just in case we do throw an error
                throw new error_1.ToolkitError('while apply()ing, found a property that cannot be hotswapped. Please report this at github.com/aws/aws-cdk/issues/new/choose');
        }
    }
    const configurations = description || environment ? { description, environment } : undefined;
    return code || configurations ? { code, configurations } : undefined;
}
/**
 * Compress a string as a file, returning a promise for the zip buffer
 * https://github.com/archiverjs/node-archiver/issues/342
 */
function zipString(fileName, rawString) {
    return new Promise((resolve, reject) => {
        const buffers = [];
        const converter = new stream_1.Writable();
        converter._write = (chunk, _, callback) => {
            buffers.push(chunk);
            process.nextTick(callback);
        };
        converter.on('finish', () => {
            resolve(Buffer.concat(buffers));
        });
        const archive = archiver('zip');
        archive.on('error', (err) => {
            reject(err);
        });
        archive.pipe(converter);
        archive.append(rawString, {
            name: fileName,
            date: new Date('1980-01-01T00:00:00.000Z'), // Add date to make resulting zip file deterministic
        });
        void archive.finalize();
    });
}
/**
 * After a Lambda Function is updated, it cannot be updated again until the
 * `State=Active` and the `LastUpdateStatus=Successful`.
 *
 * Depending on the configuration of the Lambda Function this could happen relatively quickly
 * or very slowly. For example, Zip based functions _not_ in a VPC can take ~1 second whereas VPC
 * or Container functions can take ~25 seconds (and 'idle' VPC functions can take minutes).
 */
async function waitForLambdasPropertiesUpdateToFinish(currentFunctionConfiguration, lambda, functionName) {
    var _a;
    const functionIsInVpcOrUsesDockerForCode = ((_a = currentFunctionConfiguration.VpcConfig) === null || _a === void 0 ? void 0 : _a.VpcId) || currentFunctionConfiguration.PackageType === 'Image';
    // if the function is deployed in a VPC or if it is a container image function
    // then the update will take much longer and we can wait longer between checks
    // otherwise, the update will be quick, so a 1-second delay is fine
    const delaySeconds = functionIsInVpcOrUsesDockerForCode ? 5 : 1;
    await lambda.waitUntilFunctionUpdated(delaySeconds, {
        FunctionName: functionName,
    });
}
/**
 * Get file extension from Lambda runtime string.
 * We use this extension to create a deployment package from Lambda inline code.
 */
function determineCodeFileExtFromRuntime(runtime) {
    if (runtime.startsWith('node')) {
        return 'js';
    }
    if (runtime.startsWith('python')) {
        return 'py';
    }
    // Currently inline code only supports Node.js and Python, ignoring other runtimes.
    // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html#aws-properties-lambda-function-code-properties
    throw new evaluate_cloudformation_template_1.CfnEvaluationException(`runtime ${runtime} is unsupported, only node.js and python runtimes are currently supported.`);
}
/**
 * Finds all Versions that reference an AWS::Lambda::Function with logical ID `logicalId`
 * and Aliases that reference those Versions.
 */
async function versionsAndAliases(logicalId, evaluateCfnTemplate) {
    // find all Lambda Versions that reference this Function
    const versionsReferencingFunction = evaluateCfnTemplate
        .findReferencesTo(logicalId)
        .filter((r) => r.Type === 'AWS::Lambda::Version');
    // find all Lambda Aliases that reference the above Versions
    const aliasesReferencingVersions = (0, util_1.flatMap)(versionsReferencingFunction, v => evaluateCfnTemplate.findReferencesTo(v.LogicalId));
    // Limited set of updates per function
    // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
    const aliasesNames = await Promise.all(aliasesReferencingVersions.map(a => { var _a; return evaluateCfnTemplate.evaluateCfnExpression((_a = a.Properties) === null || _a === void 0 ? void 0 : _a.Name); }));
    return { versionsReferencingFunction, aliasesNames };
}
/**
 * Renders the string used in displaying Alias resource names that reference the specified Lambda Function
 */
async function renderAliases(logicalId, evaluateCfnTemplate, callbackfn) {
    const aliasesNames = (await versionsAndAliases(logicalId, evaluateCfnTemplate)).aliasesNames;
    // Limited set of updates per function
    // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
    return Promise.all(aliasesNames.map(callbackfn));
}
/**
 * Renders the string used in displaying Version resource names that reference the specified Lambda Function
 */
async function renderVersions(logicalId, evaluateCfnTemplate, versionString) {
    const versions = (await versionsAndAliases(logicalId, evaluateCfnTemplate)).versionsReferencingFunction;
    return versions.length > 0 ? versionString : [];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhLWZ1bmN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxhbWJkYS1mdW5jdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFZQSxnRkF3SUM7QUFwSkQsbUNBQWtDO0FBRWxDLHFDQUFrSDtBQUNsSCwrQ0FBbUQ7QUFDbkQscUNBQXFDO0FBRXJDLDBGQUFrSDtBQUVsSCx5RUFBeUU7QUFDekUsaUVBQWlFO0FBQ2pFLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUU5QixLQUFLLFVBQVUsa0NBQWtDLENBQ3RELFNBQWlCLEVBQ2pCLE1BQW1DLEVBQ25DLG1CQUFtRDs7SUFFbkQseUNBQXlDO0lBQ3pDLHNEQUFzRDtJQUN0RCw2R0FBNkc7SUFDN0csMEVBQTBFO0lBQzFFLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssc0JBQXNCLEVBQUUsQ0FBQztRQUNwRCxPQUFPO1lBQ0w7Z0JBQ0UsWUFBWSxFQUFFLElBQUk7Z0JBQ2xCLFlBQVksRUFBRSxzQkFBc0I7Z0JBQ3BDLGFBQWEsRUFBRSxFQUFFO2dCQUNqQixZQUFZLEVBQUUsRUFBRTtnQkFDaEIsT0FBTyxFQUFFLFFBQVE7Z0JBQ2pCLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBUyxFQUFFLEVBQUUsR0FBRSxDQUFDO2FBQy9CO1NBQ0YsQ0FBQztJQUNKLENBQUM7SUFFRCxrQ0FBa0M7SUFDbEMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxvQkFBb0IsRUFBRSxDQUFDO1FBQ2xELE9BQU8sb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVELElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssdUJBQXVCLEVBQUUsQ0FBQztRQUNyRCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRCxNQUFNLEdBQUcsR0FBd0IsRUFBRSxDQUFDO0lBQ3BDLE1BQU0saUJBQWlCLEdB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cG9ydCB7IHR5cGUgRnVuY3Rpb25Db25maWd1cmF0aW9uLCB0eXBlIFVwZGF0ZUZ1bmN0aW9uQ29uZmlndXJhdGlvbkNvbW1hbmRJbnB1dCB9IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1sYW1iZGEnO1xuaW1wb3J0IHsgdHlwZSBDaGFuZ2VIb3Rzd2FwUmVzdWx0LCBjbGFzc2lmeUNoYW5nZXMsIHR5cGUgSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBQcm9wRGlmZnMgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi90b29sa2l0L2Vycm9yJztcbmltcG9ydCB7IGZsYXRNYXAgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB0eXBlIHsgSUxhbWJkYUNsaWVudCwgU0RLIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgQ2ZuRXZhbHVhdGlvbkV4Y2VwdGlvbiwgdHlwZSBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUgfSBmcm9tICcuLi9ldmFsdWF0ZS1jbG91ZGZvcm1hdGlvbi10ZW1wbGF0ZSc7XG5cbi8vIG5hbWVzcGFjZSBvYmplY3QgaW1wb3J0cyB3b24ndCB3b3JrIGluIHRoZSBidW5kbGUgZm9yIGZ1bmN0aW9uIGV4cG9ydHNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG5jb25zdCBhcmNoaXZlciA9IHJlcXVpcmUoJ2FyY2hpdmVyJyk7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc0hvdHN3YXBwYWJsZUxhbWJkYUZ1bmN0aW9uQ2hhbmdlKFxuICBsb2dpY2FsSWQ6IHN0cmluZyxcbiAgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsXG4gIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbik6IFByb21pc2U8Q2hhbmdlSG90c3dhcFJlc3VsdD4ge1xuICAvLyBpZiB0aGUgY2hhbmdlIGlzIGZvciBhIExhbWJkYSBWZXJzaW9uLFxuICAvLyBpZ25vcmUgaXQgYnkgcmV0dXJuaW5nIGFuIGVtcHR5IGhvdHN3YXAgb3BlcmF0aW9uIC1cbiAgLy8gd2Ugd2lsbCBwdWJsaXNoIGEgbmV3IHZlcnNpb24gd2hlbiB3ZSBnZXQgdG8gaG90c3dhcHBpbmcgdGhlIGFjdHVhbCBGdW5jdGlvbiB0aGlzIFZlcnNpb24gcG9pbnRzIHRvLCBiZWxvd1xuICAvLyAoVmVyc2lvbnMgY2FuJ3QgYmUgY2hhbmdlZCBpbiBDbG91ZEZvcm1hdGlvbiBhbnl3YXksIHRoZXkncmUgaW1tdXRhYmxlKVxuICBpZiAoY2hhbmdlLm5ld1ZhbHVlLlR5cGUgPT09ICdBV1M6OkxhbWJkYTo6VmVyc2lvbicpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBob3Rzd2FwcGFibGU6IHRydWUsXG4gICAgICAgIHJlc291cmNlVHlwZTogJ0FXUzo6TGFtYmRhOjpWZXJzaW9uJyxcbiAgICAgICAgcmVzb3VyY2VOYW1lczogW10sXG4gICAgICAgIHByb3BzQ2hhbmdlZDogW10sXG4gICAgICAgIHNlcnZpY2U6ICdsYW1iZGEnLFxuICAgICAgICBhcHBseTogYXN5bmMgKF9zZGs6IFNESykgPT4ge30sXG4gICAgICB9LFxuICAgIF07XG4gIH1cblxuICAvLyB3ZSBoYW5kbGUgQWxpYXNlcyBzcGVjaWFsbHkgdG9vXG4gIGlmIChjaGFuZ2UubmV3VmFsdWUuVHlwZSA9PT0gJ0FXUzo6TGFtYmRhOjpBbGlhcycpIHtcbiAgICByZXR1cm4gY2xhc3NpZnlBbGlhc0NoYW5nZXMoY2hhbmdlKTtcbiAgfVxuXG4gIGlmIChjaGFuZ2UubmV3VmFsdWUuVHlwZSAhPT0gJ0FXUzo6TGFtYmRhOjpGdW5jdGlvbicpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCByZXQ6IENoYW5nZUhvdHN3YXBSZXN1bHQgPSBbXTtcbiAgY29uc3QgY2xhc3NpZmllZENoYW5nZXMgPSBjbGFzc2lmeUNoYW5nZXMoY2hhbmdlLCBbJ0NvZGUnLCAnRW52aXJvbm1lbnQnLCAnRGVzY3JpcHRpb24nXSk7XG4gIGNsYXNzaWZpZWRDaGFuZ2VzLnJlcG9ydE5vbkhvdHN3YXBwYWJsZVByb3BlcnR5Q2hhbmdlcyhyZXQpO1xuXG4gIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXN0YWJsaXNoUmVzb3VyY2VQaHlzaWNhbE5hbWUoXG4gICAgbG9naWNhbElkLFxuICAgIGNoYW5nZS5uZXdWYWx1ZS5Qcm9wZXJ0aWVzPy5GdW5jdGlvbk5hbWUsXG4gICk7XG4gIGNvbnN0IG5hbWVzT2ZIb3Rzd2FwcGFibGVDaGFuZ2VzID0gT2JqZWN0LmtleXMoY2xhc3NpZmllZENoYW5nZXMuaG90c3dhcHBhYmxlUHJvcHMpO1xuICBpZiAobmFtZXNPZkhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgIHJldC5wdXNoKHtcbiAgICAgIGhvdHN3YXBwYWJsZTogdHJ1ZSxcbiAgICAgIHJlc291cmNlVHlwZTogY2hhbmdlLm5ld1ZhbHVlLlR5cGUsXG4gICAgICBwcm9wc0NoYW5nZWQ6IG5hbWVzT2ZIb3Rzd2FwcGFibGVDaGFuZ2VzLFxuICAgICAgc2VydmljZTogJ2xhbWJkYScsXG4gICAgICByZXNvdXJjZU5hbWVzOiBbXG4gICAgICAgIGBMYW1iZGEgRnVuY3Rpb24gJyR7ZnVuY3Rpb25OYW1lfSdgLFxuICAgICAgICAvLyBhZGQgVmVyc2lvbiBoZXJlIGlmIHdlJ3JlIHB1Ymxpc2hpbmcgYSBuZXcgb25lXG4gICAgICAgIC4uLihhd2FpdCByZW5kZXJWZXJzaW9ucyhsb2dpY2FsSWQsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUsIFtgTGFtYmRhIFZlcnNpb24gZm9yIEZ1bmN0aW9uICcke2Z1bmN0aW9uTmFtZX0nYF0pKSxcbiAgICAgICAgLy8gYWRkIGFueSBBbGlhc2VzIHRoYXQgd2UgYXJlIGhvdHN3YXBwaW5nIGhlcmVcbiAgICAgICAgLi4uKGF3YWl0IHJlbmRlckFsaWFzZXMoXG4gICAgICAgICAgbG9naWNhbElkLFxuICAgICAgICAgIGV2YWx1YXRlQ2ZuVGVtcGxhdGUsXG4gICAgICAgICAgYXN5bmMgKGFsaWFzKSA9PiBgTGFtYmRhIEFsaWFzICcke2FsaWFzfScgZm9yIEZ1bmN0aW9uICcke2Z1bmN0aW9uTmFtZX0nYCxcbiAgICAgICAgKSksXG4gICAgICBdLFxuICAgICAgYXBwbHk6IGFzeW5jIChzZGs6IFNESykgPT4ge1xuICAgICAgICBjb25zdCBsYW1iZGFDb2RlQ2hhbmdlID0gYXdhaXQgZXZhbHVhdGVMYW1iZGFGdW5jdGlvblByb3BzKFxuICAgICAgICAgIGNsYXNzaWZpZWRDaGFuZ2VzLmhvdHN3YXBwYWJsZVByb3BzLFxuICAgICAgICAgIGNoYW5nZS5uZXdWYWx1ZS5Qcm9wZXJ0aWVzPy5SdW50aW1lLFxuICAgICAgICAgIGV2YWx1YXRlQ2ZuVGVtcGxhdGUsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChsYW1iZGFDb2RlQ2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZ1bmN0aW9uTmFtZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgdmVyc2lvbnNSZWZlcmVuY2luZ0Z1bmN0aW9uLCBhbGlhc2VzTmFtZXMgfSA9IGF3YWl0IHZlcnNpb25zQW5kQWxpYXNlcyhsb2dpY2FsSWQsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpO1xuICAgICAgICBjb25zdCBsYW1iZGEgPSBzZGsubGFtYmRhKCk7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbnM6IFByb21pc2U8YW55PltdID0gW107XG5cbiAgICAgICAgaWYgKGxhbWJkYUNvZGVDaGFuZ2UuY29kZSAhPT0gdW5kZWZpbmVkIHx8IGxhbWJkYUNvZGVDaGFuZ2UuY29uZmlndXJhdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChsYW1iZGFDb2RlQ2hhbmdlLmNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlRnVuY3Rpb25Db2RlUmVzcG9uc2UgPSBhd2FpdCBsYW1iZGEudXBkYXRlRnVuY3Rpb25Db2RlKHtcbiAgICAgICAgICAgICAgRnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgIFMzQnVja2V0OiBsYW1iZGFDb2RlQ2hhbmdlLmNvZGUuczNCdWNrZXQsXG4gICAgICAgICAgICAgIFMzS2V5OiBsYW1iZGFDb2RlQ2hhbmdlLmNvZGUuczNLZXksXG4gICAgICAgICAgICAgIEltYWdlVXJpOiBsYW1iZGFDb2RlQ2hhbmdlLmNvZGUuaW1hZ2VVcmksXG4gICAgICAgICAgICAgIFppcEZpbGU6IGxhbWJkYUNvZGVDaGFuZ2UuY29kZS5mdW5jdGlvbkNvZGVaaXAsXG4gICAgICAgICAgICAgIFMzT2JqZWN0VmVyc2lvbjogbGFtYmRhQ29kZUNoYW5nZS5jb2RlLnMzT2JqZWN0VmVyc2lvbixcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCB3YWl0Rm9yTGFtYmRhc1Byb3BlcnRpZXNVcGRhdGVUb0ZpbmlzaCh1cGRhdGVGdW5jdGlvbkNvZGVSZXNwb25zZSwgbGFtYmRhLCBmdW5jdGlvbk5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsYW1iZGFDb2RlQ2hhbmdlLmNvbmZpZ3VyYXRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVJlcXVlc3Q6IFVwZGF0ZUZ1bmN0aW9uQ29uZmlndXJhdGlvbkNvbW1hbmRJbnB1dCA9IHtcbiAgICAgICAgICAgICAgRnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxhbWJkYUNvZGVDaGFuZ2UuY29uZmlndXJhdGlvbnMuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB1cGRhdGVSZXF1ZXN0LkRlc2NyaXB0aW9uID0gbGFtYmRhQ29kZUNoYW5nZS5jb25maWd1cmF0aW9ucy5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYW1iZGFDb2RlQ2hhbmdlLmNvbmZpZ3VyYXRpb25zLmVudmlyb25tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdXBkYXRlUmVxdWVzdC5FbnZpcm9ubWVudCA9IGxhbWJkYUNvZGVDaGFuZ2UuY29uZmlndXJhdGlvbnMuZW52aXJvbm1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVGdW5jdGlvbkNvZGVSZXNwb25zZSA9IGF3YWl0IGxhbWJkYS51cGRhdGVGdW5jdGlvbkNvbmZpZ3VyYXRpb24odXBkYXRlUmVxdWVzdCk7XG4gICAgICAgICAgICBhd2FpdCB3YWl0Rm9yTGFtYmRhc1Byb3BlcnRpZXNVcGRhdGVUb0ZpbmlzaCh1cGRhdGVGdW5jdGlvbkNvZGVSZXNwb25zZSwgbGFtYmRhLCBmdW5jdGlvbk5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG9ubHkgaWYgdGhlIGNvZGUgY2hhbmdlZCBpcyB0aGVyZSBhbnkgcG9pbnQgaW4gcHVibGlzaGluZyBhIG5ldyBWZXJzaW9uXG4gICAgICAgICAgaWYgKHZlcnNpb25zUmVmZXJlbmNpbmdGdW5jdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwdWJsaXNoVmVyc2lvblByb21pc2UgPSBsYW1iZGEucHVibGlzaFZlcnNpb24oe1xuICAgICAgICAgICAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoYWxpYXNlc05hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgVmVyc2lvbiB0byBmaW5pc2ggcHVibGlzaGluZ1xuICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uVXBkYXRlID0gYXdhaXQgcHVibGlzaFZlcnNpb25Qcm9taXNlO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGFsaWFzZXNOYW1lcykge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMucHVzaChcbiAgICAgICAgICAgICAgICAgIGxhbWJkYS51cGRhdGVBbGlhcyh7XG4gICAgICAgICAgICAgICAgICAgIEZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBOYW1lOiBhbGlhcyxcbiAgICAgICAgICAgICAgICAgICAgRnVuY3Rpb25WZXJzaW9uOiB2ZXJzaW9uVXBkYXRlLlZlcnNpb24sXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcGVyYXRpb25zLnB1c2gocHVibGlzaFZlcnNpb25Qcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBydW4gYWxsIG9mIG91ciB1cGRhdGVzIGluIHBhcmFsbGVsXG4gICAgICAgIC8vIExpbWl0ZWQgc2V0IG9mIHVwZGF0ZXMgcGVyIGZ1bmN0aW9uXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAY2RrbGFicy9wcm9taXNlYWxsLW5vLXVuYm91bmRlZC1wYXJhbGxlbGlzbVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvcGVyYXRpb25zKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hpY2ggY2hhbmdlcyB0byB0aGlzIEFsaWFzIGFyZSBob3Rzd2FwcGFibGUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIGNsYXNzaWZ5QWxpYXNDaGFuZ2VzKGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlKTogQ2hhbmdlSG90c3dhcFJlc3VsdCB7XG4gIGNvbnN0IHJldDogQ2hhbmdlSG90c3dhcFJlc3VsdCA9IFtdO1xuICBjb25zdCBjbGFzc2lmaWVkQ2hhbmdlcyA9IGNsYXNzaWZ5Q2hhbmdlcyhjaGFuZ2UsIFsnRnVuY3Rpb25WZXJzaW9uJ10pO1xuICBjbGFzc2lmaWVkQ2hhbmdlcy5yZXBvcnROb25Ib3Rzd2FwcGFibGVQcm9wZXJ0eUNoYW5nZXMocmV0KTtcblxuICBjb25zdCBuYW1lc09mSG90c3dhcHBhYmxlQ2hhbmdlcyA9IE9iamVjdC5rZXlzKGNsYXNzaWZpZWRDaGFuZ2VzLmhvdHN3YXBwYWJsZVByb3BzKTtcbiAgaWYgKG5hbWVzT2ZIb3Rzd2FwcGFibGVDaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICByZXQucHVzaCh7XG4gICAgICBob3Rzd2FwcGFibGU6IHRydWUsXG4gICAgICByZXNvdXJjZVR5cGU6IGNoYW5nZS5uZXdWYWx1ZS5UeXBlLFxuICAgICAgcHJvcHNDaGFuZ2VkOiBbXSxcbiAgICAgIHNlcnZpY2U6ICdsYW1iZGEnLFxuICAgICAgcmVzb3VyY2VOYW1lczogW10sXG4gICAgICBhcHBseTogYXN5bmMgKF9zZGs6IFNESykgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEV2YWx1YXRlcyB0aGUgaG90c3dhcHBhYmxlIHByb3BlcnRpZXMgb2YgYW4gQVdTOjpMYW1iZGE6OkZ1bmN0aW9uIGFuZFxuICogUmV0dXJucyBhIGBMYW1iZGFGdW5jdGlvbkNoYW5nZWAgaWYgdGhlIGNoYW5nZSBpcyBob3Rzd2FwcGFibGUuXG4gKiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBjaGFuZ2UgaXMgbm90IGhvdHN3YXBwYWJsZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVMYW1iZGFGdW5jdGlvblByb3BzKFxuICBob3Rzd2FwcGFibGVQcm9wQ2hhbmdlczogUHJvcERpZmZzLFxuICBydW50aW1lOiBzdHJpbmcsXG4gIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbik6IFByb21pc2U8TGFtYmRhRnVuY3Rpb25DaGFuZ2UgfCB1bmRlZmluZWQ+IHtcbiAgLypcbiAgICogQXQgZmlyc3QgZ2xhbmNlLCB3ZSB3b3VsZCB3YW50IHRvIGluaXRpYWxpemUgdGhlc2UgdXNpbmcgdGhlIFwicHJldmlvdXNcIiB2YWx1ZXMgKGNoYW5nZS5vbGRWYWx1ZSksXG4gICAqIGluIGNhc2Ugb25seSBvbmUgb2YgdGhlbSBjaGFuZ2VkLCBsaWtlIHRoZSBrZXksIGFuZCB0aGUgQnVja2V0IHN0YXllZCB0aGUgc2FtZS5cbiAgICogSG93ZXZlciwgdGhhdCBhY3R1YWxseSBmYWlscyBmb3Igb2xkLXN0eWxlIHN5bnRoZXNpcywgd2hpY2ggdXNlcyBDRk4gUGFyYW1ldGVycyFcbiAgICogQmVjYXVzZSB0aGUgbmFtZXMgb2YgdGhlIFBhcmFtZXRlcnMgZGVwZW5kIG9uIHRoZSBoYXNoIG9mIHRoZSBBc3NldCxcbiAgICogdGhlIFBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIFwib2xkXCIgdmFsdWVzIG5vIGxvbmdlciBleGlzdCBpbiBgYXNzZXRQYXJhbXNgIGF0IHRoaXMgcG9pbnQsXG4gICAqIHdoaWNoIG1lYW5zIHdlIGRvbid0IGhhdmUgdGhlIGNvcnJlY3QgdmFsdWVzIGF2YWlsYWJsZSB0byBldmFsdWF0ZSB0aGUgQ0ZOIGV4cHJlc3Npb24gd2l0aC5cbiAgICogRm9ydHVuYXRlbHksIHRoZSBkaWZmIHdpbGwgYWx3YXlzIGluY2x1ZGUgYm90aCB0aGUgczNCdWNrZXQgYW5kIHMzS2V5IHBhcnRzIG9mIHRoZSBMYW1iZGEncyBDb2RlIHByb3BlcnR5LFxuICAgKiBldmVuIGlmIG9ubHkgb25lIG9mIHRoZW0gd2FzIGFjdHVhbGx5IGNoYW5nZWQsXG4gICAqIHdoaWNoIG1lYW5zIHdlIGRvbid0IG5lZWQgdGhlIFwib2xkXCIgdmFsdWVzIGF0IGFsbCwgYW5kIHdlIGNhbiBzYWZlbHkgaW5pdGlhbGl6ZSB0aGVzZSB3aXRoIGp1c3QgYCcnYC5cbiAgICovXG4gIGxldCBjb2RlOiBMYW1iZGFGdW5jdGlvbkNvZGUgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGxldCBkZXNjcmlwdGlvbjogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBsZXQgZW52aXJvbm1lbnQ6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgZm9yIChjb25zdCB1cGRhdGVkUHJvcE5hbWUgaW4gaG90c3dhcHBhYmxlUHJvcENoYW5nZXMpIHtcbiAgICBjb25zdCB1cGRhdGVkUHJvcCA9IGhvdHN3YXBwYWJsZVByb3BDaGFuZ2VzW3VwZGF0ZWRQcm9wTmFtZV07XG5cbiAgICBzd2l0Y2ggKHVwZGF0ZWRQcm9wTmFtZSkge1xuICAgICAgY2FzZSAnQ29kZSc6XG4gICAgICAgIGxldCBzM0J1Y2tldCwgczNLZXksIHMzT2JqZWN0VmVyc2lvbiwgaW1hZ2VVcmksIGZ1bmN0aW9uQ29kZVppcDtcblxuICAgICAgICBmb3IgKGNvbnN0IG5ld1Byb3BOYW1lIGluIHVwZGF0ZWRQcm9wLm5ld1ZhbHVlKSB7XG4gICAgICAgICAgc3dpdGNoIChuZXdQcm9wTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnUzNCdWNrZXQnOlxuICAgICAgICAgICAgICBzM0J1Y2tldCA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHVwZGF0ZWRQcm9wLm5ld1ZhbHVlW25ld1Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUzNLZXknOlxuICAgICAgICAgICAgICBzM0tleSA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHVwZGF0ZWRQcm9wLm5ld1ZhbHVlW25ld1Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUzNPYmplY3RWZXJzaW9uJzpcbiAgICAgICAgICAgICAgczNPYmplY3RWZXJzaW9uID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odXBkYXRlZFByb3AubmV3VmFsdWVbbmV3UHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdJbWFnZVVyaSc6XG4gICAgICAgICAgICAgIGltYWdlVXJpID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odXBkYXRlZFByb3AubmV3VmFsdWVbbmV3UHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdaaXBGaWxlJzpcbiAgICAgICAgICAgICAgLy8gV2UgbXVzdCBjcmVhdGUgYSB6aXAgcGFja2FnZSBjb250YWluaW5nIGEgZmlsZSB3aXRoIHRoZSBpbmxpbmUgY29kZVxuICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvbkNvZGUgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih1cGRhdGVkUHJvcC5uZXdWYWx1ZVtuZXdQcm9wTmFtZV0pO1xuICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvblJ1bnRpbWUgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihydW50aW1lKTtcbiAgICAgICAgICAgICAgaWYgKCFmdW5jdGlvblJ1bnRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGZpbGUgZXh0ZW5zaW9uIG11c3QgYmUgY2hvc2VuIGRlcGVuZGluZyBvbiB0aGUgcnVudGltZVxuICAgICAgICAgICAgICBjb25zdCBjb2RlRmlsZUV4dCA9IGRldGVybWluZUNvZGVGaWxlRXh0RnJvbVJ1bnRpbWUoZnVuY3Rpb25SdW50aW1lKTtcbiAgICAgICAgICAgICAgZnVuY3Rpb25Db2RlWmlwID0gYXdhaXQgemlwU3RyaW5nKGBpbmRleC4ke2NvZGVGaWxlRXh0fWAsIGZ1bmN0aW9uQ29kZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2RlID0ge1xuICAgICAgICAgIHMzQnVja2V0LFxuICAgICAgICAgIHMzS2V5LFxuICAgICAgICAgIHMzT2JqZWN0VmVyc2lvbixcbiAgICAgICAgICBpbWFnZVVyaSxcbiAgICAgICAgICBmdW5jdGlvbkNvZGVaaXAsXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRGVzY3JpcHRpb24nOlxuICAgICAgICBkZXNjcmlwdGlvbiA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHVwZGF0ZWRQcm9wLm5ld1ZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdFbnZpcm9ubWVudCc6XG4gICAgICAgIGVudmlyb25tZW50ID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odXBkYXRlZFByb3AubmV3VmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHdlIHdpbGwgbmV2ZXIgZ2V0IGhlcmUsIGJ1dCBqdXN0IGluIGNhc2Ugd2UgZG8gdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgICAnd2hpbGUgYXBwbHkoKWluZywgZm91bmQgYSBwcm9wZXJ0eSB0aGF0IGNhbm5vdCBiZSBob3Rzd2FwcGVkLiBQbGVhc2UgcmVwb3J0IHRoaXMgYXQgZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvbmV3L2Nob29zZScsXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY29uZmlndXJhdGlvbnMgPSBkZXNjcmlwdGlvbiB8fCBlbnZpcm9ubWVudCA/IHsgZGVzY3JpcHRpb24sIGVudmlyb25tZW50IH0gOiB1bmRlZmluZWQ7XG4gIHJldHVybiBjb2RlIHx8IGNvbmZpZ3VyYXRpb25zID8geyBjb2RlLCBjb25maWd1cmF0aW9ucyB9IDogdW5kZWZpbmVkO1xufVxuXG5pbnRlcmZhY2UgTGFtYmRhRnVuY3Rpb25Db2RlIHtcbiAgcmVhZG9ubHkgczNCdWNrZXQ/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHMzS2V5Pzogc3RyaW5nO1xuICByZWFkb25seSBzM09iamVjdFZlcnNpb24/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGltYWdlVXJpPzogc3RyaW5nO1xuICByZWFkb25seSBmdW5jdGlvbkNvZGVaaXA/OiBCdWZmZXI7XG59XG5cbmludGVyZmFjZSBMYW1iZGFGdW5jdGlvbkNvbmZpZ3VyYXRpb25zIHtcbiAgcmVhZG9ubHkgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGVudmlyb25tZW50PzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbn1cblxuaW50ZXJmYWNlIExhbWJkYUZ1bmN0aW9uQ2hhbmdlIHtcbiAgcmVhZG9ubHkgY29kZT86IExhbWJkYUZ1bmN0aW9uQ29kZTtcbiAgcmVhZG9ubHkgY29uZmlndXJhdGlvbnM/OiBMYW1iZGFGdW5jdGlvbkNvbmZpZ3VyYXRpb25zO1xufVxuXG4vKipcbiAqIENvbXByZXNzIGEgc3RyaW5nIGFzIGEgZmlsZSwgcmV0dXJuaW5nIGEgcHJvbWlzZSBmb3IgdGhlIHppcCBidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcmNoaXZlcmpzL25vZGUtYXJjaGl2ZXIvaXNzdWVzLzM0MlxuICovXG5mdW5jdGlvbiB6aXBTdHJpbmcoZmlsZU5hbWU6IHN0cmluZywgcmF3U3RyaW5nOiBzdHJpbmcpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGJ1ZmZlcnM6IEJ1ZmZlcltdID0gW107XG5cbiAgICBjb25zdCBjb252ZXJ0ZXIgPSBuZXcgV3JpdGFibGUoKTtcblxuICAgIGNvbnZlcnRlci5fd3JpdGUgPSAoY2h1bms6IEJ1ZmZlciwgXzogc3RyaW5nLCBjYWxsYmFjazogKCkgPT4gdm9pZCkgPT4ge1xuICAgICAgYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBjb252ZXJ0ZXIub24oJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgIHJlc29sdmUoQnVmZmVyLmNvbmNhdChidWZmZXJzKSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBhcmNoaXZlID0gYXJjaGl2ZXIoJ3ppcCcpO1xuXG4gICAgYXJjaGl2ZS5vbignZXJyb3InLCAoZXJyOiBhbnkpID0+IHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH0pO1xuXG4gICAgYXJjaGl2ZS5waXBlKGNvbnZlcnRlcik7XG5cbiAgICBhcmNoaXZlLmFwcGVuZChyYXdTdHJpbmcsIHtcbiAgICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAgZGF0ZTogbmV3IERhdGUoJzE5ODAtMDEtMDFUMDA6MDA6MDAuMDAwWicpLCAvLyBBZGQgZGF0ZSB0byBtYWtlIHJlc3VsdGluZyB6aXAgZmlsZSBkZXRlcm1pbmlzdGljXG4gICAgfSk7XG5cbiAgICB2b2lkIGFyY2hpdmUuZmluYWxpemUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQWZ0ZXIgYSBMYW1iZGEgRnVuY3Rpb24gaXMgdXBkYXRlZCwgaXQgY2Fubm90IGJlIHVwZGF0ZWQgYWdhaW4gdW50aWwgdGhlXG4gKiBgU3RhdGU9QWN0aXZlYCBhbmQgdGhlIGBMYXN0VXBkYXRlU3RhdHVzPVN1Y2Nlc3NmdWxgLlxuICpcbiAqIERlcGVuZGluZyBvbiB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgTGFtYmRhIEZ1bmN0aW9uIHRoaXMgY291bGQgaGFwcGVuIHJlbGF0aXZlbHkgcXVpY2tseVxuICogb3IgdmVyeSBzbG93bHkuIEZvciBleGFtcGxlLCBaaXAgYmFzZWQgZnVuY3Rpb25zIF9ub3RfIGluIGEgVlBDIGNhbiB0YWtlIH4xIHNlY29uZCB3aGVyZWFzIFZQQ1xuICogb3IgQ29udGFpbmVyIGZ1bmN0aW9ucyBjYW4gdGFrZSB+MjUgc2Vjb25kcyAoYW5kICdpZGxlJyBWUEMgZnVuY3Rpb25zIGNhbiB0YWtlIG1pbnV0ZXMpLlxuICovXG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yTGFtYmRhc1Byb3BlcnRpZXNVcGRhdGVUb0ZpbmlzaChcbiAgY3VycmVudEZ1bmN0aW9uQ29uZmlndXJhdGlvbjogRnVuY3Rpb25Db25maWd1cmF0aW9uLFxuICBsYW1iZGE6IElMYW1iZGFDbGllbnQsXG4gIGZ1bmN0aW9uTmFtZTogc3RyaW5nLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGZ1bmN0aW9uSXNJblZwY09yVXNlc0RvY2tlckZvckNvZGUgPVxuICAgIGN1cnJlbnRGdW5jdGlvbkNvbmZpZ3VyYXRpb24uVnBjQ29uZmlnPy5WcGNJZCB8fCBjdXJyZW50RnVuY3Rpb25Db25maWd1cmF0aW9uLlBhY2thZ2VUeXBlID09PSAnSW1hZ2UnO1xuXG4gIC8vIGlmIHRoZSBmdW5jdGlvbiBpcyBkZXBsb3llZCBpbiBhIFZQQyBvciBpZiBpdCBpcyBhIGNvbnRhaW5lciBpbWFnZSBmdW5jdGlvblxuICAvLyB0aGVuIHRoZSB1cGRhdGUgd2lsbCB0YWtlIG11Y2ggbG9uZ2VyIGFuZCB3ZSBjYW4gd2FpdCBsb25nZXIgYmV0d2VlbiBjaGVja3NcbiAgLy8gb3RoZXJ3aXNlLCB0aGUgdXBkYXRlIHdpbGwgYmUgcXVpY2ssIHNvIGEgMS1zZWNvbmQgZGVsYXkgaXMgZmluZVxuICBjb25zdCBkZWxheVNlY29uZHMgPSBmdW5jdGlvbklzSW5WcGNPclVzZXNEb2NrZXJGb3JDb2RlID8gNSA6IDE7XG5cbiAgYXdhaXQgbGFtYmRhLndhaXRVbnRpbEZ1bmN0aW9uVXBkYXRlZChkZWxheVNlY29uZHMsIHtcbiAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGZpbGUgZXh0ZW5zaW9uIGZyb20gTGFtYmRhIHJ1bnRpbWUgc3RyaW5nLlxuICogV2UgdXNlIHRoaXMgZXh0ZW5zaW9uIHRvIGNyZWF0ZSBhIGRlcGxveW1lbnQgcGFja2FnZSBmcm9tIExhbWJkYSBpbmxpbmUgY29kZS5cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQ29kZUZpbGVFeHRGcm9tUnVudGltZShydW50aW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAocnVudGltZS5zdGFydHNXaXRoKCdub2RlJykpIHtcbiAgICByZXR1cm4gJ2pzJztcbiAgfVxuICBpZiAocnVudGltZS5zdGFydHNXaXRoKCdweXRob24nKSkge1xuICAgIHJldHVybiAncHknO1xuICB9XG4gIC8vIEN1cnJlbnRseSBpbmxpbmUgY29kZSBvbmx5IHN1cHBvcnRzIE5vZGUuanMgYW5kIFB5dGhvbiwgaWdub3Jpbmcgb3RoZXIgcnVudGltZXMuXG4gIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NDbG91ZEZvcm1hdGlvbi9sYXRlc3QvVXNlckd1aWRlL2F3cy1wcm9wZXJ0aWVzLWxhbWJkYS1mdW5jdGlvbi1jb2RlLmh0bWwjYXdzLXByb3BlcnRpZXMtbGFtYmRhLWZ1bmN0aW9uLWNvZGUtcHJvcGVydGllc1xuICB0aHJvdyBuZXcgQ2ZuRXZhbHVhdGlvbkV4Y2VwdGlvbihcbiAgICBgcnVudGltZSAke3J1bnRpbWV9IGlzIHVuc3VwcG9ydGVkLCBvbmx5IG5vZGUuanMgYW5kIHB5dGhvbiBydW50aW1lcyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZC5gLFxuICApO1xufVxuXG4vKipcbiAqIEZpbmRzIGFsbCBWZXJzaW9ucyB0aGF0IHJlZmVyZW5jZSBhbiBBV1M6OkxhbWJkYTo6RnVuY3Rpb24gd2l0aCBsb2dpY2FsIElEIGBsb2dpY2FsSWRgXG4gKiBhbmQgQWxpYXNlcyB0aGF0IHJlZmVyZW5jZSB0aG9zZSBWZXJzaW9ucy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gdmVyc2lvbnNBbmRBbGlhc2VzKGxvZ2ljYWxJZDogc3RyaW5nLCBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUpIHtcbiAgLy8gZmluZCBhbGwgTGFtYmRhIFZlcnNpb25zIHRoYXQgcmVmZXJlbmNlIHRoaXMgRnVuY3Rpb25cbiAgY29uc3QgdmVyc2lvbnNSZWZlcmVuY2luZ0Z1bmN0aW9uID0gZXZhbHVhdGVDZm5UZW1wbGF0ZVxuICAgIC5maW5kUmVmZXJlbmNlc1RvKGxvZ2ljYWxJZClcbiAgICAuZmlsdGVyKChyKSA9PiByLlR5cGUgPT09ICdBV1M6OkxhbWJkYTo6VmVyc2lvbicpO1xuICAvLyBmaW5kIGFsbCBMYW1iZGEgQWxpYXNlcyB0aGF0IHJlZmVyZW5jZSB0aGUgYWJvdmUgVmVyc2lvbnNcbiAgY29uc3QgYWxpYXNlc1JlZmVyZW5jaW5nVmVyc2lvbnMgPSBmbGF0TWFwKHZlcnNpb25zUmVmZXJlbmNpbmdGdW5jdGlvbiwgdiA9PlxuICAgIGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZFJlZmVyZW5jZXNUbyh2LkxvZ2ljYWxJZCkpO1xuICAvLyBMaW1pdGVkIHNldCBvZiB1cGRhdGVzIHBlciBmdW5jdGlvblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc21cbiAgY29uc3QgYWxpYXNlc05hbWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoYWxpYXNlc1JlZmVyZW5jaW5nVmVyc2lvbnMubWFwKGEgPT5cbiAgICBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihhLlByb3BlcnRpZXM/Lk5hbWUpKSk7XG5cbiAgcmV0dXJuIHsgdmVyc2lvbnNSZWZlcmVuY2luZ0Z1bmN0aW9uLCBhbGlhc2VzTmFtZXMgfTtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzdHJpbmcgdXNlZCBpbiBkaXNwbGF5aW5nIEFsaWFzIHJlc291cmNlIG5hbWVzIHRoYXQgcmVmZXJlbmNlIHRoZSBzcGVjaWZpZWQgTGFtYmRhIEZ1bmN0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlckFsaWFzZXMoXG4gIGxvZ2ljYWxJZDogc3RyaW5nLFxuICBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4gIGNhbGxiYWNrZm46ICh2YWx1ZTogYW55LCBpbmRleDogbnVtYmVyLCBhcnJheTogYW55W10pID0+IFByb21pc2U8c3RyaW5nPixcbik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgY29uc3QgYWxpYXNlc05hbWVzID0gKGF3YWl0IHZlcnNpb25zQW5kQWxpYXNlcyhsb2dpY2FsSWQsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpKS5hbGlhc2VzTmFtZXM7XG5cbiAgLy8gTGltaXRlZCBzZXQgb2YgdXBkYXRlcyBwZXIgZnVuY3Rpb25cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBjZGtsYWJzL3Byb21pc2VhbGwtbm8tdW5ib3VuZGVkLXBhcmFsbGVsaXNtXG4gIHJldHVybiBQcm9taXNlLmFsbChhbGlhc2VzTmFtZXMubWFwKGNhbGxiYWNrZm4pKTtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzdHJpbmcgdXNlZCBpbiBkaXNwbGF5aW5nIFZlcnNpb24gcmVzb3VyY2UgbmFtZXMgdGhhdCByZWZlcmVuY2UgdGhlIHNwZWNpZmllZCBMYW1iZGEgRnVuY3Rpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVuZGVyVmVyc2lvbnMoXG4gIGxvZ2ljYWxJZDogc3RyaW5nLFxuICBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4gIHZlcnNpb25TdHJpbmc6IHN0cmluZ1tdLFxuKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICBjb25zdCB2ZXJzaW9ucyA9IChhd2FpdCB2ZXJzaW9uc0FuZEFsaWFzZXMobG9naWNhbElkLCBldmFsdWF0ZUNmblRlbXBsYXRlKSkudmVyc2lvbnNSZWZlcmVuY2luZ0Z1bmN0aW9uO1xuXG4gIHJldHVybiB2ZXJzaW9ucy5sZW5ndGggPiAwID8gdmVyc2lvblN0cmluZyA6IFtdO1xufVxuIl19