"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialPlugins = void 0;
const util_1 = require("util");
const provider_caching_1 = require("./provider-caching");
const logging_1 = require("../../logging");
const error_1 = require("../../toolkit/error");
const error_2 = require("../../util/error");
const plugin_1 = require("../plugin/plugin");
/**
 * Cache for credential providers.
 *
 * Given an account and an operating mode (read or write) will return an
 * appropriate credential provider for credentials for the given account. The
 * credential provider will be cached so that multiple AWS clients for the same
 * environment will not make multiple network calls to obtain credentials.
 *
 * Will use default credentials if they are for the right account; otherwise,
 * all loaded credential provider plugins will be tried to obtain credentials
 * for the given account.
 */
class CredentialPlugins {
    constructor(host) {
        this.cache = {};
        this.host = host !== null && host !== void 0 ? host : plugin_1.PluginHost.instance;
    }
    async fetchCredentialsFor(awsAccountId, mode) {
        const key = `${awsAccountId}-${mode}`;
        if (!(key in this.cache)) {
            this.cache[key] = await this.lookupCredentials(awsAccountId, mode);
        }
        return this.cache[key];
    }
    get availablePluginNames() {
        return this.host.credentialProviderSources.map((s) => s.name);
    }
    async lookupCredentials(awsAccountId, mode) {
        const triedSources = [];
        // Otherwise, inspect the various credential sources we have
        for (const source of this.host.credentialProviderSources) {
            let available;
            try {
                available = await source.isAvailable();
            }
            catch (e) {
                // This shouldn't happen, but let's guard against it anyway
                (0, logging_1.warning)(`Uncaught exception in ${source.name}: ${(0, error_2.formatErrorMessage)(e)}`);
                available = false;
            }
            if (!available) {
                (0, logging_1.debug)('Credentials source %s is not available, ignoring it.', source.name);
                continue;
            }
            triedSources.push(source);
            let canProvide;
            try {
                canProvide = await source.canProvideCredentials(awsAccountId);
            }
            catch (e) {
                // This shouldn't happen, but let's guard against it anyway
                (0, logging_1.warning)(`Uncaught exception in ${source.name}: ${(0, error_2.formatErrorMessage)(e)}`);
                canProvide = false;
            }
            if (!canProvide) {
                continue;
            }
            (0, logging_1.debug)(`Using ${source.name} credentials for account ${awsAccountId}`);
            return {
                credentials: await v3ProviderFromPlugin(() => source.getProvider(awsAccountId, mode, {
                    supportsV3Providers: true,
                })),
                pluginName: source.name,
            };
        }
        return undefined;
    }
}
exports.CredentialPlugins = CredentialPlugins;
/**
 * Take a function that calls the plugin, and turn it into an SDKv3-compatible credential provider.
 *
 * What we will do is the following:
 *
 * - Query the plugin and see what kind of result it gives us.
 * - If the result is self-refreshing or doesn't need refreshing, we turn it into an SDKv3 provider
 *   and return it directly.
 *   * If the underlying return value is a provider, we will make it a caching provider
 *     (because we can't know if it will cache by itself or not).
 *   * If the underlying return value is a static credential, caching isn't relevant.
 *   * If the underlying return value is V2 credentials, those have caching built-in.
 * - If the result is a static credential that expires, we will wrap it in an SDKv3 provider
 *   that will query the plugin again when the credential expires.
 */
async function v3ProviderFromPlugin(producer) {
    const initial = await producer();
    if (isV3Provider(initial)) {
        // Already a provider, make caching
        return (0, provider_caching_1.makeCachingProvider)(initial);
    }
    else if (isV3Credentials(initial) && initial.expiration === undefined) {
        // Static credentials that don't need refreshing nor caching
        return () => Promise.resolve(initial);
    }
    else if (isV3Credentials(initial) && initial.expiration !== undefined) {
        // Static credentials that do need refreshing and caching
        return refreshFromPluginProvider(initial, producer);
    }
    else if (isV2Credentials(initial)) {
        // V2 credentials that refresh and cache themselves
        return v3ProviderFromV2Credentials(initial);
    }
    else {
        throw new error_1.AuthenticationError(`Plugin returned a value that doesn't resemble AWS credentials: ${(0, util_1.inspect)(initial)}`);
    }
}
/**
 * Converts a V2 credential into a V3-compatible provider
 */
function v3ProviderFromV2Credentials(x) {
    return async () => {
        var _a;
        // Get will fetch or refresh as necessary
        await x.getPromise();
        return {
            accessKeyId: x.accessKeyId,
            secretAccessKey: x.secretAccessKey,
            sessionToken: x.sessionToken,
            expiration: (_a = x.expireTime) !== null && _a !== void 0 ? _a : undefined,
        };
    };
}
function refreshFromPluginProvider(current, producer) {
    return async () => {
        if ((0, provider_caching_1.credentialsAboutToExpire)(current)) {
            const newCreds = await producer();
            if (!isV3Credentials(newCreds)) {
                throw new error_1.AuthenticationError(`Plugin initially returned static V3 credentials but now returned something else: ${(0, util_1.inspect)(newCreds)}`);
            }
            current = newCreds;
        }
        return current;
    };
}
function isV3Provider(x) {
    return typeof x === 'function';
}
function isV2Credentials(x) {
    return !!(x && typeof x === 'object' && x.getPromise);
}
function isV3Credentials(x) {
    return !!(x && typeof x === 'object' && x.accessKeyId && !isV2Credentials(x));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlZGVudGlhbC1wbHVnaW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY3JlZGVudGlhbC1wbHVnaW5zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUcvQix5REFBbUY7QUFDbkYsMkNBQStDO0FBQy9DLCtDQUEwRDtBQUMxRCw0Q0FBc0Q7QUFFdEQsNkNBQThDO0FBRTlDOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsTUFBYSxpQkFBaUI7SUFJNUIsWUFBWSxJQUFpQjtRQUhaLFVBQUssR0FBZ0UsRUFBRSxDQUFDO1FBSXZGLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxhQUFKLElBQUksY0FBSixJQUFJLEdBQUksbUJBQVUsQ0FBQyxRQUFRLENBQUM7SUFDMUMsQ0FBQztJQUVNLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxZQUFvQixFQUFFLElBQVU7UUFDL0QsTUFBTSxHQUFHLEdBQUcsR0FBRyxZQUFZLElBQUksSUFBSSxFQUFFLENBQUM7UUFDdEMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3JFLENBQUM7UUFDRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVELElBQVcsb0JBQW9CO1FBQzdCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRU8sS0FBSyxDQUFDLGlCQUFpQixDQUFDLFlBQW9CLEVBQUUsSUFBVTtRQUM5RCxNQUFNLFlBQVksR0FBK0IsRUFBRSxDQUFDO1FBQ3BELDREQUE0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QVMsZUFBZSxDQUFDLENBQXVCO0lBQzlDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLFFBQVEsSUFBSSxDQUFDLENBQUMsV0FBVyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDaEYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluc3BlY3QgfSBmcm9tICd1dGlsJztcbmltcG9ydCB0eXBlIHsgQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlLCBGb3JSZWFkaW5nLCBGb3JXcml0aW5nLCBQbHVnaW5Qcm92aWRlclJlc3VsdCwgU0RLdjJDb21wYXRpYmxlQ3JlZGVudGlhbHMsIFNES3YzQ29tcGF0aWJsZUNyZWRlbnRpYWxQcm92aWRlciwgU0RLdjNDb21wYXRpYmxlQ3JlZGVudGlhbHMgfSBmcm9tICdAYXdzLWNkay9jbGktcGx1Z2luLWNvbnRyYWN0JztcbmltcG9ydCB0eXBlIHsgQXdzQ3JlZGVudGlhbElkZW50aXR5LCBBd3NDcmVkZW50aWFsSWRlbnRpdHlQcm92aWRlciB9IGZyb20gJ0BzbWl0aHkvdHlwZXMnO1xuaW1wb3J0IHsgY3JlZGVudGlhbHNBYm91dFRvRXhwaXJlLCBtYWtlQ2FjaGluZ1Byb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlci1jYWNoaW5nJztcbmltcG9ydCB7IGRlYnVnLCB3YXJuaW5nIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBBdXRoZW50aWNhdGlvbkVycm9yIH0gZnJvbSAnLi4vLi4vdG9vbGtpdC9lcnJvcic7XG5pbXBvcnQgeyBmb3JtYXRFcnJvck1lc3NhZ2UgfSBmcm9tICcuLi8uLi91dGlsL2Vycm9yJztcbmltcG9ydCB7IE1vZGUgfSBmcm9tICcuLi9wbHVnaW4vbW9kZSc7XG5pbXBvcnQgeyBQbHVnaW5Ib3N0IH0gZnJvbSAnLi4vcGx1Z2luL3BsdWdpbic7XG5cbi8qKlxuICogQ2FjaGUgZm9yIGNyZWRlbnRpYWwgcHJvdmlkZXJzLlxuICpcbiAqIEdpdmVuIGFuIGFjY291bnQgYW5kIGFuIG9wZXJhdGluZyBtb2RlIChyZWFkIG9yIHdyaXRlKSB3aWxsIHJldHVybiBhblxuICogYXBwcm9wcmlhdGUgY3JlZGVudGlhbCBwcm92aWRlciBmb3IgY3JlZGVudGlhbHMgZm9yIHRoZSBnaXZlbiBhY2NvdW50LiBUaGVcbiAqIGNyZWRlbnRpYWwgcHJvdmlkZXIgd2lsbCBiZSBjYWNoZWQgc28gdGhhdCBtdWx0aXBsZSBBV1MgY2xpZW50cyBmb3IgdGhlIHNhbWVcbiAqIGVudmlyb25tZW50IHdpbGwgbm90IG1ha2UgbXVsdGlwbGUgbmV0d29yayBjYWxscyB0byBvYnRhaW4gY3JlZGVudGlhbHMuXG4gKlxuICogV2lsbCB1c2UgZGVmYXVsdCBjcmVkZW50aWFscyBpZiB0aGV5IGFyZSBmb3IgdGhlIHJpZ2h0IGFjY291bnQ7IG90aGVyd2lzZSxcbiAqIGFsbCBsb2FkZWQgY3JlZGVudGlhbCBwcm92aWRlciBwbHVnaW5zIHdpbGwgYmUgdHJpZWQgdG8gb2J0YWluIGNyZWRlbnRpYWxzXG4gKiBmb3IgdGhlIGdpdmVuIGFjY291bnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBDcmVkZW50aWFsUGx1Z2lucyB7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2FjaGU6IHsgW2tleTogc3RyaW5nXTogUGx1Z2luQ3JlZGVudGlhbHNGZXRjaFJlc3VsdCB8IHVuZGVmaW5lZCB9ID0ge307XG4gIHByaXZhdGUgcmVhZG9ubHkgaG9zdDogUGx1Z2luSG9zdDtcblxuICBjb25zdHJ1Y3Rvcihob3N0PzogUGx1Z2luSG9zdCkge1xuICAgIHRoaXMuaG9zdCA9IGhvc3QgPz8gUGx1Z2luSG9zdC5pbnN0YW5jZTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBmZXRjaENyZWRlbnRpYWxzRm9yKGF3c0FjY291bnRJZDogc3RyaW5nLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxQbHVnaW5DcmVkZW50aWFsc0ZldGNoUmVzdWx0IHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3Qga2V5ID0gYCR7YXdzQWNjb3VudElkfS0ke21vZGV9YDtcbiAgICBpZiAoIShrZXkgaW4gdGhpcy5jYWNoZSkpIHtcbiAgICAgIHRoaXMuY2FjaGVba2V5XSA9IGF3YWl0IHRoaXMubG9va3VwQ3JlZGVudGlhbHMoYXdzQWNjb3VudElkLCBtb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVba2V5XTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYXZhaWxhYmxlUGx1Z2luTmFtZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhvc3QuY3JlZGVudGlhbFByb3ZpZGVyU291cmNlcy5tYXAoKHMpID0+IHMubmFtZSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvb2t1cENyZWRlbnRpYWxzKGF3c0FjY291bnRJZDogc3RyaW5nLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxQbHVnaW5DcmVkZW50aWFsc0ZldGNoUmVzdWx0IHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgdHJpZWRTb3VyY2VzOiBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VbXSA9IFtdO1xuICAgIC8vIE90aGVyd2lzZSwgaW5zcGVjdCB0aGUgdmFyaW91cyBjcmVkZW50aWFsIHNvdXJjZXMgd2UgaGF2ZVxuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHRoaXMuaG9zdC5jcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VzKSB7XG4gICAgICBsZXQgYXZhaWxhYmxlOiBib29sZWFuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXZhaWxhYmxlID0gYXdhaXQgc291cmNlLmlzQXZhaWxhYmxlKCk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBidXQgbGV0J3MgZ3VhcmQgYWdhaW5zdCBpdCBhbnl3YXlcbiAgICAgICAgd2FybmluZyhgVW5jYXVnaHQgZXhjZXB0aW9uIGluICR7c291cmNlLm5hbWV9OiAke2Zvcm1hdEVycm9yTWVzc2FnZShlKX1gKTtcbiAgICAgICAgYXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXZhaWxhYmxlKSB7XG4gICAgICAgIGRlYnVnKCdDcmVkZW50aWFscyBzb3VyY2UgJXMgaXMgbm90IGF2YWlsYWJsZSwgaWdub3JpbmcgaXQuJywgc291cmNlLm5hbWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRyaWVkU291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICBsZXQgY2FuUHJvdmlkZTogYm9vbGVhbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhblByb3ZpZGUgPSBhd2FpdCBzb3VyY2UuY2FuUHJvdmlkZUNyZWRlbnRpYWxzKGF3c0FjY291bnRJZCk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBidXQgbGV0J3MgZ3VhcmQgYWdhaW5zdCBpdCBhbnl3YXlcbiAgICAgICAgd2FybmluZyhgVW5jYXVnaHQgZXhjZXB0aW9uIGluICR7c291cmNlLm5hbWV9OiAke2Zvcm1hdEVycm9yTWVzc2FnZShlKX1gKTtcbiAgICAgICAgY2FuUHJvdmlkZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFjYW5Qcm92aWRlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZGVidWcoYFVzaW5nICR7c291cmNlLm5hbWV9IGNyZWRlbnRpYWxzIGZvciBhY2NvdW50ICR7YXdzQWNjb3VudElkfWApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjcmVkZW50aWFsczogYXdhaXQgdjNQcm92aWRlckZyb21QbHVnaW4oKCkgPT4gc291cmNlLmdldFByb3ZpZGVyKGF3c0FjY291bnRJZCwgbW9kZSBhcyBGb3JSZWFkaW5nIHwgRm9yV3JpdGluZywge1xuICAgICAgICAgIHN1cHBvcnRzVjNQcm92aWRlcnM6IHRydWUsXG4gICAgICAgIH0pKSxcbiAgICAgICAgcGx1Z2luTmFtZTogc291cmNlLm5hbWUsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogUmVzdWx0IGZyb20gdHJ5aW5nIHRvIGZldGNoIGNyZWRlbnRpYWxzIGZyb20gdGhlIFBsdWdpbiBob3N0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGx1Z2luQ3JlZGVudGlhbHNGZXRjaFJlc3VsdCB7XG4gIC8qKlxuICAgKiBTREstdjMgY29tcGF0aWJsZSBjcmVkZW50aWFsIHByb3ZpZGVyXG4gICAqL1xuICByZWFkb25seSBjcmVkZW50aWFsczogQXdzQ3JlZGVudGlhbElkZW50aXR5UHJvdmlkZXI7XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgcGx1Z2luIHRoYXQgc3VjY2Vzc2Z1bGx5IHByb3ZpZGVkIGNyZWRlbnRpYWxzXG4gICAqL1xuICByZWFkb25seSBwbHVnaW5OYW1lOiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGFrZSBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIHBsdWdpbiwgYW5kIHR1cm4gaXQgaW50byBhbiBTREt2My1jb21wYXRpYmxlIGNyZWRlbnRpYWwgcHJvdmlkZXIuXG4gKlxuICogV2hhdCB3ZSB3aWxsIGRvIGlzIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogLSBRdWVyeSB0aGUgcGx1Z2luIGFuZCBzZWUgd2hhdCBraW5kIG9mIHJlc3VsdCBpdCBnaXZlcyB1cy5cbiAqIC0gSWYgdGhlIHJlc3VsdCBpcyBzZWxmLXJlZnJlc2hpbmcgb3IgZG9lc24ndCBuZWVkIHJlZnJlc2hpbmcsIHdlIHR1cm4gaXQgaW50byBhbiBTREt2MyBwcm92aWRlclxuICogICBhbmQgcmV0dXJuIGl0IGRpcmVjdGx5LlxuICogICAqIElmIHRoZSB1bmRlcmx5aW5nIHJldHVybiB2YWx1ZSBpcyBhIHByb3ZpZGVyLCB3ZSB3aWxsIG1ha2UgaXQgYSBjYWNoaW5nIHByb3ZpZGVyXG4gKiAgICAgKGJlY2F1c2Ugd2UgY2FuJ3Qga25vdyBpZiBpdCB3aWxsIGNhY2hlIGJ5IGl0c2VsZiBvciBub3QpLlxuICogICAqIElmIHRoZSB1bmRlcmx5aW5nIHJldHVybiB2YWx1ZSBpcyBhIHN0YXRpYyBjcmVkZW50aWFsLCBjYWNoaW5nIGlzbid0IHJlbGV2YW50LlxuICogICAqIElmIHRoZSB1bmRlcmx5aW5nIHJldHVybiB2YWx1ZSBpcyBWMiBjcmVkZW50aWFscywgdGhvc2UgaGF2ZSBjYWNoaW5nIGJ1aWx0LWluLlxuICogLSBJZiB0aGUgcmVzdWx0IGlzIGEgc3RhdGljIGNyZWRlbnRpYWwgdGhhdCBleHBpcmVzLCB3ZSB3aWxsIHdyYXAgaXQgaW4gYW4gU0RLdjMgcHJvdmlkZXJcbiAqICAgdGhhdCB3aWxsIHF1ZXJ5IHRoZSBwbHVnaW4gYWdhaW4gd2hlbiB0aGUgY3JlZGVudGlhbCBleHBpcmVzLlxuICovXG5hc3luYyBmdW5jdGlvbiB2M1Byb3ZpZGVyRnJvbVBsdWdpbihwcm9kdWNlcjogKCkgPT4gUHJvbWlzZTxQbHVnaW5Qcm92aWRlclJlc3VsdD4pOiBQcm9taXNlPEF3c0NyZWRlbnRpYWxJZGVudGl0eVByb3ZpZGVyPiB7XG4gIGNvbnN0IGluaXRpYWwgPSBhd2FpdCBwcm9kdWNlcigpO1xuXG4gIGlmIChpc1YzUHJvdmlkZXIoaW5pdGlhbCkpIHtcbiAgICAvLyBBbHJlYWR5IGEgcHJvdmlkZXIsIG1ha2UgY2FjaGluZ1xuICAgIHJldHVybiBtYWtlQ2FjaGluZ1Byb3ZpZGVyKGluaXRpYWwpO1xuICB9IGVsc2UgaWYgKGlzVjNDcmVkZW50aWFscyhpbml0aWFsKSAmJiBpbml0aWFsLmV4cGlyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFN0YXRpYyBjcmVkZW50aWFscyB0aGF0IGRvbid0IG5lZWQgcmVmcmVzaGluZyBub3IgY2FjaGluZ1xuICAgIHJldHVybiAoKSA9PiBQcm9taXNlLnJlc29sdmUoaW5pdGlhbCk7XG4gIH0gZWxzZSBpZiAoaXNWM0NyZWRlbnRpYWxzKGluaXRpYWwpICYmIGluaXRpYWwuZXhwaXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gU3RhdGljIGNyZWRlbnRpYWxzIHRoYXQgZG8gbmVlZCByZWZyZXNoaW5nIGFuZCBjYWNoaW5nXG4gICAgcmV0dXJuIHJlZnJlc2hGcm9tUGx1Z2luUHJvdmlkZXIoaW5pdGlhbCwgcHJvZHVjZXIpO1xuICB9IGVsc2UgaWYgKGlzVjJDcmVkZW50aWFscyhpbml0aWFsKSkge1xuICAgIC8vIFYyIGNyZWRlbnRpYWxzIHRoYXQgcmVmcmVzaCBhbmQgY2FjaGUgdGhlbXNlbHZlc1xuICAgIHJldHVybiB2M1Byb3ZpZGVyRnJvbVYyQ3JlZGVudGlhbHMoaW5pdGlhbCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoYFBsdWdpbiByZXR1cm5lZCBhIHZhbHVlIHRoYXQgZG9lc24ndCByZXNlbWJsZSBBV1MgY3JlZGVudGlhbHM6ICR7aW5zcGVjdChpbml0aWFsKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgVjIgY3JlZGVudGlhbCBpbnRvIGEgVjMtY29tcGF0aWJsZSBwcm92aWRlclxuICovXG5mdW5jdGlvbiB2M1Byb3ZpZGVyRnJvbVYyQ3JlZGVudGlhbHMoeDogU0RLdjJDb21wYXRpYmxlQ3JlZGVudGlhbHMpOiBBd3NDcmVkZW50aWFsSWRlbnRpdHlQcm92aWRlciB7XG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgLy8gR2V0IHdpbGwgZmV0Y2ggb3IgcmVmcmVzaCBhcyBuZWNlc3NhcnlcbiAgICBhd2FpdCB4LmdldFByb21pc2UoKTtcblxuICAgIHJldHVybiB7XG4gICAgICBhY2Nlc3NLZXlJZDogeC5hY2Nlc3NLZXlJZCxcbiAgICAgIHNlY3JldEFjY2Vzc0tleTogeC5zZWNyZXRBY2Nlc3NLZXksXG4gICAgICBzZXNzaW9uVG9rZW46IHguc2Vzc2lvblRva2VuLFxuICAgICAgZXhwaXJhdGlvbjogeC5leHBpcmVUaW1lID8/IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiByZWZyZXNoRnJvbVBsdWdpblByb3ZpZGVyKGN1cnJlbnQ6IEF3c0NyZWRlbnRpYWxJZGVudGl0eSwgcHJvZHVjZXI6ICgpID0+IFByb21pc2U8UGx1Z2luUHJvdmlkZXJSZXN1bHQ+KTogQXdzQ3JlZGVudGlhbElkZW50aXR5UHJvdmlkZXIge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChjcmVkZW50aWFsc0Fib3V0VG9FeHBpcmUoY3VycmVudCkpIHtcbiAgICAgIGNvbnN0IG5ld0NyZWRzID0gYXdhaXQgcHJvZHVjZXIoKTtcbiAgICAgIGlmICghaXNWM0NyZWRlbnRpYWxzKG5ld0NyZWRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihgUGx1Z2luIGluaXRpYWxseSByZXR1cm5lZCBzdGF0aWMgVjMgY3JlZGVudGlhbHMgYnV0IG5vdyByZXR1cm5lZCBzb21ldGhpbmcgZWxzZTogJHtpbnNwZWN0KG5ld0NyZWRzKX1gKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBuZXdDcmVkcztcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzVjNQcm92aWRlcih4OiBQbHVnaW5Qcm92aWRlclJlc3VsdCk6IHggaXMgU0RLdjNDb21wYXRpYmxlQ3JlZGVudGlhbFByb3ZpZGVyIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc1YyQ3JlZGVudGlhbHMoeDogUGx1Z2luUHJvdmlkZXJSZXN1bHQpOiB4IGlzIFNES3YyQ29tcGF0aWJsZUNyZWRlbnRpYWxzIHtcbiAgcmV0dXJuICEhKHggJiYgdHlwZW9mIHggPT09ICdvYmplY3QnICYmICh4IGFzIFNES3YyQ29tcGF0aWJsZUNyZWRlbnRpYWxzKS5nZXRQcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gaXNWM0NyZWRlbnRpYWxzKHg6IFBsdWdpblByb3ZpZGVyUmVzdWx0KTogeCBpcyBTREt2M0NvbXBhdGlibGVDcmVkZW50aWFscyB7XG4gIHJldHVybiAhISh4ICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4LmFjY2Vzc0tleUlkICYmICFpc1YyQ3JlZGVudGlhbHMoeCkpO1xufVxuIl19