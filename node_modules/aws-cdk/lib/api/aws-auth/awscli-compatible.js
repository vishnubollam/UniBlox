"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsCliCompatible = void 0;
const credential_providers_1 = require("@aws-sdk/credential-providers");
const ec2_metadata_service_1 = require("@aws-sdk/ec2-metadata-service");
const shared_ini_file_loader_1 = require("@smithy/shared-ini-file-loader");
const promptly = require("promptly");
const proxy_agent_1 = require("proxy-agent");
const provider_caching_1 = require("./provider-caching");
const util_1 = require("./util");
const logging_1 = require("../../logging");
const error_1 = require("../../toolkit/error");
const DEFAULT_CONNECTION_TIMEOUT = 10000;
const DEFAULT_TIMEOUT = 300000;
/**
 * Behaviors to match AWS CLI
 *
 * See these links:
 *
 * https://docs.aws.amazon.com/cli/latest/topic/config-vars.html
 * https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html
 */
class AwsCliCompatible {
    /**
     * Build an AWS CLI-compatible credential chain provider
     *
     * The credential chain returned by this function is always caching.
     */
    static async credentialChainBuilder(options = {}) {
        const clientConfig = {
            requestHandler: AwsCliCompatible.requestHandlerBuilder(options.httpOptions),
            customUserAgent: 'aws-cdk',
            logger: options.logger,
        };
        // Super hacky solution to https://github.com/aws/aws-cdk/issues/32510, proposed by the SDK team.
        //
        // Summary of the problem: we were reading the region from the config file and passing it to
        // the credential providers. However, in the case of SSO, this makes the credential provider
        // use that region to do the SSO flow, which is incorrect. The region that should be used for
        // that is the one set in the sso_session section of the config file.
        //
        // The idea here: the "clientConfig" is for configuring the inner auth client directly,
        // and has the highest priority, whereas "parentClientConfig" is the upper data client
        // and has lower priority than the sso_region but still higher priority than STS global region.
        const parentClientConfig = {
            region: await this.region(options.profile),
        };
        /**
         * The previous implementation matched AWS CLI behavior:
         *
         * If a profile is explicitly set using `--profile`,
         * we use that to the exclusion of everything else.
         *
         * Note: this does not apply to AWS_PROFILE,
         * environment credentials still take precedence over AWS_PROFILE
         */
        if (options.profile) {
            return (0, provider_caching_1.makeCachingProvider)((0, credential_providers_1.fromIni)({
                profile: options.profile,
                ignoreCache: true,
                mfaCodeProvider: tokenCodeFn,
                clientConfig,
                parentClientConfig,
                logger: options.logger,
            }));
        }
        const envProfile = process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE;
        /**
         * Env AWS - EnvironmentCredentials with string AWS
         * Env Amazon - EnvironmentCredentials with string AMAZON
         * Profile Credentials - PatchedSharedIniFileCredentials with implicit profile, credentials file, http options, and token fn
         *    SSO with implicit profile only
         *    SharedIniFileCredentials with implicit profile and preferStaticCredentials true (profile with source_profile)
         *    Shared Credential file that points to Environment Credentials with AWS prefix
         *    Shared Credential file that points to EC2 Metadata
         *    Shared Credential file that points to ECS Credentials
         * SSO Credentials - SsoCredentials with implicit profile and http options
         * ProcessCredentials with implicit profile
         * ECS Credentials - ECSCredentials with no input OR Web Identity - TokenFileWebIdentityCredentials with no input OR EC2 Metadata - EC2MetadataCredentials with no input
         *
         * These translate to:
         * fromEnv()
         * fromSSO()/fromIni()
         * fromProcess()
         * fromContainerMetadata()
         * fromTokenFile()
         * fromInstanceMetadata()
         *
         * The NodeProviderChain is already cached.
         */
        const nodeProviderChain = (0, credential_providers_1.fromNodeProviderChain)({
            profile: envProfile,
            clientConfig,
            parentClientConfig,
            logger: options.logger,
            mfaCodeProvider: tokenCodeFn,
            ignoreCache: true,
        });
        return shouldPrioritizeEnv()
            ? (0, credential_providers_1.createCredentialChain)((0, credential_providers_1.fromEnv)(), nodeProviderChain).expireAfter(60 * 60000)
            : nodeProviderChain;
    }
    static requestHandlerBuilder(options = {}) {
        const agent = this.proxyAgent(options);
        return {
            connectionTimeout: DEFAULT_CONNECTION_TIMEOUT,
            requestTimeout: DEFAULT_TIMEOUT,
            httpsAgent: agent,
            httpAgent: agent,
        };
    }
    static proxyAgent(options) {
        // Force it to use the proxy provided through the command line.
        // Otherwise, let the ProxyAgent auto-detect the proxy using environment variables.
        const getProxyForUrl = options.proxyAddress != null
            ? () => Promise.resolve(options.proxyAddress)
            : undefined;
        return new proxy_agent_1.ProxyAgent({
            ca: tryGetCACert(options.caBundlePath),
            getProxyForUrl,
        });
    }
    /**
     * Attempts to get the region from a number of sources and falls back to us-east-1 if no region can be found,
     * as is done in the AWS CLI.
     *
     * The order of priority is the following:
     *
     * 1. Environment variables specifying region, with both an AWS prefix and AMAZON prefix
     *    to maintain backwards compatibility, and without `DEFAULT` in the name because
     *    Lambda and CodeBuild set the $AWS_REGION variable.
     * 2. Regions listed in the Shared Ini Files - First checking for the profile provided
     *    and then checking for the default profile.
     * 3. IMDS instance identity region from the Metadata Service.
     * 4. us-east-1
     */
    static async region(maybeProfile) {
        const defaultRegion = 'us-east-1';
        const profile = maybeProfile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
        const region = process.env.AWS_REGION ||
            process.env.AMAZON_REGION ||
            process.env.AWS_DEFAULT_REGION ||
            process.env.AMAZON_DEFAULT_REGION ||
            (await getRegionFromIni(profile)) ||
            (await regionFromMetadataService());
        if (!region) {
            const usedProfile = !profile ? '' : ` (profile: "${profile}")`;
            (0, logging_1.debug)(`Unable to determine AWS region from environment or AWS configuration${usedProfile}, defaulting to '${defaultRegion}'`);
            return defaultRegion;
        }
        return region;
    }
}
exports.AwsCliCompatible = AwsCliCompatible;
/**
 * Looks up the region of the provided profile. If no region is present,
 * it will attempt to lookup the default region.
 * @param profile The profile to use to lookup the region
 * @returns The region for the profile or default profile, if present. Otherwise returns undefined.
 */
async function getRegionFromIni(profile) {
    var _a, _b, _c;
    const sharedFiles = await (0, shared_ini_file_loader_1.loadSharedConfigFiles)({ ignoreCache: true });
    // Priority:
    //
    // credentials come before config because aws-cli v1 behaves like that.
    //
    // 1. profile-region-in-credentials
    // 2. profile-region-in-config
    // 3. default-region-in-credentials
    // 4. default-region-in-config
    return (_c = (_b = (_a = getRegionFromIniFile(profile, sharedFiles.credentialsFile)) !== null && _a !== void 0 ? _a : getRegionFromIniFile(profile, sharedFiles.configFile)) !== null && _b !== void 0 ? _b : getRegionFromIniFile('default', sharedFiles.credentialsFile)) !== null && _c !== void 0 ? _c : getRegionFromIniFile('default', sharedFiles.configFile);
}
function getRegionFromIniFile(profile, data) {
    var _a;
    return (_a = data === null || data === void 0 ? void 0 : data[profile]) === null || _a === void 0 ? void 0 : _a.region;
}
function tryGetCACert(bundlePath) {
    const path = bundlePath || caBundlePathFromEnvironment();
    if (path) {
        (0, logging_1.debug)('Using CA bundle path: %s', path);
        return (0, util_1.readIfPossible)(path);
    }
    return undefined;
}
/**
 * Find and return a CA certificate bundle path to be passed into the SDK.
 */
function caBundlePathFromEnvironment() {
    if (process.env.aws_ca_bundle) {
        return process.env.aws_ca_bundle;
    }
    if (process.env.AWS_CA_BUNDLE) {
        return process.env.AWS_CA_BUNDLE;
    }
    return undefined;
}
/**
 * We used to support both AWS and AMAZON prefixes for these environment variables.
 *
 * Adding this for backward compatibility.
 */
function shouldPrioritizeEnv() {
    var _a;
    const id = process.env.AWS_ACCESS_KEY_ID || process.env.AMAZON_ACCESS_KEY_ID;
    const key = process.env.AWS_SECRET_ACCESS_KEY || process.env.AMAZON_SECRET_ACCESS_KEY;
    if (!!id && !!key) {
        process.env.AWS_ACCESS_KEY_ID = id;
        process.env.AWS_SECRET_ACCESS_KEY = key;
        const sessionToken = (_a = process.env.AWS_SESSION_TOKEN) !== null && _a !== void 0 ? _a : process.env.AMAZON_SESSION_TOKEN;
        if (sessionToken) {
            process.env.AWS_SESSION_TOKEN = sessionToken;
        }
        return true;
    }
    return false;
}
/**
 * The MetadataService class will attempt to fetch the instance identity document from
 * IMDSv2 first, and then will attempt v1 as a fallback.
 *
 * If this fails, we will use us-east-1 as the region so no error should be thrown.
 * @returns The region for the instance identity
 */
async function regionFromMetadataService() {
    (0, logging_1.debug)('Looking up AWS region in the EC2 Instance Metadata Service (IMDS).');
    try {
        const metadataService = new ec2_metadata_service_1.MetadataService({
            httpOptions: {
                timeout: 1000,
            },
        });
        await metadataService.fetchMetadataToken();
        const document = await metadataService.request('/latest/dynamic/instance-identity/document', {});
        return JSON.parse(document).region;
    }
    catch (e) {
        (0, logging_1.debug)(`Unable to retrieve AWS region from IMDS: ${e}`);
    }
}
/**
 * Ask user for MFA token for given serial
 *
 * Result is send to callback function for SDK to authorize the request
 */
async function tokenCodeFn(serialArn) {
    var _a;
    (0, logging_1.debug)('Require MFA token for serial ARN', serialArn);
    try {
        const token = await promptly.prompt(`MFA token for ${serialArn}: `, {
            trim: true,
            default: '',
        });
        (0, logging_1.debug)('Successfully got MFA token from user');
        return token;
    }
    catch (err) {
        (0, logging_1.debug)('Failed to get MFA token', err);
        const e = new error_1.AuthenticationError(`Error fetching MFA token: ${(_a = err.message) !== null && _a !== void 0 ? _a : err}`);
        e.name = 'SharedIniFileCredentialsProviderFailure';
        throw e;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXdzY2xpLWNvbXBhdGlibGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJhd3NjbGktY29tcGF0aWJsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx3RUFBK0c7QUFDL0csd0VBQWdFO0FBRWhFLDJFQUF1RTtBQUV2RSxxQ0FBcUM7QUFDckMsNkNBQXlDO0FBQ3pDLHlEQUF5RDtBQUV6RCxpQ0FBd0M7QUFDeEMsMkNBQXNDO0FBQ3RDLCtDQUEwRDtBQUUxRCxNQUFNLDBCQUEwQixHQUFHLEtBQUssQ0FBQztBQUN6QyxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUM7QUFFL0I7Ozs7Ozs7R0FPRztBQUNILE1BQWEsZ0JBQWdCO0lBQzNCOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLHNCQUFzQixDQUN4QyxVQUFrQyxFQUFFO1FBRXBDLE1BQU0sWUFBWSxHQUFHO1lBQ25CLGNBQWMsRUFBRSxnQkFBZ0IsQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDO1lBQzNFLGVBQWUsRUFBRSxTQUFTO1lBQzFCLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTTtTQUN2QixDQUFDO1FBRUYsaUdBQWlHO1FBQ2pHLEVBQUU7UUFDRiw0RkFBNEY7UUFDNUYsNEZBQTRGO1FBQzVGLDZGQUE2RjtRQUM3RixxRUFBcUU7UUFDckUsRUFBRTtRQUNGLHVGQUF1RjtRQUN2RixzRkFBc0Y7UUFDdEYsK0ZBQStGO1FBQy9GLE1BQU0sa0JBQWtCLEdBQUc7WUFDekIsTUFBTSxFQUFFLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDO1NBQzNDLENBQUM7UUFDRjs7Ozs7Ozs7V0FRRztRQUNILElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3BCLE9BQU8sSUFBQSxzQ0FBbUIsRUFBQyxJQUFBLDhCQUFPLEVBQUM7Z0JBQ2pDLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTztnQkFDeEIsV0FBVyxF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RUgsTUFBTSxlQUFlLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUMzQyxNQUFNLFFBQVEsR0FBRyxNQUFNLGVBQWUsQ0FBQyxPQUFPLENBQUMsNENBQTRDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDakcsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQztJQUNyQyxDQUFDO0lBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztRQUNYLElBQUEsZUFBSyxFQUFDLDRDQUE0QyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3pELENBQUM7QUFDSCxDQUFDO0FBUUQ7Ozs7R0FJRztBQUNILEtBQUssVUFBVSxXQUFXLENBQUMsU0FBaUI7O0lBQzFDLElBQUEsZUFBSyxFQUFDLGtDQUFrQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ3JELElBQUksQ0FBQztRQUNILE1BQU0sS0FBSyxHQUFXLE1BQU0sUUFBUSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsU0FBUyxJQUFJLEVBQUU7WUFDMUUsSUFBSSxFQUFFLElBQUk7WUFDVixPQUFPLEVBQUUsRUFBRTtTQUNaLENBQUMsQ0FBQztRQUNILElBQUEsZUFBSyxFQUFDLHNDQUFzQyxDQUFDLENBQUM7UUFDOUMsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBQUMsT0FBTyxHQUFRLEVBQUUsQ0FBQztRQUNsQixJQUFBLGVBQUssRUFBQyx5QkFBeUIsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN0QyxNQUFNLENBQUMsR0FBRyxJQUFJLDJCQUFtQixDQUFDLDZCQUE2QixNQUFBLEdBQUcsQ0FBQyxPQUFPLG1DQUFJLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDckYsQ0FBQyxDQUFDLElBQUksR0FBRyx5Q0FBeUMsQ0FBQztRQUNuRCxNQUFNLENBQUMsQ0FBQztJQUNWLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ3JlZGVudGlhbENoYWluLCBmcm9tRW52LCBmcm9tSW5pLCBmcm9tTm9kZVByb3ZpZGVyQ2hhaW4gfSBmcm9tICdAYXdzLXNkay9jcmVkZW50aWFsLXByb3ZpZGVycyc7XG5pbXBvcnQgeyBNZXRhZGF0YVNlcnZpY2UgfSBmcm9tICdAYXdzLXNkay9lYzItbWV0YWRhdGEtc2VydmljZSc7XG5pbXBvcnQgdHlwZSB7IE5vZGVIdHRwSGFuZGxlck9wdGlvbnMgfSBmcm9tICdAc21pdGh5L25vZGUtaHR0cC1oYW5kbGVyJztcbmltcG9ydCB7IGxvYWRTaGFyZWRDb25maWdGaWxlcyB9IGZyb20gJ0BzbWl0aHkvc2hhcmVkLWluaS1maWxlLWxvYWRlcic7XG5pbXBvcnQgeyBBd3NDcmVkZW50aWFsSWRlbnRpdHlQcm92aWRlciwgTG9nZ2VyIH0gZnJvbSAnQHNtaXRoeS90eXBlcyc7XG5pbXBvcnQgKiBhcyBwcm9tcHRseSBmcm9tICdwcm9tcHRseSc7XG5pbXBvcnQgeyBQcm94eUFnZW50IH0gZnJvbSAncHJveHktYWdlbnQnO1xuaW1wb3J0IHsgbWFrZUNhY2hpbmdQcm92aWRlciB9IGZyb20gJy4vcHJvdmlkZXItY2FjaGluZyc7XG5pbXBvcnQgdHlwZSB7IFNka0h0dHBPcHRpb25zIH0gZnJvbSAnLi9zZGstcHJvdmlkZXInO1xuaW1wb3J0IHsgcmVhZElmUG9zc2libGUgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IEF1dGhlbnRpY2F0aW9uRXJyb3IgfSBmcm9tICcuLi8uLi90b29sa2l0L2Vycm9yJztcblxuY29uc3QgREVGQVVMVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAxMDAwMDtcbmNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDMwMDAwMDtcblxuLyoqXG4gKiBCZWhhdmlvcnMgdG8gbWF0Y2ggQVdTIENMSVxuICpcbiAqIFNlZSB0aGVzZSBsaW5rczpcbiAqXG4gKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2xpL2xhdGVzdC90b3BpYy9jb25maWctdmFycy5odG1sXG4gKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2xpL2xhdGVzdC91c2VyZ3VpZGUvY2xpLWNvbmZpZ3VyZS1lbnZ2YXJzLmh0bWxcbiAqL1xuZXhwb3J0IGNsYXNzIEF3c0NsaUNvbXBhdGlibGUge1xuICAvKipcbiAgICogQnVpbGQgYW4gQVdTIENMSS1jb21wYXRpYmxlIGNyZWRlbnRpYWwgY2hhaW4gcHJvdmlkZXJcbiAgICpcbiAgICogVGhlIGNyZWRlbnRpYWwgY2hhaW4gcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiBpcyBhbHdheXMgY2FjaGluZy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgY3JlZGVudGlhbENoYWluQnVpbGRlcihcbiAgICBvcHRpb25zOiBDcmVkZW50aWFsQ2hhaW5PcHRpb25zID0ge30sXG4gICk6IFByb21pc2U8QXdzQ3JlZGVudGlhbElkZW50aXR5UHJvdmlkZXI+IHtcbiAgICBjb25zdCBjbGllbnRDb25maWcgPSB7XG4gICAgICByZXF1ZXN0SGFuZGxlcjogQXdzQ2xpQ29tcGF0aWJsZS5yZXF1ZXN0SGFuZGxlckJ1aWxkZXIob3B0aW9ucy5odHRwT3B0aW9ucyksXG4gICAgICBjdXN0b21Vc2VyQWdlbnQ6ICdhd3MtY2RrJyxcbiAgICAgIGxvZ2dlcjogb3B0aW9ucy5sb2dnZXIsXG4gICAgfTtcblxuICAgIC8vIFN1cGVyIGhhY2t5IHNvbHV0aW9uIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvMzI1MTAsIHByb3Bvc2VkIGJ5IHRoZSBTREsgdGVhbS5cbiAgICAvL1xuICAgIC8vIFN1bW1hcnkgb2YgdGhlIHByb2JsZW06IHdlIHdlcmUgcmVhZGluZyB0aGUgcmVnaW9uIGZyb20gdGhlIGNvbmZpZyBmaWxlIGFuZCBwYXNzaW5nIGl0IHRvXG4gICAgLy8gdGhlIGNyZWRlbnRpYWwgcHJvdmlkZXJzLiBIb3dldmVyLCBpbiB0aGUgY2FzZSBvZiBTU08sIHRoaXMgbWFrZXMgdGhlIGNyZWRlbnRpYWwgcHJvdmlkZXJcbiAgICAvLyB1c2UgdGhhdCByZWdpb24gdG8gZG8gdGhlIFNTTyBmbG93LCB3aGljaCBpcyBpbmNvcnJlY3QuIFRoZSByZWdpb24gdGhhdCBzaG91bGQgYmUgdXNlZCBmb3JcbiAgICAvLyB0aGF0IGlzIHRoZSBvbmUgc2V0IGluIHRoZSBzc29fc2Vzc2lvbiBzZWN0aW9uIG9mIHRoZSBjb25maWcgZmlsZS5cbiAgICAvL1xuICAgIC8vIFRoZSBpZGVhIGhlcmU6IHRoZSBcImNsaWVudENvbmZpZ1wiIGlzIGZvciBjb25maWd1cmluZyB0aGUgaW5uZXIgYXV0aCBjbGllbnQgZGlyZWN0bHksXG4gICAgLy8gYW5kIGhhcyB0aGUgaGlnaGVzdCBwcmlvcml0eSwgd2hlcmVhcyBcInBhcmVudENsaWVudENvbmZpZ1wiIGlzIHRoZSB1cHBlciBkYXRhIGNsaWVudFxuICAgIC8vIGFuZCBoYXMgbG93ZXIgcHJpb3JpdHkgdGhhbiB0aGUgc3NvX3JlZ2lvbiBidXQgc3RpbGwgaGlnaGVyIHByaW9yaXR5IHRoYW4gU1RTIGdsb2JhbCByZWdpb24uXG4gICAgY29uc3QgcGFyZW50Q2xpZW50Q29uZmlnID0ge1xuICAgICAgcmVnaW9uOiBhd2FpdCB0aGlzLnJlZ2lvbihvcHRpb25zLnByb2ZpbGUpLFxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIGltcGxlbWVudGF0aW9uIG1hdGNoZWQgQVdTIENMSSBiZWhhdmlvcjpcbiAgICAgKlxuICAgICAqIElmIGEgcHJvZmlsZSBpcyBleHBsaWNpdGx5IHNldCB1c2luZyBgLS1wcm9maWxlYCxcbiAgICAgKiB3ZSB1c2UgdGhhdCB0byB0aGUgZXhjbHVzaW9uIG9mIGV2ZXJ5dGhpbmcgZWxzZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgZG9lcyBub3QgYXBwbHkgdG8gQVdTX1BST0ZJTEUsXG4gICAgICogZW52aXJvbm1lbnQgY3JlZGVudGlhbHMgc3RpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXIgQVdTX1BST0ZJTEVcbiAgICAgKi9cbiAgICBpZiAob3B0aW9ucy5wcm9maWxlKSB7XG4gICAgICByZXR1cm4gbWFrZUNhY2hpbmdQcm92aWRlcihmcm9tSW5pKHtcbiAgICAgICAgcHJvZmlsZTogb3B0aW9ucy5wcm9maWxlLFxuICAgICAgICBpZ25vcmVDYWNoZTogdHJ1ZSxcbiAgICAgICAgbWZhQ29kZVByb3ZpZGVyOiB0b2tlbkNvZGVGbixcbiAgICAgICAgY2xpZW50Q29uZmlnLFxuICAgICAgICBwYXJlbnRDbGllbnRDb25maWcsXG4gICAgICAgIGxvZ2dlcjogb3B0aW9ucy5sb2dnZXIsXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgY29uc3QgZW52UHJvZmlsZSA9IHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1BST0ZJTEU7XG5cbiAgICAvKipcbiAgICAgKiBFbnYgQVdTIC0gRW52aXJvbm1lbnRDcmVkZW50aWFscyB3aXRoIHN0cmluZyBBV1NcbiAgICAgKiBFbnYgQW1hem9uIC0gRW52aXJvbm1lbnRDcmVkZW50aWFscyB3aXRoIHN0cmluZyBBTUFaT05cbiAgICAgKiBQcm9maWxlIENyZWRlbnRpYWxzIC0gUGF0Y2hlZFNoYXJlZEluaUZpbGVDcmVkZW50aWFscyB3aXRoIGltcGxpY2l0IHByb2ZpbGUsIGNyZWRlbnRpYWxzIGZpbGUsIGh0dHAgb3B0aW9ucywgYW5kIHRva2VuIGZuXG4gICAgICogICAgU1NPIHdpdGggaW1wbGljaXQgcHJvZmlsZSBvbmx5XG4gICAgICogICAgU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzIHdpdGggaW1wbGljaXQgcHJvZmlsZSBhbmQgcHJlZmVyU3RhdGljQ3JlZGVudGlhbHMgdHJ1ZSAocHJvZmlsZSB3aXRoIHNvdXJjZV9wcm9maWxlKVxuICAgICAqICAgIFNoYXJlZCBDcmVkZW50aWFsIGZpbGUgdGhhdCBwb2ludHMgdG8gRW52aXJvbm1lbnQgQ3JlZGVudGlhbHMgd2l0aCBBV1MgcHJlZml4XG4gICAgICogICAgU2hhcmVkIENyZWRlbnRpYWwgZmlsZSB0aGF0IHBvaW50cyB0byBFQzIgTWV0YWRhdGFcbiAgICAgKiAgICBTaGFyZWQgQ3JlZGVudGlhbCBmaWxlIHRoYXQgcG9pbnRzIHRvIEVDUyBDcmVkZW50aWFsc1xuICAgICAqIFNTTyBDcmVkZW50aWFscyAtIFNzb0NyZWRlbnRpYWxzIHdpdGggaW1wbGljaXQgcHJvZmlsZSBhbmQgaHR0cCBvcHRpb25zXG4gICAgICogUHJvY2Vzc0NyZWRlbnRpYWxzIHdpdGggaW1wbGljaXQgcHJvZmlsZVxuICAgICAqIEVDUyBDcmVkZW50aWFscyAtIEVDU0NyZWRlbnRpYWxzIHdpdGggbm8gaW5wdXQgT1IgV2ViIElkZW50aXR5IC0gVG9rZW5GaWxlV2ViSWRlbnRpdHlDcmVkZW50aWFscyB3aXRoIG5vIGlucHV0IE9SIEVDMiBNZXRhZGF0YSAtIEVDMk1ldGFkYXRhQ3JlZGVudGlhbHMgd2l0aCBubyBpbnB1dFxuICAgICAqXG4gICAgICogVGhlc2UgdHJhbnNsYXRlIHRvOlxuICAgICAqIGZyb21FbnYoKVxuICAgICAqIGZyb21TU08oKS9mcm9tSW5pKClcbiAgICAgKiBmcm9tUHJvY2VzcygpXG4gICAgICogZnJvbUNvbnRhaW5lck1ldGFkYXRhKClcbiAgICAgKiBmcm9tVG9rZW5GaWxlKClcbiAgICAgKiBmcm9tSW5zdGFuY2VNZXRhZGF0YSgpXG4gICAgICpcbiAgICAgKiBUaGUgTm9kZVByb3ZpZGVyQ2hhaW4gaXMgYWxyZWFkeSBjYWNoZWQuXG4gICAgICovXG4gICAgY29uc3Qgbm9kZVByb3ZpZGVyQ2hhaW4gPSBmcm9tTm9kZVByb3ZpZGVyQ2hhaW4oe1xuICAgICAgcHJvZmlsZTogZW52UHJvZmlsZSxcbiAgICAgIGNsaWVudENvbmZpZyxcbiAgICAgIHBhcmVudENsaWVudENvbmZpZyxcbiAgICAgIGxvZ2dlcjogb3B0aW9ucy5sb2dnZXIsXG4gICAgICBtZmFDb2RlUHJvdmlkZXI6IHRva2VuQ29kZUZuLFxuICAgICAgaWdub3JlQ2FjaGU6IHRydWUsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2hvdWxkUHJpb3JpdGl6ZUVudigpXG4gICAgICA/IGNyZWF0ZUNyZWRlbnRpYWxDaGFpbihmcm9tRW52KCksIG5vZGVQcm92aWRlckNoYWluKS5leHBpcmVBZnRlcig2MCAqIDYwXzAwMClcbiAgICAgIDogbm9kZVByb3ZpZGVyQ2hhaW47XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHJlcXVlc3RIYW5kbGVyQnVpbGRlcihvcHRpb25zOiBTZGtIdHRwT3B0aW9ucyA9IHt9KTogTm9kZUh0dHBIYW5kbGVyT3B0aW9ucyB7XG4gICAgY29uc3QgYWdlbnQgPSB0aGlzLnByb3h5QWdlbnQob3B0aW9ucyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29ubmVjdGlvblRpbWVvdXQ6IERFRkFVTFRfQ09OTkVDVElPTl9USU1FT1VULFxuICAgICAgcmVxdWVzdFRpbWVvdXQ6IERFRkFVTFRfVElNRU9VVCxcbiAgICAgIGh0dHBzQWdlbnQ6IGFnZW50LFxuICAgICAgaHR0cEFnZW50OiBhZ2VudCxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBwcm94eUFnZW50KG9wdGlvbnM6IFNka0h0dHBPcHRpb25zKSB7XG4gICAgLy8gRm9yY2UgaXQgdG8gdXNlIHRoZSBwcm94eSBwcm92aWRlZCB0aHJvdWdoIHRoZSBjb21tYW5kIGxpbmUuXG4gICAgLy8gT3RoZXJ3aXNlLCBsZXQgdGhlIFByb3h5QWdlbnQgYXV0by1kZXRlY3QgdGhlIHByb3h5IHVzaW5nIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICBjb25zdCBnZXRQcm94eUZvclVybCA9IG9wdGlvbnMucHJveHlBZGRyZXNzICE9IG51bGxcbiAgICAgID8gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMucHJveHlBZGRyZXNzISlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIG5ldyBQcm94eUFnZW50KHtcbiAgICAgIGNhOiB0cnlHZXRDQUNlcnQob3B0aW9ucy5jYUJ1bmRsZVBhdGgpLFxuICAgICAgZ2V0UHJveHlGb3JVcmwsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZ2V0IHRoZSByZWdpb24gZnJvbSBhIG51bWJlciBvZiBzb3VyY2VzIGFuZCBmYWxscyBiYWNrIHRvIHVzLWVhc3QtMSBpZiBubyByZWdpb24gY2FuIGJlIGZvdW5kLFxuICAgKiBhcyBpcyBkb25lIGluIHRoZSBBV1MgQ0xJLlxuICAgKlxuICAgKiBUaGUgb3JkZXIgb2YgcHJpb3JpdHkgaXMgdGhlIGZvbGxvd2luZzpcbiAgICpcbiAgICogMS4gRW52aXJvbm1lbnQgdmFyaWFibGVzIHNwZWNpZnlpbmcgcmVnaW9uLCB3aXRoIGJvdGggYW4gQVdTIHByZWZpeCBhbmQgQU1BWk9OIHByZWZpeFxuICAgKiAgICB0byBtYWludGFpbiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYW5kIHdpdGhvdXQgYERFRkFVTFRgIGluIHRoZSBuYW1lIGJlY2F1c2VcbiAgICogICAgTGFtYmRhIGFuZCBDb2RlQnVpbGQgc2V0IHRoZSAkQVdTX1JFR0lPTiB2YXJpYWJsZS5cbiAgICogMi4gUmVnaW9ucyBsaXN0ZWQgaW4gdGhlIFNoYXJlZCBJbmkgRmlsZXMgLSBGaXJzdCBjaGVja2luZyBmb3IgdGhlIHByb2ZpbGUgcHJvdmlkZWRcbiAgICogICAgYW5kIHRoZW4gY2hlY2tpbmcgZm9yIHRoZSBkZWZhdWx0IHByb2ZpbGUuXG4gICAqIDMuIElNRFMgaW5zdGFuY2UgaWRlbnRpdHkgcmVnaW9uIGZyb20gdGhlIE1ldGFkYXRhIFNlcnZpY2UuXG4gICAqIDQuIHVzLWVhc3QtMVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyByZWdpb24obWF5YmVQcm9maWxlPzogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBkZWZhdWx0UmVnaW9uID0gJ3VzLWVhc3QtMSc7XG4gICAgY29uc3QgcHJvZmlsZSA9IG1heWJlUHJvZmlsZSB8fCBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9QUk9GSUxFIHx8ICdkZWZhdWx0JztcblxuICAgIGNvbnN0IHJlZ2lvbiA9XG4gICAgICBwcm9jZXNzLmVudi5BV1NfUkVHSU9OIHx8XG4gICAgICBwcm9jZXNzLmVudi5BTUFaT05fUkVHSU9OIHx8XG4gICAgICBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9SRUdJT04gfHxcbiAgICAgIHByb2Nlc3MuZW52LkFNQVpPTl9ERUZBVUxUX1JFR0lPTiB8fFxuICAgICAgKGF3YWl0IGdldFJlZ2lvbkZyb21JbmkocHJvZmlsZSkpIHx8XG4gICAgICAoYXdhaXQgcmVnaW9uRnJvbU1ldGFkYXRhU2VydmljZSgpKTtcblxuICAgIGlmICghcmVnaW9uKSB7XG4gICAgICBjb25zdCB1c2VkUHJvZmlsZSA9ICFwcm9maWxlID8gJycgOiBgIChwcm9maWxlOiBcIiR7cHJvZmlsZX1cIilgO1xuICAgICAgZGVidWcoXG4gICAgICAgIGBVbmFibGUgdG8gZGV0ZXJtaW5lIEFXUyByZWdpb24gZnJvbSBlbnZpcm9ubWVudCBvciBBV1MgY29uZmlndXJhdGlvbiR7dXNlZFByb2ZpbGV9LCBkZWZhdWx0aW5nIHRvICcke2RlZmF1bHRSZWdpb259J2AsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRlZmF1bHRSZWdpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2lvbjtcbiAgfVxufVxuXG4vKipcbiAqIExvb2tzIHVwIHRoZSByZWdpb24gb2YgdGhlIHByb3ZpZGVkIHByb2ZpbGUuIElmIG5vIHJlZ2lvbiBpcyBwcmVzZW50LFxuICogaXQgd2lsbCBhdHRlbXB0IHRvIGxvb2t1cCB0aGUgZGVmYXVsdCByZWdpb24uXG4gKiBAcGFyYW0gcHJvZmlsZSBUaGUgcHJvZmlsZSB0byB1c2UgdG8gbG9va3VwIHRoZSByZWdpb25cbiAqIEByZXR1cm5zIFRoZSByZWdpb24gZm9yIHRoZSBwcm9maWxlIG9yIGRlZmF1bHQgcHJvZmlsZSwgaWYgcHJlc2VudC4gT3RoZXJ3aXNlIHJldHVybnMgdW5kZWZpbmVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRSZWdpb25Gcm9tSW5pKHByb2ZpbGU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0IHNoYXJlZEZpbGVzID0gYXdhaXQgbG9hZFNoYXJlZENvbmZpZ0ZpbGVzKHsgaWdub3JlQ2FjaGU6IHRydWUgfSk7XG5cbiAgLy8gUHJpb3JpdHk6XG4gIC8vXG4gIC8vIGNyZWRlbnRpYWxzIGNvbWUgYmVmb3JlIGNvbmZpZyBiZWNhdXNlIGF3cy1jbGkgdjEgYmVoYXZlcyBsaWtlIHRoYXQuXG4gIC8vXG4gIC8vIDEuIHByb2ZpbGUtcmVnaW9uLWluLWNyZWRlbnRpYWxzXG4gIC8vIDIuIHByb2ZpbGUtcmVnaW9uLWluLWNvbmZpZ1xuICAvLyAzLiBkZWZhdWx0LXJlZ2lvbi1pbi1jcmVkZW50aWFsc1xuICAvLyA0LiBkZWZhdWx0LXJlZ2lvbi1pbi1jb25maWdcblxuICByZXR1cm4gZ2V0UmVnaW9uRnJvbUluaUZpbGUocHJvZmlsZSwgc2hhcmVkRmlsZXMuY3JlZGVudGlhbHNGaWxlKVxuICAgID8/IGdldFJlZ2lvbkZyb21JbmlGaWxlKHByb2ZpbGUsIHNoYXJlZEZpbGVzLmNvbmZpZ0ZpbGUpXG4gICAgPz8gZ2V0UmVnaW9uRnJvbUluaUZpbGUoJ2RlZmF1bHQnLCBzaGFyZWRGaWxlcy5jcmVkZW50aWFsc0ZpbGUpXG4gICAgPz8gZ2V0UmVnaW9uRnJvbUluaUZpbGUoJ2RlZmF1bHQnLCBzaGFyZWRGaWxlcy5jb25maWdGaWxlKTtcblxufVxuXG5mdW5jdGlvbiBnZXRSZWdpb25Gcm9tSW5pRmlsZShwcm9maWxlOiBzdHJpbmcsIGRhdGE/OiBhbnkpIHtcbiAgcmV0dXJuIGRhdGE/Lltwcm9maWxlXT8ucmVnaW9uO1xufVxuXG5mdW5jdGlvbiB0cnlHZXRDQUNlcnQoYnVuZGxlUGF0aD86IHN0cmluZykge1xuICBjb25zdCBwYXRoID0gYnVuZGxlUGF0aCB8fCBjYUJ1bmRsZVBhdGhGcm9tRW52aXJvbm1lbnQoKTtcbiAgaWYgKHBhdGgpIHtcbiAgICBkZWJ1ZygnVXNpbmcgQ0EgYnVuZGxlIHBhdGg6ICVzJywgcGF0aCk7XG4gICAgcmV0dXJuIHJlYWRJZlBvc3NpYmxlKHBhdGgpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogRmluZCBhbmQgcmV0dXJuIGEgQ0EgY2VydGlmaWNhdGUgYnVuZGxlIHBhdGggdG8gYmUgcGFzc2VkIGludG8gdGhlIFNESy5cbiAqL1xuZnVuY3Rpb24gY2FCdW5kbGVQYXRoRnJvbUVudmlyb25tZW50KCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmIChwcm9jZXNzLmVudi5hd3NfY2FfYnVuZGxlKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LmF3c19jYV9idW5kbGU7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52LkFXU19DQV9CVU5ETEUpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuQVdTX0NBX0JVTkRMRTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFdlIHVzZWQgdG8gc3VwcG9ydCBib3RoIEFXUyBhbmQgQU1BWk9OIHByZWZpeGVzIGZvciB0aGVzZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogQWRkaW5nIHRoaXMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFByaW9yaXRpemVFbnYoKSB7XG4gIGNvbnN0IGlkID0gcHJvY2Vzcy5lbnYuQVdTX0FDQ0VTU19LRVlfSUQgfHwgcHJvY2Vzcy5lbnYuQU1BWk9OX0FDQ0VTU19LRVlfSUQ7XG4gIGNvbnN0IGtleSA9IHByb2Nlc3MuZW52LkFXU19TRUNSRVRfQUNDRVNTX0tFWSB8fCBwcm9jZXNzLmVudi5BTUFaT05fU0VDUkVUX0FDQ0VTU19LRVk7XG5cbiAgaWYgKCEhaWQgJiYgISFrZXkpIHtcbiAgICBwcm9jZXNzLmVudi5BV1NfQUNDRVNTX0tFWV9JRCA9IGlkO1xuICAgIHByb2Nlc3MuZW52LkFXU19TRUNSRVRfQUNDRVNTX0tFWSA9IGtleTtcblxuICAgIGNvbnN0IHNlc3Npb25Ub2tlbiA9IHByb2Nlc3MuZW52LkFXU19TRVNTSU9OX1RPS0VOID8/IHByb2Nlc3MuZW52LkFNQVpPTl9TRVNTSU9OX1RPS0VOO1xuICAgIGlmIChzZXNzaW9uVG9rZW4pIHtcbiAgICAgIHByb2Nlc3MuZW52LkFXU19TRVNTSU9OX1RPS0VOID0gc2Vzc2lvblRva2VuO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBNZXRhZGF0YVNlcnZpY2UgY2xhc3Mgd2lsbCBhdHRlbXB0IHRvIGZldGNoIHRoZSBpbnN0YW5jZSBpZGVudGl0eSBkb2N1bWVudCBmcm9tXG4gKiBJTURTdjIgZmlyc3QsIGFuZCB0aGVuIHdpbGwgYXR0ZW1wdCB2MSBhcyBhIGZhbGxiYWNrLlxuICpcbiAqIElmIHRoaXMgZmFpbHMsIHdlIHdpbGwgdXNlIHVzLWVhc3QtMSBhcyB0aGUgcmVnaW9uIHNvIG5vIGVycm9yIHNob3VsZCBiZSB0aHJvd24uXG4gKiBAcmV0dXJucyBUaGUgcmVnaW9uIGZvciB0aGUgaW5zdGFuY2UgaWRlbnRpdHlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVnaW9uRnJvbU1ldGFkYXRhU2VydmljZSgpIHtcbiAgZGVidWcoJ0xvb2tpbmcgdXAgQVdTIHJlZ2lvbiBpbiB0aGUgRUMyIEluc3RhbmNlIE1ldGFkYXRhIFNlcnZpY2UgKElNRFMpLicpO1xuICB0cnkge1xuICAgIGNvbnN0IG1ldGFkYXRhU2VydmljZSA9IG5ldyBNZXRhZGF0YVNlcnZpY2Uoe1xuICAgICAgaHR0cE9wdGlvbnM6IHtcbiAgICAgICAgdGltZW91dDogMTAwMCxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBhd2FpdCBtZXRhZGF0YVNlcnZpY2UuZmV0Y2hNZXRhZGF0YVRva2VuKCk7XG4gICAgY29uc3QgZG9jdW1lbnQgPSBhd2FpdCBtZXRhZGF0YVNlcnZpY2UucmVxdWVzdCgnL2xhdGVzdC9keW5hbWljL2luc3RhbmNlLWlkZW50aXR5L2RvY3VtZW50Jywge30pO1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRvY3VtZW50KS5yZWdpb247XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZyhgVW5hYmxlIHRvIHJldHJpZXZlIEFXUyByZWdpb24gZnJvbSBJTURTOiAke2V9YCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVkZW50aWFsQ2hhaW5PcHRpb25zIHtcbiAgcmVhZG9ubHkgcHJvZmlsZT86IHN0cmluZztcbiAgcmVhZG9ubHkgaHR0cE9wdGlvbnM/OiBTZGtIdHRwT3B0aW9ucztcbiAgcmVhZG9ubHkgbG9nZ2VyPzogTG9nZ2VyO1xufVxuXG4vKipcbiAqIEFzayB1c2VyIGZvciBNRkEgdG9rZW4gZm9yIGdpdmVuIHNlcmlhbFxuICpcbiAqIFJlc3VsdCBpcyBzZW5kIHRvIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBTREsgdG8gYXV0aG9yaXplIHRoZSByZXF1ZXN0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRva2VuQ29kZUZuKHNlcmlhbEFybjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgZGVidWcoJ1JlcXVpcmUgTUZBIHRva2VuIGZvciBzZXJpYWwgQVJOJywgc2VyaWFsQXJuKTtcbiAgdHJ5IHtcbiAgICBjb25zdCB0b2tlbjogc3RyaW5nID0gYXdhaXQgcHJvbXB0bHkucHJvbXB0KGBNRkEgdG9rZW4gZm9yICR7c2VyaWFsQXJufTogYCwge1xuICAgICAgdHJpbTogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6ICcnLFxuICAgIH0pO1xuICAgIGRlYnVnKCdTdWNjZXNzZnVsbHkgZ290IE1GQSB0b2tlbiBmcm9tIHVzZXInKTtcbiAgICByZXR1cm4gdG9rZW47XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgZGVidWcoJ0ZhaWxlZCB0byBnZXQgTUZBIHRva2VuJywgZXJyKTtcbiAgICBjb25zdCBlID0gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoYEVycm9yIGZldGNoaW5nIE1GQSB0b2tlbjogJHtlcnIubWVzc2FnZSA/PyBlcnJ9YCk7XG4gICAgZS5uYW1lID0gJ1NoYXJlZEluaUZpbGVDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZSc7XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuIl19