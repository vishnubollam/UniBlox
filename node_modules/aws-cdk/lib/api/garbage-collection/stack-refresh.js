"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackgroundStackRefresh = exports.ActiveAssetCache = void 0;
exports.refreshStacks = refreshStacks;
const messages_1 = require("../../cli/messages");
const error_1 = require("../../toolkit/error");
class ActiveAssetCache {
    constructor() {
        this.stacks = new Set();
    }
    rememberStack(stackTemplate) {
        this.stacks.add(stackTemplate);
    }
    contains(asset) {
        for (const stack of this.stacks) {
            if (stack.includes(asset)) {
                return true;
            }
        }
        return false;
    }
}
exports.ActiveAssetCache = ActiveAssetCache;
async function paginateSdkCall(cb) {
    let finished = false;
    let nextToken;
    while (!finished) {
        nextToken = await cb(nextToken);
        if (nextToken === undefined) {
            finished = true;
        }
    }
}
/**
 * Fetches all relevant stack templates from CloudFormation. It ignores the following stacks:
 * - stacks in DELETE_COMPLETE or DELETE_IN_PROGRESS stage
 * - stacks that are using a different bootstrap qualifier
 */
async function fetchAllStackTemplates(cfn, { ioHost, action }, qualifier) {
    var _a;
    const stackNames = [];
    await paginateSdkCall(async (nextToken) => {
        var _a;
        const stacks = await cfn.listStacks({ NextToken: nextToken });
        // We ignore stacks with these statuses because their assets are no longer live
        const ignoredStatues = ['CREATE_FAILED', 'DELETE_COMPLETE', 'DELETE_IN_PROGRESS', 'DELETE_FAILED', 'REVIEW_IN_PROGRESS'];
        stackNames.push(...((_a = stacks.StackSummaries) !== null && _a !== void 0 ? _a : [])
            .filter((s) => !ignoredStatues.includes(s.StackStatus))
            .map((s) => { var _a; return (_a = s.StackId) !== null && _a !== void 0 ? _a : s.StackName; }));
        return stacks.NextToken;
    });
    await ioHost.notify((0, messages_1.debug)(action, `Parsing through ${stackNames.length} stacks`));
    const templates = [];
    for (const stack of stackNames) {
        let summary;
        summary = await cfn.getTemplateSummary({
            StackName: stack,
        });
        if (bootstrapFilter(summary.Parameters, qualifier)) {
            // This stack is definitely bootstrapped to a different qualifier so we can safely ignore it
            continue;
        }
        else {
            const template = await cfn.getTemplate({
                StackName: stack,
            });
            templates.push(((_a = template.TemplateBody) !== null && _a !== void 0 ? _a : '') + JSON.stringify(summary === null || summary === void 0 ? void 0 : summary.Parameters));
        }
    }
    await ioHost.notify((0, messages_1.debug)(action, 'Done parsing through stacks'));
    return templates;
}
/**
 * Filter out stacks that we KNOW are using a different bootstrap qualifier
 * This is mostly necessary for the integration tests that can run the same app (with the same assets)
 * under different qualifiers.
 * This is necessary because a stack under a different bootstrap could coincidentally reference the same hash
 * and cause a false negative (cause an asset to be preserved when its isolated)
 * This is intentionally done in a way where we ONLY filter out stacks that are meant for a different qualifier
 * because we are okay with false positives.
 */
function bootstrapFilter(parameters, qualifier) {
    var _a;
    const bootstrapVersion = parameters === null || parameters === void 0 ? void 0 : parameters.find((p) => p.ParameterKey === 'BootstrapVersion');
    const splitBootstrapVersion = (_a = bootstrapVersion === null || bootstrapVersion === void 0 ? void 0 : bootstrapVersion.DefaultValue) === null || _a === void 0 ? void 0 : _a.split('/');
    // We find the qualifier in a specific part of the bootstrap version parameter
    return (qualifier &&
        splitBootstrapVersion &&
        splitBootstrapVersion.length == 4 &&
        splitBootstrapVersion[2] != qualifier);
}
async function refreshStacks(cfn, { ioHost, action }, activeAssets, qualifier) {
    try {
        const stacks = await fetchAllStackTemplates(cfn, { ioHost, action }, qualifier);
        for (const stack of stacks) {
            activeAssets.rememberStack(stack);
        }
    }
    catch (err) {
        throw new error_1.ToolkitError(`Error refreshing stacks: ${err}`);
    }
}
/**
 * Class that controls scheduling of the background stack refresh
 */
class BackgroundStackRefresh {
    constructor(props) {
        this.props = props;
        this.queuedPromises = [];
        this.lastRefreshTime = Date.now();
    }
    start() {
        // Since start is going to be called right after the first invocation of refreshStacks,
        // lets wait some time before beginning the background refresh.
        this.timeout = setTimeout(() => this.refresh(), 300000); // 5 minutes
    }
    async refresh() {
        const startTime = Date.now();
        await refreshStacks(this.props.cfn, this.props.msg, this.props.activeAssets, this.props.qualifier);
        this.justRefreshedStacks();
        // If the last invocation of refreshStacks takes <5 minutes, the next invocation starts 5 minutes after the last one started.
        // If the last invocation of refreshStacks takes >5 minutes, the next invocation starts immediately.
        this.timeout = setTimeout(() => this.refresh(), Math.max(startTime + 300000 - Date.now(), 0));
    }
    justRefreshedStacks() {
        this.lastRefreshTime = Date.now();
        for (const p of this.queuedPromises.splice(0, this.queuedPromises.length)) {
            p(undefined);
        }
    }
    /**
     * Checks if the last successful background refresh happened within the specified time frame.
     * If the last refresh is older than the specified time frame, it returns a Promise that resolves
     * when the next background refresh completes or rejects if the refresh takes too long.
     */
    noOlderThan(ms) {
        const horizon = Date.now() - ms;
        // The last refresh happened within the time frame
        if (this.lastRefreshTime >= horizon) {
            return Promise.resolve();
        }
        // The last refresh happened earlier than the time frame
        // We will wait for the latest refresh to land or reject if it takes too long
        return Promise.race([
            new Promise(resolve => this.queuedPromises.push(resolve)),
            new Promise((_, reject) => setTimeout(() => reject(new error_1.ToolkitError('refreshStacks took too long; the background thread likely threw an error')), ms)),
        ]);
    }
    stop() {
        clearTimeout(this.timeout);
    }
}
exports.BackgroundStackRefresh = BackgroundStackRefresh;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2stcmVmcmVzaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInN0YWNrLXJlZnJlc2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBb0dBLHNDQVNDO0FBNUdELGlEQUEyQztBQUUzQywrQ0FBbUQ7QUFHbkQsTUFBYSxnQkFBZ0I7SUFBN0I7UUFDbUIsV0FBTSxHQUFnQixJQUFJLEdBQUcsRUFBRSxDQUFDO0lBY25ELENBQUM7SUFaUSxhQUFhLENBQUMsYUFBcUI7UUFDeEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVNLFFBQVEsQ0FBQyxLQUFhO1FBQzNCLEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ2hDLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUMxQixPQUFPLElBQUksQ0FBQztZQUNkLENBQUM7UUFDSCxDQUFDO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBQ0Y7QUFmRCw0Q0FlQztBQUVELEtBQUssVUFBVSxlQUFlLENBQUMsRUFBdUQ7SUFDcEYsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLElBQUksU0FBNkIsQ0FBQztJQUNsQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDakIsU0FBUyxHQUFHLE1BQU0sRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2hDLElBQUksU0FBUyxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQzVCLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDbEIsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILEtBQUssVUFBVSxzQkFBc0IsQ0FBQyxHQUEwQixFQUFFLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBZSxFQUFFLFNBQWtCOztJQUNuSCxNQUFNLFVBQVUsR0FBYSxFQUFFLENBQUM7SUFDaEMsTUFBTSxl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QUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzdCLENBQUM7Q0FDRjtBQXpERCx3REF5REMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXJhbWV0ZXJEZWNsYXJhdGlvbiB9IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2NsaS9tZXNzYWdlcyc7XG5pbXBvcnQgeyBJb01lc3NhZ2luZyB9IGZyb20gJy4uLy4uL3Rvb2xraXQvY2xpLWlvLWhvc3QnO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yIH0gZnJvbSAnLi4vLi4vdG9vbGtpdC9lcnJvcic7XG5pbXBvcnQgeyBJQ2xvdWRGb3JtYXRpb25DbGllbnQgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5cbmV4cG9ydCBjbGFzcyBBY3RpdmVBc3NldENhY2hlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBzdGFja3M6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuXG4gIHB1YmxpYyByZW1lbWJlclN0YWNrKHN0YWNrVGVtcGxhdGU6IHN0cmluZykge1xuICAgIHRoaXMuc3RhY2tzLmFkZChzdGFja1RlbXBsYXRlKTtcbiAgfVxuXG4gIHB1YmxpYyBjb250YWlucyhhc3NldDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgZm9yIChjb25zdCBzdGFjayBvZiB0aGlzLnN0YWNrcykge1xuICAgICAgaWYgKHN0YWNrLmluY2x1ZGVzKGFzc2V0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBhZ2luYXRlU2RrQ2FsbChjYjogKG5leHRUb2tlbj86IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+KSB7XG4gIGxldCBmaW5pc2hlZCA9IGZhbHNlO1xuICBsZXQgbmV4dFRva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHdoaWxlICghZmluaXNoZWQpIHtcbiAgICBuZXh0VG9rZW4gPSBhd2FpdCBjYihuZXh0VG9rZW4pO1xuICAgIGlmIChuZXh0VG9rZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEZldGNoZXMgYWxsIHJlbGV2YW50IHN0YWNrIHRlbXBsYXRlcyBmcm9tIENsb3VkRm9ybWF0aW9uLiBJdCBpZ25vcmVzIHRoZSBmb2xsb3dpbmcgc3RhY2tzOlxuICogLSBzdGFja3MgaW4gREVMRVRFX0NPTVBMRVRFIG9yIERFTEVURV9JTl9QUk9HUkVTUyBzdGFnZVxuICogLSBzdGFja3MgdGhhdCBhcmUgdXNpbmcgYSBkaWZmZXJlbnQgYm9vdHN0cmFwIHF1YWxpZmllclxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaEFsbFN0YWNrVGVtcGxhdGVzKGNmbjogSUNsb3VkRm9ybWF0aW9uQ2xpZW50LCB7IGlvSG9zdCwgYWN0aW9uIH06IElvTWVzc2FnaW5nLCBxdWFsaWZpZXI/OiBzdHJpbmcpIHtcbiAgY29uc3Qgc3RhY2tOYW1lczogc3RyaW5nW10gPSBbXTtcbiAgYXdhaXQgcGFnaW5hdGVTZGtDYWxsKGFzeW5jIChuZXh0VG9rZW4pID0+IHtcbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBjZm4ubGlzdFN0YWNrcyh7IE5leHRUb2tlbjogbmV4dFRva2VuIH0pO1xuXG4gICAgLy8gV2UgaWdub3JlIHN0YWNrcyB3aXRoIHRoZXNlIHN0YXR1c2VzIGJlY2F1c2UgdGhlaXIgYXNzZXRzIGFyZSBubyBsb25nZXIgbGl2ZVxuICAgIGNvbnN0IGlnbm9yZWRTdGF0dWVzID0gWydDUkVBVEVfRkFJTEVEJywgJ0RFTEVURV9DT01QTEVURScsICdERUxFVEVfSU5fUFJPR1JFU1MnLCAnREVMRVRFX0ZBSUxFRCcsICdSRVZJRVdfSU5fUFJPR1JFU1MnXTtcbiAgICBzdGFja05hbWVzLnB1c2goXG4gICAgICAuLi4oc3RhY2tzLlN0YWNrU3VtbWFyaWVzID8/IFtdKVxuICAgICAgICAuZmlsdGVyKChzOiBhbnkpID0+ICFpZ25vcmVkU3RhdHVlcy5pbmNsdWRlcyhzLlN0YWNrU3RhdHVzKSlcbiAgICAgICAgLm1hcCgoczogYW55KSA9PiBzLlN0YWNrSWQgPz8gcy5TdGFja05hbWUpLFxuICAgICk7XG5cbiAgICByZXR1cm4gc3RhY2tzLk5leHRUb2tlbjtcbiAgfSk7XG5cbiAgYXdhaXQgaW9Ib3N0Lm5vdGlmeShkZWJ1ZyhhY3Rpb24sIGBQYXJzaW5nIHRocm91Z2ggJHtzdGFja05hbWVzLmxlbmd0aH0gc3RhY2tzYCkpO1xuXG4gIGNvbnN0IHRlbXBsYXRlczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja05hbWVzKSB7XG4gICAgbGV0IHN1bW1hcnk7XG4gICAgc3VtbWFyeSA9IGF3YWl0IGNmbi5nZXRUZW1wbGF0ZVN1bW1hcnkoe1xuICAgICAgU3RhY2tOYW1lOiBzdGFjayxcbiAgICB9KTtcblxuICAgIGlmIChib290c3RyYXBGaWx0ZXIoc3VtbWFyeS5QYXJhbWV0ZXJzLCBxdWFsaWZpZXIpKSB7XG4gICAgICAvLyBUaGlzIHN0YWNrIGlzIGRlZmluaXRlbHkgYm9vdHN0cmFwcGVkIHRvIGEgZGlmZmVyZW50IHF1YWxpZmllciBzbyB3ZSBjYW4gc2FmZWx5IGlnbm9yZSBpdFxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gYXdhaXQgY2ZuLmdldFRlbXBsYXRlKHtcbiAgICAgICAgU3RhY2tOYW1lOiBzdGFjayxcbiAgICAgIH0pO1xuXG4gICAgICB0ZW1wbGF0ZXMucHVzaCgodGVtcGxhdGUuVGVtcGxhdGVCb2R5ID8/ICcnKSArIEpTT04uc3RyaW5naWZ5KHN1bW1hcnk/LlBhcmFtZXRlcnMpKTtcbiAgICB9XG4gIH1cblxuICBhd2FpdCBpb0hvc3Qubm90aWZ5KGRlYnVnKGFjdGlvbiwgJ0RvbmUgcGFyc2luZyB0aHJvdWdoIHN0YWNrcycpKTtcblxuICByZXR1cm4gdGVtcGxhdGVzO1xufVxuXG4vKipcbiAqIEZpbHRlciBvdXQgc3RhY2tzIHRoYXQgd2UgS05PVyBhcmUgdXNpbmcgYSBkaWZmZXJlbnQgYm9vdHN0cmFwIHF1YWxpZmllclxuICogVGhpcyBpcyBtb3N0bHkgbmVjZXNzYXJ5IGZvciB0aGUgaW50ZWdyYXRpb24gdGVzdHMgdGhhdCBjYW4gcnVuIHRoZSBzYW1lIGFwcCAod2l0aCB0aGUgc2FtZSBhc3NldHMpXG4gKiB1bmRlciBkaWZmZXJlbnQgcXVhbGlmaWVycy5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYSBzdGFjayB1bmRlciBhIGRpZmZlcmVudCBib290c3RyYXAgY291bGQgY29pbmNpZGVudGFsbHkgcmVmZXJlbmNlIHRoZSBzYW1lIGhhc2hcbiAqIGFuZCBjYXVzZSBhIGZhbHNlIG5lZ2F0aXZlIChjYXVzZSBhbiBhc3NldCB0byBiZSBwcmVzZXJ2ZWQgd2hlbiBpdHMgaXNvbGF0ZWQpXG4gKiBUaGlzIGlzIGludGVudGlvbmFsbHkgZG9uZSBpbiBhIHdheSB3aGVyZSB3ZSBPTkxZIGZpbHRlciBvdXQgc3RhY2tzIHRoYXQgYXJlIG1lYW50IGZvciBhIGRpZmZlcmVudCBxdWFsaWZpZXJcbiAqIGJlY2F1c2Ugd2UgYXJlIG9rYXkgd2l0aCBmYWxzZSBwb3NpdGl2ZXMuXG4gKi9cbmZ1bmN0aW9uIGJvb3RzdHJhcEZpbHRlcihwYXJhbWV0ZXJzPzogUGFyYW1ldGVyRGVjbGFyYXRpb25bXSwgcXVhbGlmaWVyPzogc3RyaW5nKSB7XG4gIGNvbnN0IGJvb3RzdHJhcFZlcnNpb24gPSBwYXJhbWV0ZXJzPy5maW5kKChwKSA9PiBwLlBhcmFtZXRlcktleSA9PT0gJ0Jvb3RzdHJhcFZlcnNpb24nKTtcbiAgY29uc3Qgc3BsaXRCb290c3RyYXBWZXJzaW9uID0gYm9vdHN0cmFwVmVyc2lvbj8uRGVmYXVsdFZhbHVlPy5zcGxpdCgnLycpO1xuICAvLyBXZSBmaW5kIHRoZSBxdWFsaWZpZXIgaW4gYSBzcGVjaWZpYyBwYXJ0IG9mIHRoZSBib290c3RyYXAgdmVyc2lvbiBwYXJhbWV0ZXJcbiAgcmV0dXJuIChxdWFsaWZpZXIgJiZcbiAgICAgICAgICBzcGxpdEJvb3RzdHJhcFZlcnNpb24gJiZcbiAgICAgICAgICBzcGxpdEJvb3RzdHJhcFZlcnNpb24ubGVuZ3RoID09IDQgJiZcbiAgICAgICAgICBzcGxpdEJvb3RzdHJhcFZlcnNpb25bMl0gIT0gcXVhbGlmaWVyKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hTdGFja3MoY2ZuOiBJQ2xvdWRGb3JtYXRpb25DbGllbnQsIHsgaW9Ib3N0LCBhY3Rpb24gfTogSW9NZXNzYWdpbmcsIGFjdGl2ZUFzc2V0czogQWN0aXZlQXNzZXRDYWNoZSwgcXVhbGlmaWVyPzogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgZmV0Y2hBbGxTdGFja1RlbXBsYXRlcyhjZm4sIHsgaW9Ib3N0LCBhY3Rpb24gfSwgcXVhbGlmaWVyKTtcbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgYWN0aXZlQXNzZXRzLnJlbWVtYmVyU3RhY2soc3RhY2spO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgRXJyb3IgcmVmcmVzaGluZyBzdGFja3M6ICR7ZXJyfWApO1xuICB9XG59XG5cbi8qKlxuICogQmFja2dyb3VuZCBTdGFjayBSZWZyZXNoIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCYWNrZ3JvdW5kU3RhY2tSZWZyZXNoUHJvcHMge1xuICAvKipcbiAgICogVGhlIENGTiBTREsgaGFuZGxlclxuICAgKi9cbiAgcmVhZG9ubHkgY2ZuOiBJQ2xvdWRGb3JtYXRpb25DbGllbnQ7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gc2VuZCBtZXNzYWdlcy5cbiAgICovXG4gIHJlYWRvbmx5IG1zZzogSW9NZXNzYWdpbmc7XG5cbiAgLyoqXG4gICAqIEFjdGl2ZSBBc3NldCBzdG9yYWdlXG4gICAqL1xuICByZWFkb25seSBhY3RpdmVBc3NldHM6IEFjdGl2ZUFzc2V0Q2FjaGU7XG5cbiAgLyoqXG4gICAqIFN0YWNrIGJvb3RzdHJhcCBxdWFsaWZpZXJcbiAgICovXG4gIHJlYWRvbmx5IHF1YWxpZmllcj86IHN0cmluZztcbn1cblxuLyoqXG4gKiBDbGFzcyB0aGF0IGNvbnRyb2xzIHNjaGVkdWxpbmcgb2YgdGhlIGJhY2tncm91bmQgc3RhY2sgcmVmcmVzaFxuICovXG5leHBvcnQgY2xhc3MgQmFja2dyb3VuZFN0YWNrUmVmcmVzaCB7XG4gIHByaXZhdGUgdGltZW91dD86IE5vZGVKUy5UaW1lb3V0O1xuICBwcml2YXRlIGxhc3RSZWZyZXNoVGltZTogbnVtYmVyO1xuICBwcml2YXRlIHF1ZXVlZFByb21pc2VzOiBBcnJheTwodmFsdWU6IHVua25vd24pID0+IHZvaWQ+ID0gW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcm9wczogQmFja2dyb3VuZFN0YWNrUmVmcmVzaFByb3BzKSB7XG4gICAgdGhpcy5sYXN0UmVmcmVzaFRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgcHVibGljIHN0YXJ0KCkge1xuICAgIC8vIFNpbmNlIHN0YXJ0IGlzIGdvaW5nIHRvIGJlIGNhbGxlZCByaWdodCBhZnRlciB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiByZWZyZXNoU3RhY2tzLFxuICAgIC8vIGxldHMgd2FpdCBzb21lIHRpbWUgYmVmb3JlIGJlZ2lubmluZyB0aGUgYmFja2dyb3VuZCByZWZyZXNoLlxuICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZWZyZXNoKCksIDMwMF8wMDApOyAvLyA1IG1pbnV0ZXNcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVmcmVzaCgpIHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgYXdhaXQgcmVmcmVzaFN0YWNrcyh0aGlzLnByb3BzLmNmbiwgdGhpcy5wcm9wcy5tc2csIHRoaXMucHJvcHMuYWN0aXZlQXNzZXRzLCB0aGlzLnByb3BzLnF1YWxpZmllcik7XG4gICAgdGhpcy5qdXN0UmVmcmVzaGVkU3RhY2tzKCk7XG5cbiAgICAvLyBJZiB0aGUgbGFzdCBpbnZvY2F0aW9uIG9mIHJlZnJlc2hTdGFja3MgdGFrZXMgPDUgbWludXRlcywgdGhlIG5leHQgaW52b2NhdGlvbiBzdGFydHMgNSBtaW51dGVzIGFmdGVyIHRoZSBsYXN0IG9uZSBzdGFydGVkLlxuICAgIC8vIElmIHRoZSBsYXN0IGludm9jYXRpb24gb2YgcmVmcmVzaFN0YWNrcyB0YWtlcyA+NSBtaW51dGVzLCB0aGUgbmV4dCBpbnZvY2F0aW9uIHN0YXJ0cyBpbW1lZGlhdGVseS5cbiAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVmcmVzaCgpLCBNYXRoLm1heChzdGFydFRpbWUgKyAzMDBfMDAwIC0gRGF0ZS5ub3coKSwgMCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBqdXN0UmVmcmVzaGVkU3RhY2tzKCkge1xuICAgIHRoaXMubGFzdFJlZnJlc2hUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5xdWV1ZWRQcm9taXNlcy5zcGxpY2UoMCwgdGhpcy5xdWV1ZWRQcm9taXNlcy5sZW5ndGgpKSB7XG4gICAgICBwKHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgbGFzdCBzdWNjZXNzZnVsIGJhY2tncm91bmQgcmVmcmVzaCBoYXBwZW5lZCB3aXRoaW4gdGhlIHNwZWNpZmllZCB0aW1lIGZyYW1lLlxuICAgKiBJZiB0aGUgbGFzdCByZWZyZXNoIGlzIG9sZGVyIHRoYW4gdGhlIHNwZWNpZmllZCB0aW1lIGZyYW1lLCBpdCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzXG4gICAqIHdoZW4gdGhlIG5leHQgYmFja2dyb3VuZCByZWZyZXNoIGNvbXBsZXRlcyBvciByZWplY3RzIGlmIHRoZSByZWZyZXNoIHRha2VzIHRvbyBsb25nLlxuICAgKi9cbiAgcHVibGljIG5vT2xkZXJUaGFuKG1zOiBudW1iZXIpIHtcbiAgICBjb25zdCBob3Jpem9uID0gRGF0ZS5ub3coKSAtIG1zO1xuXG4gICAgLy8gVGhlIGxhc3QgcmVmcmVzaCBoYXBwZW5lZCB3aXRoaW4gdGhlIHRpbWUgZnJhbWVcbiAgICBpZiAodGhpcy5sYXN0UmVmcmVzaFRpbWUgPj0gaG9yaXpvbikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIC8vIFRoZSBsYXN0IHJlZnJlc2ggaGFwcGVuZWQgZWFybGllciB0aGFuIHRoZSB0aW1lIGZyYW1lXG4gICAgLy8gV2Ugd2lsbCB3YWl0IGZvciB0aGUgbGF0ZXN0IHJlZnJlc2ggdG8gbGFuZCBvciByZWplY3QgaWYgaXQgdGFrZXMgdG9vIGxvbmdcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdGhpcy5xdWV1ZWRQcm9taXNlcy5wdXNoKHJlc29sdmUpKSxcbiAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBUb29sa2l0RXJyb3IoJ3JlZnJlc2hTdGFja3MgdG9vayB0b28gbG9uZzsgdGhlIGJhY2tncm91bmQgdGhyZWFkIGxpa2VseSB0aHJldyBhbiBlcnJvcicpKSwgbXMpKSxcbiAgICBdKTtcbiAgfVxuXG4gIHB1YmxpYyBzdG9wKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICB9XG59XG4iXX0=