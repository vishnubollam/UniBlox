"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findCloudWatchLogGroups = findCloudWatchLogGroups;
const logging_1 = require("../../logging");
const error_1 = require("../../util/error");
const environment_1 = require("../environment");
const evaluate_cloudformation_template_1 = require("../evaluate-cloudformation-template");
const mode_1 = require("../plugin/mode");
const toolkit_info_1 = require("../toolkit-info");
// resource types that have associated CloudWatch Log Groups that should _not_ be monitored
const IGNORE_LOGS_RESOURCE_TYPES = ['AWS::EC2::FlowLog', 'AWS::CloudTrail::Trail', 'AWS::CodeBuild::Project'];
async function findCloudWatchLogGroups(sdkProvider, msg, stackArtifact) {
    let sdk;
    const resolvedEnv = await sdkProvider.resolveEnvironment(stackArtifact.environment);
    // try to assume the lookup role and fallback to the default credentials
    try {
        sdk = (await new environment_1.EnvironmentAccess(sdkProvider, toolkit_info_1.DEFAULT_TOOLKIT_STACK_NAME, msg).accessStackForLookup(stackArtifact)).sdk;
    }
    catch (e) {
        (0, logging_1.debug)(`Failed to access SDK environment: ${(0, error_1.formatErrorMessage)(e)}`);
        sdk = (await sdkProvider.forEnvironment(resolvedEnv, mode_1.Mode.ForReading)).sdk;
    }
    const listStackResources = new evaluate_cloudformation_template_1.LazyListStackResources(sdk, stackArtifact.stackName);
    const evaluateCfnTemplate = new evaluate_cloudformation_template_1.EvaluateCloudFormationTemplate({
        stackName: stackArtifact.stackName,
        template: stackArtifact.template,
        parameters: {},
        account: resolvedEnv.account,
        region: resolvedEnv.region,
        partition: (await sdk.currentAccount()).partition,
        sdk,
    });
    const stackResources = await listStackResources.listStackResources();
    const logGroupNames = findAllLogGroupNames(stackResources, evaluateCfnTemplate);
    return {
        env: resolvedEnv,
        sdk,
        logGroupNames,
    };
}
/**
 * Determine if a CloudWatch Log Group is associated
 * with an ignored resource
 */
function isReferencedFromIgnoredResource(logGroupResource, evaluateCfnTemplate) {
    const resourcesReferencingLogGroup = evaluateCfnTemplate.findReferencesTo(logGroupResource.LogicalResourceId);
    return resourcesReferencingLogGroup.some((reference) => {
        return IGNORE_LOGS_RESOURCE_TYPES.includes(reference.Type);
    });
}
const cloudWatchLogsResolvers = {
    'AWS::Logs::LogGroup': (resource, evaluateCfnTemplate) => {
        var _a;
        if (isReferencedFromIgnoredResource(resource, evaluateCfnTemplate)) {
            return undefined;
        }
        return (_a = resource.PhysicalResourceId) === null || _a === void 0 ? void 0 : _a.toString();
    },
    // Resource types that will create a CloudWatch log group with a specific name if one is not provided.
    // The keys are CFN resource types, and the values are the name of the physical name property of that resource
    // and the service name that is used in the automatically created CloudWatch log group.
    'AWS::Lambda::Function': (resource, evaluateCfnTemplate) => {
        const loggingConfig = evaluateCfnTemplate.getResourceProperty(resource.LogicalResourceId, 'LoggingConfig');
        if (loggingConfig === null || loggingConfig === void 0 ? void 0 : loggingConfig.LogGroup) {
            // if LogGroup is a string then use it as the LogGroupName as it is referred by LogGroup.fromLogGroupArn in CDK
            if (typeof loggingConfig.LogGroup === 'string') {
                return loggingConfig.LogGroup;
            }
            // if { Ref: '...' } is used then try to resolve the LogGroupName from the referenced resource in the template
            if (typeof loggingConfig.LogGroup === 'object') {
                if (loggingConfig.LogGroup.Ref) {
                    return evaluateCfnTemplate.getResourceProperty(loggingConfig.LogGroup.Ref, 'LogGroupName');
                }
            }
        }
        return `/aws/lambda/${resource.PhysicalResourceId}`;
    },
};
/**
 * Find all CloudWatch Log Groups in the deployed template.
 * This will find both explicitly created Log Groups (excluding those associated with ignored resources)
 * and Log Groups created implicitly (i.e. Lambda Functions)
 */
function findAllLogGroupNames(stackResources, evaluateCfnTemplate) {
    const logGroupNames = [];
    for (const resource of stackResources) {
        const logGroupResolver = cloudWatchLogsResolvers[resource.ResourceType];
        if (logGroupResolver) {
            const logGroupName = logGroupResolver(resource, evaluateCfnTemplate);
            if (logGroupName) {
                logGroupNames.push(logGroupName);
            }
        }
    }
    return logGroupNames;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmluZC1jbG91ZHdhdGNoLWxvZ3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmaW5kLWNsb3Vkd2F0Y2gtbG9ncy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQXNDQSwwREFrQ0M7QUF0RUQsMkNBQXNDO0FBRXRDLDRDQUFzRDtBQUV0RCxnREFBbUQ7QUFDbkQsMEZBQTZHO0FBQzdHLHlDQUFzQztBQUN0QyxrREFBNkQ7QUFFN0QsMkZBQTJGO0FBQzNGLE1BQU0sMEJBQTBCLEdBQUcsQ0FBQyxtQkFBbUIsRUFBRSx3QkFBd0IsRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO0FBMEJ2RyxLQUFLLFVBQVUsdUJBQXVCLENBQzNDLFdBQXdCLEVBQ3hCLEdBQWdCLEVBQ2hCLGFBQTBDO0lBRTFDLElBQUksR0FBUSxDQUFDO0lBQ2IsTUFBTSxXQUFXLEdBQUcsTUFBTSxXQUFXLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3BGLHdFQUF3RTtJQUN4RSxJQUFJLENBQUM7UUFDSCxHQUFHLEdBQUcsQ0FBQyxNQUFNLElBQUksK0JBQWlCLENBQUMsV0FBVyxFQUFFLHlDQUEwQixFQUFFLEdBQUcsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBQzVILENBQUM7SUFBQyxPQUFPLENBQU0sRUFBRSxDQUFDO1FBQ2hCLElBQUEsZUFBSyxFQUFDLHFDQUFxQyxJQUFBLDBCQUFrQixFQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNwRSxHQUFHLEdBQUcsQ0FBQyxNQUFNLFdBQVcsQ0FBQyxjQUFjLENBQUMsV0FBVyxFQUFFLFdBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztJQUM3RSxDQUFDO0lBRUQsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLHlEQUFzQixDQUFDLEdBQUcsRUFBRSxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEYsTUFBTSxt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QkFBZ0IsQ0FBQyxRQUFRLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztZQUNyRSxJQUFJLFlBQVksRUFBRSxDQUFDO2dCQUNqQixhQUFhLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ25DLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztJQUVELE9BQU8sYUFBYSxDQUFDO0FBQ3ZCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCwgRW52aXJvbm1lbnQgfSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHR5cGUgeyBTdGFja1Jlc291cmNlU3VtbWFyeSB9IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgSW9NZXNzYWdpbmcgfSBmcm9tICcuLi8uLi90b29sa2l0L2NsaS1pby1ob3N0JztcbmltcG9ydCB7IGZvcm1hdEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uL3V0aWwvZXJyb3InO1xuaW1wb3J0IHR5cGUgeyBTREssIFNka1Byb3ZpZGVyIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgRW52aXJvbm1lbnRBY2Nlc3MgfSBmcm9tICcuLi9lbnZpcm9ubWVudCc7XG5pbXBvcnQgeyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsIExhenlMaXN0U3RhY2tSZXNvdXJjZXMgfSBmcm9tICcuLi9ldmFsdWF0ZS1jbG91ZGZvcm1hdGlvbi10ZW1wbGF0ZSc7XG5pbXBvcnQgeyBNb2RlIH0gZnJvbSAnLi4vcGx1Z2luL21vZGUnO1xuaW1wb3J0IHsgREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUUgfSBmcm9tICcuLi90b29sa2l0LWluZm8nO1xuXG4vLyByZXNvdXJjZSB0eXBlcyB0aGF0IGhhdmUgYXNzb2NpYXRlZCBDbG91ZFdhdGNoIExvZyBHcm91cHMgdGhhdCBzaG91bGQgX25vdF8gYmUgbW9uaXRvcmVkXG5jb25zdCBJR05PUkVfTE9HU19SRVNPVVJDRV9UWVBFUyA9IFsnQVdTOjpFQzI6OkZsb3dMb2cnLCAnQVdTOjpDbG91ZFRyYWlsOjpUcmFpbCcsICdBV1M6OkNvZGVCdWlsZDo6UHJvamVjdCddO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gbmVlZGVkIHRvIG1vbml0b3IgQ2xvdWRXYXRjaCBMb2cgR3JvdXBzXG4gKiBmb3VuZCBpbiBhIGdpdmVuIENsb3VkRm9ybWF0aW9uIFN0YWNrXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRm91bmRMb2dHcm91cHNSZXN1bHQge1xuICAvKipcbiAgICogVGhlIHJlc29sdmVkIGVudmlyb25tZW50IChhY2NvdW50L3JlZ2lvbikgdGhhdCB0aGUgbG9nXG4gICAqIGdyb3VwcyBhcmUgZGVwbG95ZWQgaW5cbiAgICovXG4gIHJlYWRvbmx5IGVudjogRW52aXJvbm1lbnQ7XG5cbiAgLyoqXG4gICAqIFRoZSBTREsgdGhhdCBjYW4gYmUgdXNlZCB0byByZWFkIGV2ZW50cyBmcm9tIHRoZSBDbG91ZFdhdGNoXG4gICAqIExvZyBHcm91cHMgaW4gdGhlIGdpdmVuIGVudmlyb25tZW50XG4gICAqL1xuICByZWFkb25seSBzZGs6IFNESztcblxuICAvKipcbiAgICogVGhlIG5hbWVzIG9mIHRoZSByZWxldmFudCBDbG91ZFdhdGNoIExvZyBHcm91cHNcbiAgICogaW4gdGhlIGdpdmVuIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlXG4gICAqL1xuICByZWFkb25seSBsb2dHcm91cE5hbWVzOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpbmRDbG91ZFdhdGNoTG9nR3JvdXBzKFxuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsXG4gIG1zZzogSW9NZXNzYWdpbmcsXG4gIHN0YWNrQXJ0aWZhY3Q6IENsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCxcbik6IFByb21pc2U8Rm91bmRMb2dHcm91cHNSZXN1bHQ+IHtcbiAgbGV0IHNkazogU0RLO1xuICBjb25zdCByZXNvbHZlZEVudiA9IGF3YWl0IHNka1Byb3ZpZGVyLnJlc29sdmVFbnZpcm9ubWVudChzdGFja0FydGlmYWN0LmVudmlyb25tZW50KTtcbiAgLy8gdHJ5IHRvIGFzc3VtZSB0aGUgbG9va3VwIHJvbGUgYW5kIGZhbGxiYWNrIHRvIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzXG4gIHRyeSB7XG4gICAgc2RrID0gKGF3YWl0IG5ldyBFbnZpcm9ubWVudEFjY2VzcyhzZGtQcm92aWRlciwgREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUUsIG1zZykuYWNjZXNzU3RhY2tGb3JMb29rdXAoc3RhY2tBcnRpZmFjdCkpLnNkaztcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgZGVidWcoYEZhaWxlZCB0byBhY2Nlc3MgU0RLIGVudmlyb25tZW50OiAke2Zvcm1hdEVycm9yTWVzc2FnZShlKX1gKTtcbiAgICBzZGsgPSAoYXdhaXQgc2RrUHJvdmlkZXIuZm9yRW52aXJvbm1lbnQocmVzb2x2ZWRFbnYsIE1vZGUuRm9yUmVhZGluZykpLnNkaztcbiAgfVxuXG4gIGNvbnN0IGxpc3RTdGFja1Jlc291cmNlcyA9IG5ldyBMYXp5TGlzdFN0YWNrUmVzb3VyY2VzKHNkaywgc3RhY2tBcnRpZmFjdC5zdGFja05hbWUpO1xuICBjb25zdCBldmFsdWF0ZUNmblRlbXBsYXRlID0gbmV3IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSh7XG4gICAgc3RhY2tOYW1lOiBzdGFja0FydGlmYWN0LnN0YWNrTmFtZSxcbiAgICB0ZW1wbGF0ZTogc3RhY2tBcnRpZmFjdC50ZW1wbGF0ZSxcbiAgICBwYXJhbWV0ZXJzOiB7fSxcbiAgICBhY2NvdW50OiByZXNvbHZlZEVudi5hY2NvdW50LFxuICAgIHJlZ2lvbjogcmVzb2x2ZWRFbnYucmVnaW9uLFxuICAgIHBhcnRpdGlvbjogKGF3YWl0IHNkay5jdXJyZW50QWNjb3VudCgpKS5wYXJ0aXRpb24sXG4gICAgc2RrLFxuICB9KTtcblxuICBjb25zdCBzdGFja1Jlc291cmNlcyA9IGF3YWl0IGxpc3RTdGFja1Jlc291cmNlcy5saXN0U3RhY2tSZXNvdXJjZXMoKTtcbiAgY29uc3QgbG9nR3JvdXBOYW1lcyA9IGZpbmRBbGxMb2dHcm91cE5hbWVzKHN0YWNrUmVzb3VyY2VzLCBldmFsdWF0ZUNmblRlbXBsYXRlKTtcblxuICByZXR1cm4ge1xuICAgIGVudjogcmVzb2x2ZWRFbnYsXG4gICAgc2RrLFxuICAgIGxvZ0dyb3VwTmFtZXMsXG4gIH07XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgQ2xvdWRXYXRjaCBMb2cgR3JvdXAgaXMgYXNzb2NpYXRlZFxuICogd2l0aCBhbiBpZ25vcmVkIHJlc291cmNlXG4gKi9cbmZ1bmN0aW9uIGlzUmVmZXJlbmNlZEZyb21JZ25vcmVkUmVzb3VyY2UoXG4gIGxvZ0dyb3VwUmVzb3VyY2U6IFN0YWNrUmVzb3VyY2VTdW1tYXJ5LFxuICBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4pOiBib29sZWFuIHtcbiAgY29uc3QgcmVzb3VyY2VzUmVmZXJlbmNpbmdMb2dHcm91cCA9IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZFJlZmVyZW5jZXNUbyhsb2dHcm91cFJlc291cmNlLkxvZ2ljYWxSZXNvdXJjZUlkISk7XG4gIHJldHVybiByZXNvdXJjZXNSZWZlcmVuY2luZ0xvZ0dyb3VwLnNvbWUoKHJlZmVyZW5jZSkgPT4ge1xuICAgIHJldHVybiBJR05PUkVfTE9HU19SRVNPVVJDRV9UWVBFUy5pbmNsdWRlcyhyZWZlcmVuY2UuVHlwZSk7XG4gIH0pO1xufVxuXG50eXBlIENsb3VkV2F0Y2hMb2dzUmVzb2x2ZXIgPSAoXG4gIHJlc291cmNlOiBTdGFja1Jlc291cmNlU3VtbWFyeSxcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuKSA9PiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbmNvbnN0IGNsb3VkV2F0Y2hMb2dzUmVzb2x2ZXJzOiBSZWNvcmQ8c3RyaW5nLCBDbG91ZFdhdGNoTG9nc1Jlc29sdmVyPiA9IHtcbiAgJ0FXUzo6TG9nczo6TG9nR3JvdXAnOiAocmVzb3VyY2UsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpID0+IHtcbiAgICBpZiAoaXNSZWZlcmVuY2VkRnJvbUlnbm9yZWRSZXNvdXJjZShyZXNvdXJjZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZSkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiByZXNvdXJjZS5QaHlzaWNhbFJlc291cmNlSWQ/LnRvU3RyaW5nKCk7XG4gIH0sXG5cbiAgLy8gUmVzb3VyY2UgdHlwZXMgdGhhdCB3aWxsIGNyZWF0ZSBhIENsb3VkV2F0Y2ggbG9nIGdyb3VwIHdpdGggYSBzcGVjaWZpYyBuYW1lIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gIC8vIFRoZSBrZXlzIGFyZSBDRk4gcmVzb3VyY2UgdHlwZXMsIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGUgbmFtZSBvZiB0aGUgcGh5c2ljYWwgbmFtZSBwcm9wZXJ0eSBvZiB0aGF0IHJlc291cmNlXG4gIC8vIGFuZCB0aGUgc2VydmljZSBuYW1lIHRoYXQgaXMgdXNlZCBpbiB0aGUgYXV0b21hdGljYWxseSBjcmVhdGVkIENsb3VkV2F0Y2ggbG9nIGdyb3VwLlxuICAnQVdTOjpMYW1iZGE6OkZ1bmN0aW9uJzogKHJlc291cmNlLCBldmFsdWF0ZUNmblRlbXBsYXRlKSA9PiB7XG4gICAgY29uc3QgbG9nZ2luZ0NvbmZpZyA9IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZ2V0UmVzb3VyY2VQcm9wZXJ0eShyZXNvdXJjZS5Mb2dpY2FsUmVzb3VyY2VJZCEsICdMb2dnaW5nQ29uZmlnJyk7XG4gICAgaWYgKGxvZ2dpbmdDb25maWc/LkxvZ0dyb3VwKSB7XG4gICAgICAvLyBpZiBMb2dHcm91cCBpcyBhIHN0cmluZyB0aGVuIHVzZSBpdCBhcyB0aGUgTG9nR3JvdXBOYW1lIGFzIGl0IGlzIHJlZmVycmVkIGJ5IExvZ0dyb3VwLmZyb21Mb2dHcm91cEFybiBpbiBDREtcbiAgICAgIGlmICh0eXBlb2YgbG9nZ2luZ0NvbmZpZy5Mb2dHcm91cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dpbmdDb25maWcuTG9nR3JvdXA7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHsgUmVmOiAnLi4uJyB9IGlzIHVzZWQgdGhlbiB0cnkgdG8gcmVzb2x2ZSB0aGUgTG9nR3JvdXBOYW1lIGZyb20gdGhlIHJlZmVyZW5jZWQgcmVzb3VyY2UgaW4gdGhlIHRlbXBsYXRlXG4gICAgICBpZiAodHlwZW9mIGxvZ2dpbmdDb25maWcuTG9nR3JvdXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChsb2dnaW5nQ29uZmlnLkxvZ0dyb3VwLlJlZikge1xuICAgICAgICAgIHJldHVybiBldmFsdWF0ZUNmblRlbXBsYXRlLmdldFJlc291cmNlUHJvcGVydHkobG9nZ2luZ0NvbmZpZy5Mb2dHcm91cC5SZWYsICdMb2dHcm91cE5hbWUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBgL2F3cy9sYW1iZGEvJHtyZXNvdXJjZS5QaHlzaWNhbFJlc291cmNlSWR9YDtcbiAgfSxcbn07XG5cbi8qKlxuICogRmluZCBhbGwgQ2xvdWRXYXRjaCBMb2cgR3JvdXBzIGluIHRoZSBkZXBsb3llZCB0ZW1wbGF0ZS5cbiAqIFRoaXMgd2lsbCBmaW5kIGJvdGggZXhwbGljaXRseSBjcmVhdGVkIExvZyBHcm91cHMgKGV4Y2x1ZGluZyB0aG9zZSBhc3NvY2lhdGVkIHdpdGggaWdub3JlZCByZXNvdXJjZXMpXG4gKiBhbmQgTG9nIEdyb3VwcyBjcmVhdGVkIGltcGxpY2l0bHkgKGkuZS4gTGFtYmRhIEZ1bmN0aW9ucylcbiAqL1xuZnVuY3Rpb24gZmluZEFsbExvZ0dyb3VwTmFtZXMoXG4gIHN0YWNrUmVzb3VyY2VzOiBTdGFja1Jlc291cmNlU3VtbWFyeVtdLFxuICBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IGxvZ0dyb3VwTmFtZXM6IHN0cmluZ1tdID0gW107XG5cbiAgZm9yIChjb25zdCByZXNvdXJjZSBvZiBzdGFja1Jlc291cmNlcykge1xuICAgIGNvbnN0IGxvZ0dyb3VwUmVzb2x2ZXIgPSBjbG91ZFdhdGNoTG9nc1Jlc29sdmVyc1tyZXNvdXJjZS5SZXNvdXJjZVR5cGUhXTtcbiAgICBpZiAobG9nR3JvdXBSZXNvbHZlcikge1xuICAgICAgY29uc3QgbG9nR3JvdXBOYW1lID0gbG9nR3JvdXBSZXNvbHZlcihyZXNvdXJjZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZSk7XG4gICAgICBpZiAobG9nR3JvdXBOYW1lKSB7XG4gICAgICAgIGxvZ0dyb3VwTmFtZXMucHVzaChsb2dHcm91cE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2dHcm91cE5hbWVzO1xufVxuIl19