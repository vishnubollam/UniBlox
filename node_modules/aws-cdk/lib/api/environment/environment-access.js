"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnvironmentAccess = void 0;
const environment_resources_1 = require("./environment-resources");
const messages_1 = require("../../cli/messages");
const error_1 = require("../../toolkit/error");
const error_2 = require("../../util/error");
const mode_1 = require("../plugin/mode");
const placeholders_1 = require("../util/placeholders");
/**
 * Access particular AWS resources, based on information from the CX manifest
 *
 * It is not possible to grab direct access to AWS credentials; 9 times out of 10
 * we have to allow for role assumption, and role assumption can only work if
 * there is a CX Manifest that contains a role ARN.
 *
 * This class exists so new code isn't tempted to go and get SDK credentials directly.
 */
class EnvironmentAccess {
    constructor(sdkProvider, toolkitStackName, { ioHost, action }) {
        this.sdkProvider = sdkProvider;
        this.sdkCache = new Map();
        this.environmentResources = new environment_resources_1.EnvironmentResourcesRegistry(toolkitStackName);
        this.ioHost = ioHost;
        this.action = action;
    }
    /**
     * Resolves the environment for a stack.
     */
    async resolveStackEnvironment(stack) {
        return this.sdkProvider.resolveEnvironment(stack.environment);
    }
    /**
     * Get an SDK to access the given stack's environment for stack operations
     *
     * Will ask plugins for readonly credentials if available, use the default
     * AWS credentials if not.
     *
     * Will assume the deploy role if configured on the stack. Check the default `deploy-role`
     * policies to see what you can do with this role.
     */
    async accessStackForReadOnlyStackOperations(stack) {
        return this.accessStackForStackOperations(stack, mode_1.Mode.ForReading);
    }
    /**
     * Get an SDK to access the given stack's environment for stack operations
     *
     * Will ask plugins for mutating credentials if available, use the default AWS
     * credentials if not.  The `mode` parameter is only used for querying
     * plugins.
     *
     * Will assume the deploy role if configured on the stack. Check the default `deploy-role`
     * policies to see what you can do with this role.
     */
    async accessStackForMutableStackOperations(stack) {
        return this.accessStackForStackOperations(stack, mode_1.Mode.ForWriting);
    }
    /**
     * Get an SDK to access the given stack's environment for environmental lookups
     *
     * Will use a plugin if available, use the default AWS credentials if not.
     * The `mode` parameter is only used for querying plugins.
     *
     * Will assume the lookup role if configured on the stack. Check the default `lookup-role`
     * policies to see what you can do with this role. It can generally read everything
     * in the account that does not require KMS access.
     *
     * ---
     *
     * For backwards compatibility reasons, there are some scenarios that are handled here:
     *
     *  1. The lookup role may not exist (it was added in bootstrap stack version 7). If so:
     *     a. Return the default credentials if the default credentials are for the stack account
     *        (you will notice this as `isFallbackCredentials=true`).
     *     b. Throw an error if the default credentials are not for the stack account.
     *
     *  2. The lookup role may not have the correct permissions (for example, ReadOnlyAccess was added in
     *     bootstrap stack version 8); the stack will have a minimum version number on it.
     *     a. If it does not we throw an error which should be handled in the calling
     *        function (and fallback to use a different role, etc)
     *
     * Upon success, caller will have an SDK for the right account, which may or may not have
     * the right permissions.
     */
    async accessStackForLookup(stack) {
        var _a, _b, _c, _d, _e;
        if (!stack.environment) {
            throw new error_1.ToolkitError(`The stack ${stack.displayName} does not have an environment`);
        }
        const lookupEnv = await this.prepareSdk({
            environment: stack.environment,
            mode: mode_1.Mode.ForReading,
            assumeRoleArn: (_a = stack.lookupRole) === null || _a === void 0 ? void 0 : _a.arn,
            assumeRoleExternalId: (_b = stack.lookupRole) === null || _b === void 0 ? void 0 : _b.assumeRoleExternalId,
            assumeRoleAdditionalOptions: (_c = stack.lookupRole) === null || _c === void 0 ? void 0 : _c.assumeRoleAdditionalOptions,
        });
        // if we succeed in assuming the lookup role, make sure we have the correct bootstrap stack version
        if (lookupEnv.didAssumeRole && ((_d = stack.lookupRole) === null || _d === void 0 ? void 0 : _d.bootstrapStackVersionSsmParameter) && stack.lookupRole.requiresBootstrapStackVersion) {
            const version = await lookupEnv.resources.versionFromSsmParameter(stack.lookupRole.bootstrapStackVersionSsmParameter);
            if (version < stack.lookupRole.requiresBootstrapStackVersion) {
                throw new error_1.ToolkitError(`Bootstrap stack version '${stack.lookupRole.requiresBootstrapStackVersion}' is required, found version '${version}'. To get rid of this error, please upgrade to bootstrap version >= ${stack.lookupRole.requiresBootstrapStackVersion}`);
            }
        }
        if (lookupEnv.isFallbackCredentials) {
            const arn = await lookupEnv.replacePlaceholders((_e = stack.lookupRole) === null || _e === void 0 ? void 0 : _e.arn);
            await this.ioHost.notify((0, messages_1.warn)(this.action, `Lookup role ${arn} was not assumed. Proceeding with default credentials.`));
        }
        return lookupEnv;
    }
    /**
     * Get an SDK to access the given stack's environment for reading stack attributes
     *
     * Will use a plugin if available, use the default AWS credentials if not.
     * The `mode` parameter is only used for querying plugins.
     *
     * Will try to assume the lookup role if given, will use the regular stack operations
     * access (deploy-role) otherwise. When calling this, you should assume that you will get
     * the least privileged role, so don't try to use it for anything the `deploy-role`
     * wouldn't be able to do. Also you cannot rely on being able to read encrypted anything.
     */
    async accessStackForLookupBestEffort(stack) {
        if (!stack.environment) {
            throw new error_1.ToolkitError(`The stack ${stack.displayName} does not have an environment`);
        }
        try {
            return await this.accessStackForLookup(stack);
        }
        catch (e) {
            await this.ioHost.notify((0, messages_1.warn)(this.action, `${(0, error_2.formatErrorMessage)(e)}`));
        }
        return this.accessStackForStackOperations(stack, mode_1.Mode.ForReading);
    }
    /**
     * Get an SDK to access the given stack's environment for stack operations
     *
     * Will use a plugin if available, use the default AWS credentials if not.
     * The `mode` parameter is only used for querying plugins.
     *
     * Will assume the deploy role if configured on the stack. Check the default `deploy-role`
     * policies to see what you can do with this role.
     */
    async accessStackForStackOperations(stack, mode) {
        if (!stack.environment) {
            throw new error_1.ToolkitError(`The stack ${stack.displayName} does not have an environment`);
        }
        return this.prepareSdk({
            environment: stack.environment,
            mode,
            assumeRoleArn: stack.assumeRoleArn,
            assumeRoleExternalId: stack.assumeRoleExternalId,
            assumeRoleAdditionalOptions: stack.assumeRoleAdditionalOptions,
        });
    }
    /**
     * Prepare an SDK for use in the given environment and optionally with a role assumed.
     */
    async prepareSdk(options) {
        const resolvedEnvironment = await this.sdkProvider.resolveEnvironment(options.environment);
        // Substitute any placeholders with information about the current environment
        const { assumeRoleArn } = await (0, placeholders_1.replaceEnvPlaceholders)({
            assumeRoleArn: options.assumeRoleArn,
        }, resolvedEnvironment, this.sdkProvider);
        const stackSdk = await this.cachedSdkForEnvironment(resolvedEnvironment, options.mode, {
            assumeRoleArn,
            assumeRoleExternalId: options.assumeRoleExternalId,
            assumeRoleAdditionalOptions: options.assumeRoleAdditionalOptions,
        });
        return {
            sdk: stackSdk.sdk,
            resolvedEnvironment,
            resources: this.environmentResources.for(resolvedEnvironment, stackSdk.sdk, { ioHost: this.ioHost, action: this.action }),
            // If we asked for a role, did not successfully assume it, and yet got here without an exception: that
            // means we must have fallback credentials.
            isFallbackCredentials: !stackSdk.didAssumeRole && !!assumeRoleArn,
            didAssumeRole: stackSdk.didAssumeRole,
            replacePlaceholders: async (str) => {
                const ret = await (0, placeholders_1.replaceEnvPlaceholders)({ str }, resolvedEnvironment, this.sdkProvider);
                return ret.str;
            },
        };
    }
    async cachedSdkForEnvironment(environment, mode, options) {
        var _a, _b;
        const cacheKeyElements = [
            environment.account,
            environment.region,
            `${mode}`,
            (_a = options === null || options === void 0 ? void 0 : options.assumeRoleArn) !== null && _a !== void 0 ? _a : '',
            (_b = options === null || options === void 0 ? void 0 : options.assumeRoleExternalId) !== null && _b !== void 0 ? _b : '',
        ];
        if (options === null || options === void 0 ? void 0 : options.assumeRoleAdditionalOptions) {
            cacheKeyElements.push(JSON.stringify(options.assumeRoleAdditionalOptions));
        }
        const cacheKey = cacheKeyElements.join(':');
        const existing = this.sdkCache.get(cacheKey);
        if (existing) {
            return existing;
        }
        const ret = await this.sdkProvider.forEnvironment(environment, mode, options);
        this.sdkCache.set(cacheKey, ret);
        return ret;
    }
}
exports.EnvironmentAccess = EnvironmentAccess;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW52aXJvbm1lbnQtYWNjZXNzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZW52aXJvbm1lbnQtYWNjZXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUVBLG1FQUE2RjtBQUM3RixpREFBMEM7QUFFMUMsK0NBQW1EO0FBQ25ELDRDQUFzRDtBQUV0RCx5Q0FBc0M7QUFDdEMsdURBQXlGO0FBRXpGOzs7Ozs7OztHQVFHO0FBQ0gsTUFBYSxpQkFBaUI7SUFNNUIsWUFBNkIsV0FBd0IsRUFBRSxnQkFBd0IsRUFBRSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQWU7UUFBbkYsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFMcEMsYUFBUSxHQUFHLElBQUksR0FBRyxFQUE2QixDQUFDO1FBTS9ELElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLG9EQUE0QixDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDL0UsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7SUFDdkIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksS0FBSyxDQUFDLHVCQUF1QixDQUFDLEtBQXdDO1FBQzNFLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksS0FBSyxDQUFDLHFDQUFxQyxDQUFDLEtBQXdDO1FBQ3pGLE9BQU8sSUFBSSxDQUFDLDZCQUE2QixDQUFDLEtBQUssRUFBRSxXQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDcEUsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxLQUF3QztRQUN4RixPQUFPLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxLQUFLLEVBQUUsV0FBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7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LElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDOUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ2pDLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztDQUNGO0FBL01ELDhDQStNQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBFbnZpcm9ubWVudFJlc291cmNlcywgRW52aXJvbm1lbnRSZXNvdXJjZXNSZWdpc3RyeSB9IGZyb20gJy4vZW52aXJvbm1lbnQtcmVzb3VyY2VzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi9jbGkvbWVzc2FnZXMnO1xuaW1wb3J0IHsgSW9NZXNzYWdpbmcgfSBmcm9tICcuLi8uLi90b29sa2l0L2NsaS1pby1ob3N0JztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uL3Rvb2xraXQvZXJyb3InO1xuaW1wb3J0IHsgZm9ybWF0RXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vdXRpbC9lcnJvcic7XG5pbXBvcnQgeyBDcmVkZW50aWFsc09wdGlvbnMsIFNka0ZvckVudmlyb25tZW50LCBTZGtQcm92aWRlciB9IGZyb20gJy4uL2F3cy1hdXRoL3Nkay1wcm92aWRlcic7XG5pbXBvcnQgeyBNb2RlIH0gZnJvbSAnLi4vcGx1Z2luL21vZGUnO1xuaW1wb3J0IHsgcmVwbGFjZUVudlBsYWNlaG9sZGVycywgU3RyaW5nV2l0aG91dFBsYWNlaG9sZGVycyB9IGZyb20gJy4uL3V0aWwvcGxhY2Vob2xkZXJzJztcblxuLyoqXG4gKiBBY2Nlc3MgcGFydGljdWxhciBBV1MgcmVzb3VyY2VzLCBiYXNlZCBvbiBpbmZvcm1hdGlvbiBmcm9tIHRoZSBDWCBtYW5pZmVzdFxuICpcbiAqIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBncmFiIGRpcmVjdCBhY2Nlc3MgdG8gQVdTIGNyZWRlbnRpYWxzOyA5IHRpbWVzIG91dCBvZiAxMFxuICogd2UgaGF2ZSB0byBhbGxvdyBmb3Igcm9sZSBhc3N1bXB0aW9uLCBhbmQgcm9sZSBhc3N1bXB0aW9uIGNhbiBvbmx5IHdvcmsgaWZcbiAqIHRoZXJlIGlzIGEgQ1ggTWFuaWZlc3QgdGhhdCBjb250YWlucyBhIHJvbGUgQVJOLlxuICpcbiAqIFRoaXMgY2xhc3MgZXhpc3RzIHNvIG5ldyBjb2RlIGlzbid0IHRlbXB0ZWQgdG8gZ28gYW5kIGdldCBTREsgY3JlZGVudGlhbHMgZGlyZWN0bHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbnZpcm9ubWVudEFjY2VzcyB7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2RrQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgU2RrRm9yRW52aXJvbm1lbnQ+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgZW52aXJvbm1lbnRSZXNvdXJjZXM6IEVudmlyb25tZW50UmVzb3VyY2VzUmVnaXN0cnk7XG4gIHByaXZhdGUgcmVhZG9ubHkgaW9Ib3N0OiBJb01lc3NhZ2luZ1snaW9Ib3N0J107XG4gIHByaXZhdGUgcmVhZG9ubHkgYWN0aW9uOiBJb01lc3NhZ2luZ1snYWN0aW9uJ107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsIHRvb2xraXRTdGFja05hbWU6IHN0cmluZywgeyBpb0hvc3QsIGFjdGlvbiB9OiBJb01lc3NhZ2luZykge1xuICAgIHRoaXMuZW52aXJvbm1lbnRSZXNvdXJjZXMgPSBuZXcgRW52aXJvbm1lbnRSZXNvdXJjZXNSZWdpc3RyeSh0b29sa2l0U3RhY2tOYW1lKTtcbiAgICB0aGlzLmlvSG9zdCA9IGlvSG9zdDtcbiAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgZW52aXJvbm1lbnQgZm9yIGEgc3RhY2suXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcmVzb2x2ZVN0YWNrRW52aXJvbm1lbnQoc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCk6IFByb21pc2U8Y3hhcGkuRW52aXJvbm1lbnQ+IHtcbiAgICByZXR1cm4gdGhpcy5zZGtQcm92aWRlci5yZXNvbHZlRW52aXJvbm1lbnQoc3RhY2suZW52aXJvbm1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBTREsgdG8gYWNjZXNzIHRoZSBnaXZlbiBzdGFjaydzIGVudmlyb25tZW50IGZvciBzdGFjayBvcGVyYXRpb25zXG4gICAqXG4gICAqIFdpbGwgYXNrIHBsdWdpbnMgZm9yIHJlYWRvbmx5IGNyZWRlbnRpYWxzIGlmIGF2YWlsYWJsZSwgdXNlIHRoZSBkZWZhdWx0XG4gICAqIEFXUyBjcmVkZW50aWFscyBpZiBub3QuXG4gICAqXG4gICAqIFdpbGwgYXNzdW1lIHRoZSBkZXBsb3kgcm9sZSBpZiBjb25maWd1cmVkIG9uIHRoZSBzdGFjay4gQ2hlY2sgdGhlIGRlZmF1bHQgYGRlcGxveS1yb2xlYFxuICAgKiBwb2xpY2llcyB0byBzZWUgd2hhdCB5b3UgY2FuIGRvIHdpdGggdGhpcyByb2xlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGFjY2Vzc1N0YWNrRm9yUmVhZE9ubHlTdGFja09wZXJhdGlvbnMoc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCk6IFByb21pc2U8VGFyZ2V0RW52aXJvbm1lbnQ+IHtcbiAgICByZXR1cm4gdGhpcy5hY2Nlc3NTdGFja0ZvclN0YWNrT3BlcmF0aW9ucyhzdGFjaywgTW9kZS5Gb3JSZWFkaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gU0RLIHRvIGFjY2VzcyB0aGUgZ2l2ZW4gc3RhY2sncyBlbnZpcm9ubWVudCBmb3Igc3RhY2sgb3BlcmF0aW9uc1xuICAgKlxuICAgKiBXaWxsIGFzayBwbHVnaW5zIGZvciBtdXRhdGluZyBjcmVkZW50aWFscyBpZiBhdmFpbGFibGUsIHVzZSB0aGUgZGVmYXVsdCBBV1NcbiAgICogY3JlZGVudGlhbHMgaWYgbm90LiAgVGhlIGBtb2RlYCBwYXJhbWV0ZXIgaXMgb25seSB1c2VkIGZvciBxdWVyeWluZ1xuICAgKiBwbHVnaW5zLlxuICAgKlxuICAgKiBXaWxsIGFzc3VtZSB0aGUgZGVwbG95IHJvbGUgaWYgY29uZmlndXJlZCBvbiB0aGUgc3RhY2suIENoZWNrIHRoZSBkZWZhdWx0IGBkZXBsb3ktcm9sZWBcbiAgICogcG9saWNpZXMgdG8gc2VlIHdoYXQgeW91IGNhbiBkbyB3aXRoIHRoaXMgcm9sZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBhY2Nlc3NTdGFja0Zvck11dGFibGVTdGFja09wZXJhdGlvbnMoc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCk6IFByb21pc2U8VGFyZ2V0RW52aXJvbm1lbnQ+IHtcbiAgICByZXR1cm4gdGhpcy5hY2Nlc3NTdGFja0ZvclN0YWNrT3BlcmF0aW9ucyhzdGFjaywgTW9kZS5Gb3JXcml0aW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gU0RLIHRvIGFjY2VzcyB0aGUgZ2l2ZW4gc3RhY2sncyBlbnZpcm9ubWVudCBmb3IgZW52aXJvbm1lbnRhbCBsb29rdXBzXG4gICAqXG4gICAqIFdpbGwgdXNlIGEgcGx1Z2luIGlmIGF2YWlsYWJsZSwgdXNlIHRoZSBkZWZhdWx0IEFXUyBjcmVkZW50aWFscyBpZiBub3QuXG4gICAqIFRoZSBgbW9kZWAgcGFyYW1ldGVyIGlzIG9ubHkgdXNlZCBmb3IgcXVlcnlpbmcgcGx1Z2lucy5cbiAgICpcbiAgICogV2lsbCBhc3N1bWUgdGhlIGxvb2t1cCByb2xlIGlmIGNvbmZpZ3VyZWQgb24gdGhlIHN0YWNrLiBDaGVjayB0aGUgZGVmYXVsdCBgbG9va3VwLXJvbGVgXG4gICAqIHBvbGljaWVzIHRvIHNlZSB3aGF0IHlvdSBjYW4gZG8gd2l0aCB0aGlzIHJvbGUuIEl0IGNhbiBnZW5lcmFsbHkgcmVhZCBldmVyeXRoaW5nXG4gICAqIGluIHRoZSBhY2NvdW50IHRoYXQgZG9lcyBub3QgcmVxdWlyZSBLTVMgYWNjZXNzLlxuICAgKlxuICAgKiAtLS1cbiAgICpcbiAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnMsIHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvcyB0aGF0IGFyZSBoYW5kbGVkIGhlcmU6XG4gICAqXG4gICAqICAxLiBUaGUgbG9va3VwIHJvbGUgbWF5IG5vdCBleGlzdCAoaXQgd2FzIGFkZGVkIGluIGJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uIDcpLiBJZiBzbzpcbiAgICogICAgIGEuIFJldHVybiB0aGUgZGVmYXVsdCBjcmVkZW50aWFscyBpZiB0aGUgZGVmYXVsdCBjcmVkZW50aWFscyBhcmUgZm9yIHRoZSBzdGFjayBhY2NvdW50XG4gICAqICAgICAgICAoeW91IHdpbGwgbm90aWNlIHRoaXMgYXMgYGlzRmFsbGJhY2tDcmVkZW50aWFscz10cnVlYCkuXG4gICAqICAgICBiLiBUaHJvdyBhbiBlcnJvciBpZiB0aGUgZGVmYXVsdCBjcmVkZW50aWFscyBhcmUgbm90IGZvciB0aGUgc3RhY2sgYWNjb3VudC5cbiAgICpcbiAgICogIDIuIFRoZSBsb29rdXAgcm9sZSBtYXkgbm90IGhhdmUgdGhlIGNvcnJlY3QgcGVybWlzc2lvbnMgKGZvciBleGFtcGxlLCBSZWFkT25seUFjY2VzcyB3YXMgYWRkZWQgaW5cbiAgICogICAgIGJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uIDgpOyB0aGUgc3RhY2sgd2lsbCBoYXZlIGEgbWluaW11bSB2ZXJzaW9uIG51bWJlciBvbiBpdC5cbiAgICogICAgIGEuIElmIGl0IGRvZXMgbm90IHdlIHRocm93IGFuIGVycm9yIHdoaWNoIHNob3VsZCBiZSBoYW5kbGVkIGluIHRoZSBjYWxsaW5nXG4gICAqICAgICAgICBmdW5jdGlvbiAoYW5kIGZhbGxiYWNrIHRvIHVzZSBhIGRpZmZlcmVudCByb2xlLCBldGMpXG4gICAqXG4gICAqIFVwb24gc3VjY2VzcywgY2FsbGVyIHdpbGwgaGF2ZSBhbiBTREsgZm9yIHRoZSByaWdodCBhY2NvdW50LCB3aGljaCBtYXkgb3IgbWF5IG5vdCBoYXZlXG4gICAqIHRoZSByaWdodCBwZXJtaXNzaW9ucy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBhY2Nlc3NTdGFja0Zvckxvb2t1cChzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KTogUHJvbWlzZTxUYXJnZXRFbnZpcm9ubWVudD4ge1xuICAgIGlmICghc3RhY2suZW52aXJvbm1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYFRoZSBzdGFjayAke3N0YWNrLmRpc3BsYXlOYW1lfSBkb2VzIG5vdCBoYXZlIGFuIGVudmlyb25tZW50YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9va3VwRW52ID0gYXdhaXQgdGhpcy5wcmVwYXJlU2RrKHtcbiAgICAgIGVudmlyb25tZW50OiBzdGFjay5lbnZpcm9ubWVudCxcbiAgICAgIG1vZGU6IE1vZGUuRm9yUmVhZGluZyxcbiAgICAgIGFzc3VtZVJvbGVBcm46IHN0YWNrLmxvb2t1cFJvbGU/LmFybixcbiAgICAgIGFzc3VtZVJvbGVFeHRlcm5hbElkOiBzdGFjay5sb29rdXBSb2xlPy5hc3N1bWVSb2xlRXh0ZXJuYWxJZCxcbiAgICAgIGFzc3VtZVJvbGVBZGRpdGlvbmFsT3B0aW9uczogc3RhY2subG9va3VwUm9sZT8uYXNzdW1lUm9sZUFkZGl0aW9uYWxPcHRpb25zLFxuICAgIH0pO1xuXG4gICAgLy8gaWYgd2Ugc3VjY2VlZCBpbiBhc3N1bWluZyB0aGUgbG9va3VwIHJvbGUsIG1ha2Ugc3VyZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IGJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uXG4gICAgaWYgKGxvb2t1cEVudi5kaWRBc3N1bWVSb2xlICYmIHN0YWNrLmxvb2t1cFJvbGU/LmJvb3RzdHJhcFN0YWNrVmVyc2lvblNzbVBhcmFtZXRlciAmJiBzdGFjay5sb29rdXBSb2xlLnJlcXVpcmVzQm9vdHN0cmFwU3RhY2tWZXJzaW9uKSB7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgbG9va3VwRW52LnJlc291cmNlcy52ZXJzaW9uRnJvbVNzbVBhcmFtZXRlcihzdGFjay5sb29rdXBSb2xlLmJvb3RzdHJhcFN0YWNrVmVyc2lvblNzbVBhcmFtZXRlcik7XG4gICAgICBpZiAodmVyc2lvbiA8IHN0YWNrLmxvb2t1cFJvbGUucmVxdWlyZXNCb290c3RyYXBTdGFja1ZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgQm9vdHN0cmFwIHN0YWNrIHZlcnNpb24gJyR7c3RhY2subG9va3VwUm9sZS5yZXF1aXJlc0Jvb3RzdHJhcFN0YWNrVmVyc2lvbn0nIGlzIHJlcXVpcmVkLCBmb3VuZCB2ZXJzaW9uICcke3ZlcnNpb259Jy4gVG8gZ2V0IHJpZCBvZiB0aGlzIGVycm9yLCBwbGVhc2UgdXBncmFkZSB0byBib290c3RyYXAgdmVyc2lvbiA+PSAke3N0YWNrLmxvb2t1cFJvbGUucmVxdWlyZXNCb290c3RyYXBTdGFja1ZlcnNpb259YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsb29rdXBFbnYuaXNGYWxsYmFja0NyZWRlbnRpYWxzKSB7XG4gICAgICBjb25zdCBhcm4gPSBhd2FpdCBsb29rdXBFbnYucmVwbGFjZVBsYWNlaG9sZGVycyhzdGFjay5sb29rdXBSb2xlPy5hcm4pO1xuICAgICAgYXdhaXQgdGhpcy5pb0hvc3Qubm90aWZ5KHdhcm4odGhpcy5hY3Rpb24sIGBMb29rdXAgcm9sZSAke2Fybn0gd2FzIG5vdCBhc3N1bWVkLiBQcm9jZWVkaW5nIHdpdGggZGVmYXVsdCBjcmVkZW50aWFscy5gKSk7XG4gICAgfVxuICAgIHJldHVybiBsb29rdXBFbnY7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIFNESyB0byBhY2Nlc3MgdGhlIGdpdmVuIHN0YWNrJ3MgZW52aXJvbm1lbnQgZm9yIHJlYWRpbmcgc3RhY2sgYXR0cmlidXRlc1xuICAgKlxuICAgKiBXaWxsIHVzZSBhIHBsdWdpbiBpZiBhdmFpbGFibGUsIHVzZSB0aGUgZGVmYXVsdCBBV1MgY3JlZGVudGlhbHMgaWYgbm90LlxuICAgKiBUaGUgYG1vZGVgIHBhcmFtZXRlciBpcyBvbmx5IHVzZWQgZm9yIHF1ZXJ5aW5nIHBsdWdpbnMuXG4gICAqXG4gICAqIFdpbGwgdHJ5IHRvIGFzc3VtZSB0aGUgbG9va3VwIHJvbGUgaWYgZ2l2ZW4sIHdpbGwgdXNlIHRoZSByZWd1bGFyIHN0YWNrIG9wZXJhdGlvbnNcbiAgICogYWNjZXNzIChkZXBsb3ktcm9sZSkgb3RoZXJ3aXNlLiBXaGVuIGNhbGxpbmcgdGhpcywgeW91IHNob3VsZCBhc3N1bWUgdGhhdCB5b3Ugd2lsbCBnZXRcbiAgICogdGhlIGxlYXN0IHByaXZpbGVnZWQgcm9sZSwgc28gZG9uJ3QgdHJ5IHRvIHVzZSBpdCBmb3IgYW55dGhpbmcgdGhlIGBkZXBsb3ktcm9sZWBcbiAgICogd291bGRuJ3QgYmUgYWJsZSB0byBkby4gQWxzbyB5b3UgY2Fubm90IHJlbHkgb24gYmVpbmcgYWJsZSB0byByZWFkIGVuY3J5cHRlZCBhbnl0aGluZy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBhY2Nlc3NTdGFja0Zvckxvb2t1cEJlc3RFZmZvcnQoc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCk6IFByb21pc2U8VGFyZ2V0RW52aXJvbm1lbnQ+IHtcbiAgICBpZiAoIXN0YWNrLmVudmlyb25tZW50KSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBUaGUgc3RhY2sgJHtzdGFjay5kaXNwbGF5TmFtZX0gZG9lcyBub3QgaGF2ZSBhbiBlbnZpcm9ubWVudGApO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5hY2Nlc3NTdGFja0Zvckxvb2t1cChzdGFjayk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBhd2FpdCB0aGlzLmlvSG9zdC5ub3RpZnkod2Fybih0aGlzLmFjdGlvbiwgYCR7Zm9ybWF0RXJyb3JNZXNzYWdlKGUpfWApKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWNjZXNzU3RhY2tGb3JTdGFja09wZXJhdGlvbnMoc3RhY2ssIE1vZGUuRm9yUmVhZGluZyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIFNESyB0byBhY2Nlc3MgdGhlIGdpdmVuIHN0YWNrJ3MgZW52aXJvbm1lbnQgZm9yIHN0YWNrIG9wZXJhdGlvbnNcbiAgICpcbiAgICogV2lsbCB1c2UgYSBwbHVnaW4gaWYgYXZhaWxhYmxlLCB1c2UgdGhlIGRlZmF1bHQgQVdTIGNyZWRlbnRpYWxzIGlmIG5vdC5cbiAgICogVGhlIGBtb2RlYCBwYXJhbWV0ZXIgaXMgb25seSB1c2VkIGZvciBxdWVyeWluZyBwbHVnaW5zLlxuICAgKlxuICAgKiBXaWxsIGFzc3VtZSB0aGUgZGVwbG95IHJvbGUgaWYgY29uZmlndXJlZCBvbiB0aGUgc3RhY2suIENoZWNrIHRoZSBkZWZhdWx0IGBkZXBsb3ktcm9sZWBcbiAgICogcG9saWNpZXMgdG8gc2VlIHdoYXQgeW91IGNhbiBkbyB3aXRoIHRoaXMgcm9sZS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgYWNjZXNzU3RhY2tGb3JTdGFja09wZXJhdGlvbnMoc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCwgbW9kZTogTW9kZSk6IFByb21pc2U8VGFyZ2V0RW52aXJvbm1lbnQ+IHtcbiAgICBpZiAoIXN0YWNrLmVudmlyb25tZW50KSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBUaGUgc3RhY2sgJHtzdGFjay5kaXNwbGF5TmFtZX0gZG9lcyBub3QgaGF2ZSBhbiBlbnZpcm9ubWVudGApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByZXBhcmVTZGsoe1xuICAgICAgZW52aXJvbm1lbnQ6IHN0YWNrLmVudmlyb25tZW50LFxuICAgICAgbW9kZSxcbiAgICAgIGFzc3VtZVJvbGVBcm46IHN0YWNrLmFzc3VtZVJvbGVBcm4sXG4gICAgICBhc3N1bWVSb2xlRXh0ZXJuYWxJZDogc3RhY2suYXNzdW1lUm9sZUV4dGVybmFsSWQsXG4gICAgICBhc3N1bWVSb2xlQWRkaXRpb25hbE9wdGlvbnM6IHN0YWNrLmFzc3VtZVJvbGVBZGRpdGlvbmFsT3B0aW9ucyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlIGFuIFNESyBmb3IgdXNlIGluIHRoZSBnaXZlbiBlbnZpcm9ubWVudCBhbmQgb3B0aW9uYWxseSB3aXRoIGEgcm9sZSBhc3N1bWVkLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBwcmVwYXJlU2RrKFxuICAgIG9wdGlvbnM6IFByZXBhcmVTZGtSb2xlT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxUYXJnZXRFbnZpcm9ubWVudD4ge1xuICAgIGNvbnN0IHJlc29sdmVkRW52aXJvbm1lbnQgPSBhd2FpdCB0aGlzLnNka1Byb3ZpZGVyLnJlc29sdmVFbnZpcm9ubWVudChvcHRpb25zLmVudmlyb25tZW50KTtcblxuICAgIC8vIFN1YnN0aXR1dGUgYW55IHBsYWNlaG9sZGVycyB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGVudmlyb25tZW50XG4gICAgY29uc3QgeyBhc3N1bWVSb2xlQXJuIH0gPSBhd2FpdCByZXBsYWNlRW52UGxhY2Vob2xkZXJzKHtcbiAgICAgIGFzc3VtZVJvbGVBcm46IG9wdGlvbnMuYXNzdW1lUm9sZUFybixcbiAgICB9LCByZXNvbHZlZEVudmlyb25tZW50LCB0aGlzLnNka1Byb3ZpZGVyKTtcblxuICAgIGNvbnN0IHN0YWNrU2RrID0gYXdhaXQgdGhpcy5jYWNoZWRTZGtGb3JFbnZpcm9ubWVudChyZXNvbHZlZEVudmlyb25tZW50LCBvcHRpb25zLm1vZGUsIHtcbiAgICAgIGFzc3VtZVJvbGVBcm4sXG4gICAgICBhc3N1bWVSb2xlRXh0ZXJuYWxJZDogb3B0aW9ucy5hc3N1bWVSb2xlRXh0ZXJuYWxJZCxcbiAgICAgIGFzc3VtZVJvbGVBZGRpdGlvbmFsT3B0aW9uczogb3B0aW9ucy5hc3N1bWVSb2xlQWRkaXRpb25hbE9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2RrOiBzdGFja1Nkay5zZGssXG4gICAgICByZXNvbHZlZEVudmlyb25tZW50LFxuICAgICAgcmVzb3VyY2VzOiB0aGlzLmVudmlyb25tZW50UmVzb3VyY2VzLmZvcihyZXNvbHZlZEVudmlyb25tZW50LCBzdGFja1Nkay5zZGssIHsgaW9Ib3N0OiB0aGlzLmlvSG9zdCwgYWN0aW9uOiB0aGlzLmFjdGlvbiB9KSxcbiAgICAgIC8vIElmIHdlIGFza2VkIGZvciBhIHJvbGUsIGRpZCBub3Qgc3VjY2Vzc2Z1bGx5IGFzc3VtZSBpdCwgYW5kIHlldCBnb3QgaGVyZSB3aXRob3V0IGFuIGV4Y2VwdGlvbjogdGhhdFxuICAgICAgLy8gbWVhbnMgd2UgbXVzdCBoYXZlIGZhbGxiYWNrIGNyZWRlbnRpYWxzLlxuICAgICAgaXNGYWxsYmFja0NyZWRlbnRpYWxzOiAhc3RhY2tTZGsuZGlkQXNzdW1lUm9sZSAmJiAhIWFzc3VtZVJvbGVBcm4sXG4gICAgICBkaWRBc3N1bWVSb2xlOiBzdGFja1Nkay5kaWRBc3N1bWVSb2xlLFxuICAgICAgcmVwbGFjZVBsYWNlaG9sZGVyczogYXN5bmMgPEEgZXh0ZW5kcyBzdHJpbmcgfCB1bmRlZmluZWQ+KHN0cjogQSkgPT4ge1xuICAgICAgICBjb25zdCByZXQgPSBhd2FpdCByZXBsYWNlRW52UGxhY2Vob2xkZXJzKHsgc3RyIH0sIHJlc29sdmVkRW52aXJvbm1lbnQsIHRoaXMuc2RrUHJvdmlkZXIpO1xuICAgICAgICByZXR1cm4gcmV0LnN0cjtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY2FjaGVkU2RrRm9yRW52aXJvbm1lbnQoXG4gICAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICAgIG1vZGU6IE1vZGUsXG4gICAgb3B0aW9ucz86IENyZWRlbnRpYWxzT3B0aW9ucyxcbiAgKSB7XG4gICAgY29uc3QgY2FjaGVLZXlFbGVtZW50cyA9IFtcbiAgICAgIGVudmlyb25tZW50LmFjY291bnQsXG4gICAgICBlbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICBgJHttb2RlfWAsXG4gICAgICBvcHRpb25zPy5hc3N1bWVSb2xlQXJuID8/ICcnLFxuICAgICAgb3B0aW9ucz8uYXNzdW1lUm9sZUV4dGVybmFsSWQgPz8gJycsXG4gICAgXTtcblxuICAgIGlmIChvcHRpb25zPy5hc3N1bWVSb2xlQWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgIGNhY2hlS2V5RWxlbWVudHMucHVzaChKU09OLnN0cmluZ2lmeShvcHRpb25zLmFzc3VtZVJvbGVBZGRpdGlvbmFsT3B0aW9ucykpO1xuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlS2V5ID0gY2FjaGVLZXlFbGVtZW50cy5qb2luKCc6Jyk7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLnNka0NhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIuZm9yRW52aXJvbm1lbnQoZW52aXJvbm1lbnQsIG1vZGUsIG9wdGlvbnMpO1xuICAgIHRoaXMuc2RrQ2FjaGUuc2V0KGNhY2hlS2V5LCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTREsgb2J0YWluZWQgYnkgYXNzdW1pbmcgdGhlIGRlcGxveSByb2xlXG4gKiBmb3IgYSBnaXZlbiBlbnZpcm9ubWVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRhcmdldEVudmlyb25tZW50IHtcbiAgLyoqXG4gICAqIFRoZSBTREsgZm9yIHRoZSBnaXZlbiBlbnZpcm9ubWVudFxuICAgKi9cbiAgcmVhZG9ubHkgc2RrOiBTREs7XG5cbiAgLyoqXG4gICAqIFRoZSByZXNvbHZlZCBlbnZpcm9ubWVudCBmb3IgdGhlIHN0YWNrXG4gICAqIChubyBtb3JlICd1bmtub3duLWFjY291bnQvdW5rbm93bi1yZWdpb24nKVxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb2x2ZWRFbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQ7XG5cbiAgLyoqXG4gICAqIEFjY2VzcyBjbGFzcyBmb3IgZW52aXJvbm1lbnRhbCByZXNvdXJjZXMgdG8gaGVscCB0aGUgZGVwbG95bWVudFxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VzOiBFbnZpcm9ubWVudFJlc291cmNlcztcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3Qgd2UgYXNzdW1lZCBhIHJvbGUgaW4gdGhlIHByb2Nlc3Mgb2YgZ2V0dGluZyB0aGVzZSBjcmVkZW50aWFsc1xuICAgKi9cbiAgcmVhZG9ubHkgZGlkQXNzdW1lUm9sZTogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhlc2UgYXJlIGZhbGxiYWNrIGNyZWRlbnRpYWxzXG4gICAqXG4gICAqIEZhbGxiYWNrIGNyZWRlbnRpYWxzIG1lYW5zIHRoYXQgYXNzdW1pbmcgdGhlIGludGVuZGVkIHJvbGUgZmFpbGVkLCBidXQgdGhlXG4gICAqIGJhc2UgY3JlZGVudGlhbHMgaGFwcGVuIHRvIGJlIGZvciB0aGUgcmlnaHQgYWNjb3VudCBzbyB3ZSBqdXN0IHBpY2tlZCB0aG9zZVxuICAgKiBhbmQgaG9wZSB0aGUgZnV0dXJlIFNESyBjYWxscyBzdWNjZWVkLlxuICAgKlxuICAgKiBUaGlzIGlzIGEgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgbWVjaGFuaXNtIGZyb20gYXJvdW5kIHRoZSB0aW1lIHdlIGludHJvZHVjZWRcbiAgICogZGVwbG95bWVudCByb2xlcy5cbiAgICovXG4gIHJlYWRvbmx5IGlzRmFsbGJhY2tDcmVkZW50aWFsczogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVwbGFjZSBlbnZpcm9ubWVudCBwbGFjZWhvbGRlcnMgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGVudmlyb25tZW50XG4gICAqL1xuICByZXBsYWNlUGxhY2Vob2xkZXJzKHg6IHN0cmluZyB8IHVuZGVmaW5lZCk6IFByb21pc2U8U3RyaW5nV2l0aG91dFBsYWNlaG9sZGVycyB8IHVuZGVmaW5lZD47XG59XG5cbmludGVyZmFjZSBQcmVwYXJlU2RrUm9sZU9wdGlvbnMge1xuICByZWFkb25seSBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQ7XG4gIHJlYWRvbmx5IG1vZGU6IE1vZGU7XG4gIHJlYWRvbmx5IGFzc3VtZVJvbGVBcm4/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGFzc3VtZVJvbGVFeHRlcm5hbElkPzogc3RyaW5nO1xuICByZWFkb25seSBhc3N1bWVSb2xlQWRkaXRpb25hbE9wdGlvbnM/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xufVxuIl19