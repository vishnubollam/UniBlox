"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceImporter = void 0;
exports.removeNonImportResources = removeNonImportResources;
const util_1 = require("util");
const cfnDiff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const fs = require("fs-extra");
const promptly = require("promptly");
const messages_1 = require("../../cli/messages");
const error_1 = require("../../toolkit/error");
const deployments_1 = require("../deployments");
/**
 * Resource importing utility class
 *
 * - Determines the resources added to a template (compared to the deployed version)
 * - Look up the identification information
 *   - Load them from a file, or
 *   - Ask the user, based on information supplied to us by CloudFormation's GetTemplateSummary
 * - Translate the input to a structure expected by CloudFormation, update the template to add the
 *   importable resources, then run an IMPORT changeset.
 */
class ResourceImporter {
    constructor(stack, props) {
        this.stack = stack;
        this.cfn = props.deployments;
        this.ioHost = props.ioHost;
        this.action = props.action;
    }
    /**
     * Ask the user for resources to import
     */
    async askForResourceIdentifiers(available) {
        const ret = { importResources: [], resourceMap: {} };
        const resourceIdentifiers = await this.resourceIdentifiers();
        for (const resource of available) {
            const identifier = await this.askForResourceIdentifier(resourceIdentifiers, resource);
            if (!identifier) {
                continue;
            }
            ret.importResources.push(resource);
            ret.resourceMap[resource.logicalId] = identifier;
        }
        return ret;
    }
    /**
     * Load the resources to import from a file
     */
    async loadResourceIdentifiers(available, filename) {
        const contents = await fs.readJson(filename);
        const ret = { importResources: [], resourceMap: {} };
        for (const resource of available) {
            const descr = this.describeResource(resource.logicalId);
            const idProps = contents[resource.logicalId];
            if (idProps) {
                await this.ioHost.notify((0, messages_1.info)(this.action, (0, util_1.format)('%s: importing using %s', chalk.blue(descr), chalk.blue(fmtdict(idProps)))));
                ret.importResources.push(resource);
                ret.resourceMap[resource.logicalId] = idProps;
                delete contents[resource.logicalId];
            }
            else {
                await this.ioHost.notify((0, messages_1.info)(this.action, (0, util_1.format)('%s: skipping', chalk.blue(descr))));
            }
        }
        const unknown = Object.keys(contents);
        if (unknown.length > 0) {
            await this.ioHost.notify((0, messages_1.warn)(this.action, `Unrecognized resource identifiers in mapping file: ${unknown.join(', ')}`));
        }
        return ret;
    }
    /**
     * Based on the provided resource mapping, prepare CFN structures for import (template,
     * ResourcesToImport structure) and perform the import operation (CloudFormation deployment)
     *
     * @param importMap Mapping from CDK construct tree path to physical resource import identifiers
     * @param options Options to pass to CloudFormation deploy operation
     */
    async importResourcesFromMap(importMap, options = {}) {
        const resourcesToImport = await this.makeResourcesToImport(importMap);
        const updatedTemplate = await this.currentTemplateWithAdditions(importMap.importResources);
        await this.importResources(updatedTemplate, resourcesToImport, options);
    }
    /**
     * Based on the app and resources file generated by cdk migrate. Removes all items from the template that
     * cannot be included in an import change-set for new stacks and performs the import operation,
     * creating the new stack.
     *
     * @param resourcesToImport The mapping created by cdk migrate
     * @param options Options to pass to CloudFormation deploy operation
     */
    async importResourcesFromMigrate(resourcesToImport, options = {}) {
        const updatedTemplate = this.removeNonImportResources();
        await this.importResources(updatedTemplate, resourcesToImport, options);
    }
    async importResources(overrideTemplate, resourcesToImport, options) {
        try {
            const result = await this.cfn.deployStack({
                stack: this.stack,
                deployName: this.stack.stackName,
                ...options,
                overrideTemplate,
                resourcesToImport,
            });
            (0, deployments_1.assertIsSuccessfulDeployStackResult)(result);
            const message = result.noOp
                ? ' ✅  %s (no changes)'
                : ' ✅  %s';
            await this.ioHost.notify((0, messages_1.info)(this.action, '\n' + chalk.green((0, util_1.format)(message, this.stack.displayName))));
        }
        catch (e) {
            await this.ioHost.notify((0, messages_1.error)(this.action, (0, util_1.format)('\n ❌  %s failed: %s', chalk.bold(this.stack.displayName), e), 'CDK_TOOLKIT_E3900'));
            throw e;
        }
    }
    /**
     * Perform a diff between the currently running and the new template, ensure that it is valid
     * for importing and return a list of resources that are being added in the new version
     *
     * @return mapping logicalResourceId -> resourceDifference
     */
    async discoverImportableResources(allowNonAdditions = false) {
        const currentTemplate = await this.currentTemplate();
        const diff = cfnDiff.fullDiff(currentTemplate, this.stack.template);
        // Ignore changes to CDKMetadata
        const resourceChanges = Object.entries(diff.resources.changes)
            .filter(([logicalId, _]) => logicalId !== 'CDKMetadata');
        // Split the changes into additions and non-additions. Imports only make sense
        // for newly-added resources.
        const nonAdditions = resourceChanges.filter(([_, dif]) => !dif.isAddition);
        const additions = resourceChanges.filter(([_, dif]) => dif.isAddition);
        if (nonAdditions.length) {
            const offendingResources = nonAdditions.map(([logId, _]) => this.describeResource(logId));
            if (allowNonAdditions) {
                await this.ioHost.notify((0, messages_1.warn)(this.action, `Ignoring updated/deleted resources (--force): ${offendingResources.join(', ')}`));
            }
            else {
                throw new error_1.ToolkitError('No resource updates or deletes are allowed on import operation. Make sure to resolve pending changes ' +
                    `to existing resources, before attempting an import. Updated/deleted resources: ${offendingResources.join(', ')} (--force to override)`);
            }
        }
        // Resources in the new template, that are not present in the current template, are a potential import candidates
        return {
            additions: additions.map(([logicalId, resourceDiff]) => {
                var _a, _b, _c;
                return ({
                    logicalId,
                    resourceDiff,
                    resourceDefinition: addDefaultDeletionPolicy((_c = (_b = (_a = this.stack.template) === null || _a === void 0 ? void 0 : _a.Resources) === null || _b === void 0 ? void 0 : _b[logicalId]) !== null && _c !== void 0 ? _c : {}),
                });
            }),
            hasNonAdditions: nonAdditions.length > 0,
        };
    }
    /**
     * Resolves the environment of a stack.
     */
    async resolveEnvironment() {
        return this.cfn.resolveEnvironment(this.stack);
    }
    /**
     * Get currently deployed template of the given stack (SINGLETON)
     *
     * @returns Currently deployed CloudFormation template
     */
    async currentTemplate() {
        if (!this._currentTemplate) {
            this._currentTemplate = await this.cfn.readCurrentTemplate(this.stack);
        }
        return this._currentTemplate;
    }
    /**
     * Return the current template, with the given resources added to it
     */
    async currentTemplateWithAdditions(additions) {
        const template = await this.currentTemplate();
        if (!template.Resources) {
            template.Resources = {};
        }
        for (const add of additions) {
            template.Resources[add.logicalId] = add.resourceDefinition;
        }
        return template;
    }
    /**
     * Get a list of import identifiers for all resource types used in the given
     * template that do support the import operation (SINGLETON)
     *
     * @returns a mapping from a resource type to a list of property names that together identify the resource for import
     */
    async resourceIdentifiers() {
        var _a, _b;
        const ret = {};
        const resourceIdentifierSummaries = await this.cfn.resourceIdentifierSummaries(this.stack);
        for (const summary of resourceIdentifierSummaries) {
            if ('ResourceType' in summary && summary.ResourceType && 'ResourceIdentifiers' in summary && summary.ResourceIdentifiers) {
                ret[summary.ResourceType] = (_b = ((_a = summary.ResourceIdentifiers) !== null && _a !== void 0 ? _a : [])) === null || _b === void 0 ? void 0 : _b.map(x => x.split(','));
            }
        }
        return ret;
    }
    /**
     * Ask for the importable identifier for the given resource
     *
     * There may be more than one identifier under which a resource can be imported. The `import`
     * operation needs exactly one of them.
     *
     * - If we can get one from the template, we will use one.
     * - Otherwise, we will ask the user for one of them.
     */
    async askForResourceIdentifier(resourceIdentifiers, chg) {
        var _a, _b;
        const resourceName = this.describeResource(chg.logicalId);
        // Skip resources that do not support importing
        const resourceType = chg.resourceDiff.newResourceType;
        if (resourceType === undefined || !(resourceType in resourceIdentifiers)) {
            await this.ioHost.notify((0, messages_1.warn)(this.action, `${resourceName}: unsupported resource type ${resourceType}, skipping import.`));
            return undefined;
        }
        const idPropSets = resourceIdentifiers[resourceType];
        // Retain only literal strings: strip potential CFN intrinsics
        const resourceProps = Object.fromEntries(Object.entries((_a = chg.resourceDefinition.Properties) !== null && _a !== void 0 ? _a : {})
            .filter(([_, v]) => typeof v === 'string'));
        // Find property sets that are fully satisfied in the template, ask the user to confirm them
        const satisfiedPropSets = idPropSets.filter(ps => ps.every(p => resourceProps[p]));
        for (const satisfiedPropSet of satisfiedPropSets) {
            const candidateProps = Object.fromEntries(satisfiedPropSet.map(p => [p, resourceProps[p]]));
            const displayCandidateProps = fmtdict(candidateProps);
            if (await promptly.confirm(`${chalk.blue(resourceName)} (${resourceType}): import with ${chalk.yellow(displayCandidateProps)} (yes/no) [default: yes]? `, { default: 'yes' })) {
                return candidateProps;
            }
        }
        // If we got here and the user rejected any available identifiers, then apparently they don't want the resource at all
        if (satisfiedPropSets.length > 0) {
            await this.ioHost.notify((0, messages_1.info)(this.action, chalk.grey(`Skipping import of ${resourceName}`)));
            return undefined;
        }
        // We cannot auto-import this, ask the user for one of the props
        // The only difference between these cases is what we print: for multiple properties, we print a preamble
        const prefix = `${chalk.blue(resourceName)} (${resourceType})`;
        let preamble;
        let promptPattern;
        if (idPropSets.length > 1) {
            preamble = `${prefix}: enter one of ${idPropSets.map(x => chalk.blue(x.join('+'))).join(', ')} to import (all empty to skip)`;
            promptPattern = `${prefix}: enter %`;
        }
        else {
            promptPattern = `${prefix}: enter %`;
        }
        // Do the input loop here
        if (preamble) {
            await this.ioHost.notify((0, messages_1.info)(this.action, preamble));
        }
        for (const idProps of idPropSets) {
            const input = {};
            for (const idProp of idProps) {
                // If we have a value from the template, use it as default. This will only be a partial
                // identifier if present, otherwise we would have done the import already above.
                const defaultValue = (_b = resourceProps[idProp]) !== null && _b !== void 0 ? _b : '';
                const prompt = [
                    promptPattern.replace(/%/g, chalk.blue(idProp)),
                    defaultValue
                        ? `[${defaultValue}]`
                        : '(empty to skip)',
                ].join(' ') + ':';
                const response = await promptly.prompt(prompt, { default: defaultValue, trim: true });
                if (!response) {
                    break;
                }
                input[idProp] = response;
                // Also stick this property into 'resourceProps', so that it may be reused by a subsequent question
                // (for a different compound identifier that involves the same property). Just a small UX enhancement.
                resourceProps[idProp] = response;
            }
            // If the user gave inputs for all values, we are complete
            if (Object.keys(input).length === idProps.length) {
                return input;
            }
        }
        await this.ioHost.notify((0, messages_1.info)(this.action, chalk.grey(`Skipping import of ${resourceName}`)));
        return undefined;
    }
    /**
     * Convert the internal "resource mapping" structure to CloudFormation accepted "ResourcesToImport" structure
     */
    async makeResourcesToImport(resourceMap) {
        return resourceMap.importResources.map(res => ({
            LogicalResourceId: res.logicalId,
            ResourceType: res.resourceDiff.newResourceType,
            ResourceIdentifier: resourceMap.resourceMap[res.logicalId],
        }));
    }
    /**
     * Convert CloudFormation logical resource ID to CDK construct tree path
     *
     * @param logicalId CloudFormation logical ID of the resource (the key in the template's Resources section)
     * @returns Forward-slash separated path of the resource in CDK construct tree, e.g. MyStack/MyBucket/Resource
     */
    describeResource(logicalId) {
        var _a, _b, _c, _d, _e;
        return (_e = (_d = (_c = (_b = (_a = this.stack.template) === null || _a === void 0 ? void 0 : _a.Resources) === null || _b === void 0 ? void 0 : _b[logicalId]) === null || _c === void 0 ? void 0 : _c.Metadata) === null || _d === void 0 ? void 0 : _d['aws:cdk:path']) !== null && _e !== void 0 ? _e : logicalId;
    }
    /**
     * Removes CDKMetadata and Outputs in the template so that only resources for importing are left.
     * @returns template with import resources only
     */
    removeNonImportResources() {
        return removeNonImportResources(this.stack);
    }
}
exports.ResourceImporter = ResourceImporter;
/**
 * Removes CDKMetadata and Outputs in the template so that only resources for importing are left.
 * @returns template with import resources only
 */
function removeNonImportResources(stack) {
    const template = stack.template;
    delete template.Resources.CDKMetadata;
    delete template.Outputs;
    return template;
}
function fmtdict(xs) {
    return Object.entries(xs).map(([k, v]) => `${k}=${v}`).join(', ');
}
/**
 * Add a default `DeletionPolicy` policy.
 * The default value is set to 'Retain', to lower risk of unintentionally
 * deleting stateful resources in the process of importing to CDK.
 */
function addDefaultDeletionPolicy(resource) {
    if (resource.DeletionPolicy) {
        return resource;
    }
    return {
        ...resource,
        DeletionPolicy: 'Retain',
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1wb3J0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbXBvcnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUF1Y0EsNERBS0M7QUE1Y0QsK0JBQThCO0FBQzlCLHdEQUF3RDtBQUd4RCwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLHFDQUFxQztBQUNyQyxpREFBdUQ7QUFFdkQsK0NBQW1EO0FBQ25ELGdEQUEwSjtBQXdGMUo7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBYSxnQkFBZ0I7SUFRM0IsWUFDRSxLQUF3QyxFQUN4QyxLQUE0QjtRQUU1QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7UUFDN0IsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO1FBQzNCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztJQUM3QixDQUFDO0lBRUQ7O09BRUc7SUFDSSxLQUFLLENBQUMseUJBQXlCLENBQUMsU0FBK0I7UUFDcEUsTUFBTSxHQUFHLEdBQWMsRUFBRSxlQUFlLEVBQUUsRUFBRSxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUNoRSxNQUFNLG1CQUFtQixHQUFHLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFFN0QsS0FBSyxNQUFNLFFBQVEsSUFBSSxTQUFTLEVBQUUsQ0FBQztZQUNqQyxNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxtQkFBbUIsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUN0RixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7Z0JBQ2hCLFNBQVM7WUFDWCxDQUFDO1lBRUQsR0FBRyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDbkMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsU0FBUyxD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QVEsQ0FBQyxPQUFPLENBQUM7SUFDeEIsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQztBQXdDRCxTQUFTLE9BQU8sQ0FBSSxFQUFxQjtJQUN2QyxPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3BFLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyx3QkFBd0IsQ0FBQyxRQUFhO0lBQzdDLElBQUksUUFBUSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQUMsT0FBTyxRQUFRLENBQUM7SUFBQyxDQUFDO0lBRWpELE9BQU87UUFDTCxHQUFHLFFBQVE7UUFDWCxjQUFjLEVBQUUsUUFBUTtLQUN6QixDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0ICogYXMgY2ZuRGlmZiBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCB7IFJlc291cmNlRGlmZmVyZW5jZSB9IGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIHByb21wdGx5IGZyb20gJ3Byb21wdGx5JztcbmltcG9ydCB7IGVycm9yLCBpbmZvLCB3YXJuIH0gZnJvbSAnLi4vLi4vY2xpL21lc3NhZ2VzJztcbmltcG9ydCB7IElJb0hvc3QsIFRvb2xraXRBY3Rpb24gfSBmcm9tICcuLi8uLi90b29sa2l0L2NsaS1pby1ob3N0JztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uL3Rvb2xraXQvZXJyb3InO1xuaW1wb3J0IHsgYXNzZXJ0SXNTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQsIHR5cGUgRGVwbG95bWVudHMsIERlcGxveW1lbnRNZXRob2QsIFJlc291cmNlSWRlbnRpZmllclByb3BlcnRpZXMsIFJlc291cmNlc1RvSW1wb3J0IH0gZnJvbSAnLi4vZGVwbG95bWVudHMnO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSAnLi4vdGFncyc7XG5pbXBvcnQgeyBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MgfSBmcm9tICcuLi91dGlsL2Nsb3VkZm9ybWF0aW9uL3N0YWNrLWFjdGl2aXR5LW1vbml0b3InO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlc291cmNlSW1wb3J0ZXJQcm9wcyB7XG4gIGRlcGxveW1lbnRzOiBEZXBsb3ltZW50cztcbiAgaW9Ib3N0OiBJSW9Ib3N0O1xuICBhY3Rpb246IFRvb2xraXRBY3Rpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1wb3J0RGVwbG95bWVudE9wdGlvbnMge1xuICAvKipcbiAgICogUm9sZSB0byBwYXNzIHRvIENsb3VkRm9ybWF0aW9uIGZvciBkZXBsb3ltZW50XG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdCBzdGFjayByb2xlXG4gICAqL1xuICByZWFkb25seSByb2xlQXJuPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZXBsb3ltZW50IG1ldGhvZFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIENoYW5nZSBzZXQgd2l0aCBkZWZhdWx0IG9wdGlvbnNcbiAgICovXG4gIHJlYWRvbmx5IGRlcGxveW1lbnRNZXRob2Q/OiBEZXBsb3ltZW50TWV0aG9kO1xuXG4gIC8qKlxuICAgKiBTdGFjayB0YWdzIChwYXNzIHRocm91Z2ggdG8gQ2xvdWRGb3JtYXRpb24pXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gdGFnc1xuICAgKi9cbiAgcmVhZG9ubHkgdGFncz86IFRhZ1tdO1xuXG4gIC8qKlxuICAgKiBVc2UgcHJldmlvdXMgdmFsdWVzIGZvciB1bnNwZWNpZmllZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIElmIG5vdCBzZXQsIGFsbCBwYXJhbWV0ZXJzIG11c3QgYmUgc3BlY2lmaWVkIGZvciBldmVyeSBkZXBsb3ltZW50LlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSB1c2VQcmV2aW91c1BhcmFtZXRlcnM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEaXNwbGF5IG1vZGUgZm9yIHN0YWNrIGRlcGxveW1lbnQgcHJvZ3Jlc3MuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gU3RhY2tBY3Rpdml0eVByb2dyZXNzLkJhciAtIHN0YWNrIGV2ZW50cyB3aWxsIGJlIGRpc3BsYXllZCBmb3JcbiAgICogICB0aGUgcmVzb3VyY2UgY3VycmVudGx5IGJlaW5nIGRlcGxveWVkLlxuICAgKi9cbiAgcmVhZG9ubHkgcHJvZ3Jlc3M/OiBTdGFja0FjdGl2aXR5UHJvZ3Jlc3M7XG5cbiAgLyoqXG4gICAqIFJvbGxiYWNrIGZhaWxlZCBkZXBsb3ltZW50c1xuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSByb2xsYmFjaz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogU2V0IG9mIHBhcmFtZXRlcnMgdGhhdCB1bmlxdWVseSBpZGVudGlmeSBhIHBoeXNpY2FsIHJlc291cmNlIG9mIGEgZ2l2ZW4gdHlwZVxuICogZm9yIHRoZSBpbXBvcnQgb3BlcmF0aW9uLCBleGFtcGxlOlxuICpcbiAqIGBgYFxuICoge1xuICogICBcIkFXUzo6UzM6OkJ1Y2tldFwiOiBbW1wiQnVja2V0TmFtZVwiXV0sXG4gKiAgIFwiQVdTOjpEeW5hbW9EQjo6R2xvYmFsVGFibGVcIjogW1tcIlRhYmxlTmFtZVwiXSwgW1wiVGFibGVBcm5cIl0sIFtcIlRhYmxlU3RyZWFtQXJuXCJdXSxcbiAqICAgXCJBV1M6OlJvdXRlNTM6OktleVNpZ25pbmdLZXlcIjogW1tcIkhvc3RlZFpvbmVJZFwiLCBcIk5hbWVcIl1dLFxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCB0eXBlIFJlc291cmNlSWRlbnRpZmllcnMgPSB7IFtyZXNvdXJjZVR5cGU6IHN0cmluZ106IHN0cmluZ1tdW10gfTtcblxuLyoqXG4gKiBNYXBwaW5nIG9mIENESyByZXNvdXJjZXMgKEwxIGNvbnN0cnVjdHMpIHRvIHBoeXNpY2FsIHJlc291cmNlcyB0byBiZSBpbXBvcnRlZFxuICogaW4gdGhlaXIgcGxhY2UsIGV4YW1wbGU6XG4gKlxuICogYGBgXG4gKiB7XG4gKiAgIFwiTXlTdGFjay9NeVMzQnVja2V0L1Jlc291cmNlXCI6IHtcbiAqICAgICBcIkJ1Y2tldE5hbWVcIjogXCJteS1tYW51YWxseS1jcmVhdGVkLXMzLWJ1Y2tldFwiXG4gKiAgIH0sXG4gKiAgIFwiTXlTdGFjay9NeVZwYy9SZXNvdXJjZVwiOiB7XG4gKiAgICAgXCJWcGNJZFwiOiBcInZwYy0xMjM0NTY3ODlcIlxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IHR5cGUgUmVzb3VyY2VNYXAgPSB7IFtsb2dpY2FsUmVzb3VyY2U6IHN0cmluZ106IFJlc291cmNlSWRlbnRpZmllclByb3BlcnRpZXMgfTtcblxuLyoqXG4gKiBSZXNvdXJjZSBpbXBvcnRpbmcgdXRpbGl0eSBjbGFzc1xuICpcbiAqIC0gRGV0ZXJtaW5lcyB0aGUgcmVzb3VyY2VzIGFkZGVkIHRvIGEgdGVtcGxhdGUgKGNvbXBhcmVkIHRvIHRoZSBkZXBsb3llZCB2ZXJzaW9uKVxuICogLSBMb29rIHVwIHRoZSBpZGVudGlmaWNhdGlvbiBpbmZvcm1hdGlvblxuICogICAtIExvYWQgdGhlbSBmcm9tIGEgZmlsZSwgb3JcbiAqICAgLSBBc2sgdGhlIHVzZXIsIGJhc2VkIG9uIGluZm9ybWF0aW9uIHN1cHBsaWVkIHRvIHVzIGJ5IENsb3VkRm9ybWF0aW9uJ3MgR2V0VGVtcGxhdGVTdW1tYXJ5XG4gKiAtIFRyYW5zbGF0ZSB0aGUgaW5wdXQgdG8gYSBzdHJ1Y3R1cmUgZXhwZWN0ZWQgYnkgQ2xvdWRGb3JtYXRpb24sIHVwZGF0ZSB0aGUgdGVtcGxhdGUgdG8gYWRkIHRoZVxuICogICBpbXBvcnRhYmxlIHJlc291cmNlcywgdGhlbiBydW4gYW4gSU1QT1JUIGNoYW5nZXNldC5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlc291cmNlSW1wb3J0ZXIge1xuICBwcml2YXRlIF9jdXJyZW50VGVtcGxhdGU6IGFueTtcblxuICBwcml2YXRlIHJlYWRvbmx5IHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2ZuOiBEZXBsb3ltZW50cztcbiAgcHJpdmF0ZSByZWFkb25seSBpb0hvc3Q6IElJb0hvc3Q7XG4gIHByaXZhdGUgcmVhZG9ubHkgYWN0aW9uOiBUb29sa2l0QWN0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsXG4gICAgcHJvcHM6IFJlc291cmNlSW1wb3J0ZXJQcm9wcyxcbiAgKSB7XG4gICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgIHRoaXMuY2ZuID0gcHJvcHMuZGVwbG95bWVudHM7XG4gICAgdGhpcy5pb0hvc3QgPSBwcm9wcy5pb0hvc3Q7XG4gICAgdGhpcy5hY3Rpb24gPSBwcm9wcy5hY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQXNrIHRoZSB1c2VyIGZvciByZXNvdXJjZXMgdG8gaW1wb3J0XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYXNrRm9yUmVzb3VyY2VJZGVudGlmaWVycyhhdmFpbGFibGU6IEltcG9ydGFibGVSZXNvdXJjZVtdKTogUHJvbWlzZTxJbXBvcnRNYXA+IHtcbiAgICBjb25zdCByZXQ6IEltcG9ydE1hcCA9IHsgaW1wb3J0UmVzb3VyY2VzOiBbXSwgcmVzb3VyY2VNYXA6IHt9IH07XG4gICAgY29uc3QgcmVzb3VyY2VJZGVudGlmaWVycyA9IGF3YWl0IHRoaXMucmVzb3VyY2VJZGVudGlmaWVycygpO1xuXG4gICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiBhdmFpbGFibGUpIHtcbiAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBhd2FpdCB0aGlzLmFza0ZvclJlc291cmNlSWRlbnRpZmllcihyZXNvdXJjZUlkZW50aWZpZXJzLCByZXNvdXJjZSk7XG4gICAgICBpZiAoIWlkZW50aWZpZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldC5pbXBvcnRSZXNvdXJjZXMucHVzaChyZXNvdXJjZSk7XG4gICAgICByZXQucmVzb3VyY2VNYXBbcmVzb3VyY2UubG9naWNhbElkXSA9IGlkZW50aWZpZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSByZXNvdXJjZXMgdG8gaW1wb3J0IGZyb20gYSBmaWxlXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbG9hZFJlc291cmNlSWRlbnRpZmllcnMoYXZhaWxhYmxlOiBJbXBvcnRhYmxlUmVzb3VyY2VbXSwgZmlsZW5hbWU6IHN0cmluZyk6IFByb21pc2U8SW1wb3J0TWFwPiB7XG4gICAgY29uc3QgY29udGVudHMgPSBhd2FpdCBmcy5yZWFkSnNvbihmaWxlbmFtZSk7XG5cbiAgICBjb25zdCByZXQ6IEltcG9ydE1hcCA9IHsgaW1wb3J0UmVzb3VyY2VzOiBbXSwgcmVzb3VyY2VNYXA6IHt9IH07XG4gICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiBhdmFpbGFibGUpIHtcbiAgICAgIGNvbnN0IGRlc2NyID0gdGhpcy5kZXNjcmliZVJlc291cmNlKHJlc291cmNlLmxvZ2ljYWxJZCk7XG4gICAgICBjb25zdCBpZFByb3BzID0gY29udGVudHNbcmVzb3VyY2UubG9naWNhbElkXTtcbiAgICAgIGlmIChpZFByb3BzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW9Ib3N0Lm5vdGlmeShpbmZvKHRoaXMuYWN0aW9uLCBmb3JtYXQoJyVzOiBpbXBvcnRpbmcgdXNpbmcgJXMnLCBjaGFsay5ibHVlKGRlc2NyKSwgY2hhbGsuYmx1ZShmbXRkaWN0KGlkUHJvcHMpKSkpKTtcblxuICAgICAgICByZXQuaW1wb3J0UmVzb3VyY2VzLnB1c2gocmVzb3VyY2UpO1xuICAgICAgICByZXQucmVzb3VyY2VNYXBbcmVzb3VyY2UubG9naWNhbElkXSA9IGlkUHJvcHM7XG4gICAgICAgIGRlbGV0ZSBjb250ZW50c1tyZXNvdXJjZS5sb2dpY2FsSWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pb0hvc3Qubm90aWZ5KGluZm8odGhpcy5hY3Rpb24sIGZvcm1hdCgnJXM6IHNraXBwaW5nJywgY2hhbGsuYmx1ZShkZXNjcikpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdW5rbm93biA9IE9iamVjdC5rZXlzKGNvbnRlbnRzKTtcbiAgICBpZiAodW5rbm93bi5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLmlvSG9zdC5ub3RpZnkod2Fybih0aGlzLmFjdGlvbiwgYFVucmVjb2duaXplZCByZXNvdXJjZSBpZGVudGlmaWVycyBpbiBtYXBwaW5nIGZpbGU6ICR7dW5rbm93bi5qb2luKCcsICcpfWApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEJhc2VkIG9uIHRoZSBwcm92aWRlZCByZXNvdXJjZSBtYXBwaW5nLCBwcmVwYXJlIENGTiBzdHJ1Y3R1cmVzIGZvciBpbXBvcnQgKHRlbXBsYXRlLFxuICAgKiBSZXNvdXJjZXNUb0ltcG9ydCBzdHJ1Y3R1cmUpIGFuZCBwZXJmb3JtIHRoZSBpbXBvcnQgb3BlcmF0aW9uIChDbG91ZEZvcm1hdGlvbiBkZXBsb3ltZW50KVxuICAgKlxuICAgKiBAcGFyYW0gaW1wb3J0TWFwIE1hcHBpbmcgZnJvbSBDREsgY29uc3RydWN0IHRyZWUgcGF0aCB0byBwaHlzaWNhbCByZXNvdXJjZSBpbXBvcnQgaWRlbnRpZmllcnNcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIHRvIENsb3VkRm9ybWF0aW9uIGRlcGxveSBvcGVyYXRpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBpbXBvcnRSZXNvdXJjZXNGcm9tTWFwKGltcG9ydE1hcDogSW1wb3J0TWFwLCBvcHRpb25zOiBJbXBvcnREZXBsb3ltZW50T3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzb3VyY2VzVG9JbXBvcnQ6IFJlc291cmNlc1RvSW1wb3J0ID0gYXdhaXQgdGhpcy5tYWtlUmVzb3VyY2VzVG9JbXBvcnQoaW1wb3J0TWFwKTtcbiAgICBjb25zdCB1cGRhdGVkVGVtcGxhdGUgPSBhd2FpdCB0aGlzLmN1cnJlbnRUZW1wbGF0ZVdpdGhBZGRpdGlvbnMoaW1wb3J0TWFwLmltcG9ydFJlc291cmNlcyk7XG5cbiAgICBhd2FpdCB0aGlzLmltcG9ydFJlc291cmNlcyh1cGRhdGVkVGVtcGxhdGUsIHJlc291cmNlc1RvSW1wb3J0LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNlZCBvbiB0aGUgYXBwIGFuZCByZXNvdXJjZXMgZmlsZSBnZW5lcmF0ZWQgYnkgY2RrIG1pZ3JhdGUuIFJlbW92ZXMgYWxsIGl0ZW1zIGZyb20gdGhlIHRlbXBsYXRlIHRoYXRcbiAgICogY2Fubm90IGJlIGluY2x1ZGVkIGluIGFuIGltcG9ydCBjaGFuZ2Utc2V0IGZvciBuZXcgc3RhY2tzIGFuZCBwZXJmb3JtcyB0aGUgaW1wb3J0IG9wZXJhdGlvbixcbiAgICogY3JlYXRpbmcgdGhlIG5ldyBzdGFjay5cbiAgICpcbiAgICogQHBhcmFtIHJlc291cmNlc1RvSW1wb3J0IFRoZSBtYXBwaW5nIGNyZWF0ZWQgYnkgY2RrIG1pZ3JhdGVcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIHRvIENsb3VkRm9ybWF0aW9uIGRlcGxveSBvcGVyYXRpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBpbXBvcnRSZXNvdXJjZXNGcm9tTWlncmF0ZShyZXNvdXJjZXNUb0ltcG9ydDogUmVzb3VyY2VzVG9JbXBvcnQsIG9wdGlvbnM6IEltcG9ydERlcGxveW1lbnRPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB1cGRhdGVkVGVtcGxhdGUgPSB0aGlzLnJlbW92ZU5vbkltcG9ydFJlc291cmNlcygpO1xuXG4gICAgYXdhaXQgdGhpcy5pbXBvcnRSZXNvdXJjZXModXBkYXRlZFRlbXBsYXRlLCByZXNvdXJjZXNUb0ltcG9ydCwgb3B0aW9ucyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGltcG9ydFJlc291cmNlcyhvdmVycmlkZVRlbXBsYXRlOiBhbnksIHJlc291cmNlc1RvSW1wb3J0OiBSZXNvdXJjZXNUb0ltcG9ydCwgb3B0aW9uczogSW1wb3J0RGVwbG95bWVudE9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jZm4uZGVwbG95U3RhY2soe1xuICAgICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgICAgZGVwbG95TmFtZTogdGhpcy5zdGFjay5zdGFja05hbWUsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIG92ZXJyaWRlVGVtcGxhdGUsXG4gICAgICAgIHJlc291cmNlc1RvSW1wb3J0LFxuICAgICAgfSk7XG5cbiAgICAgIGFzc2VydElzU3VjY2Vzc2Z1bERlcGxveVN0YWNrUmVzdWx0KHJlc3VsdCk7XG5cbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXN1bHQubm9PcFxuICAgICAgICA/ICcg4pyFICAlcyAobm8gY2hhbmdlcyknXG4gICAgICAgIDogJyDinIUgICVzJztcblxuICAgICAgYXdhaXQgdGhpcy5pb0hvc3Qubm90aWZ5KGluZm8odGhpcy5hY3Rpb24sICdcXG4nICsgY2hhbGsuZ3JlZW4oZm9ybWF0KG1lc3NhZ2UsIHRoaXMuc3RhY2suZGlzcGxheU5hbWUpKSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW9Ib3N0Lm5vdGlmeShlcnJvcih0aGlzLmFjdGlvbiwgZm9ybWF0KCdcXG4g4p2MICAlcyBmYWlsZWQ6ICVzJywgY2hhbGsuYm9sZCh0aGlzLnN0YWNrLmRpc3BsYXlOYW1lKSwgZSksICdDREtfVE9PTEtJVF9FMzkwMCcpKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBkaWZmIGJldHdlZW4gdGhlIGN1cnJlbnRseSBydW5uaW5nIGFuZCB0aGUgbmV3IHRlbXBsYXRlLCBlbnN1cmUgdGhhdCBpdCBpcyB2YWxpZFxuICAgKiBmb3IgaW1wb3J0aW5nIGFuZCByZXR1cm4gYSBsaXN0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBiZWluZyBhZGRlZCBpbiB0aGUgbmV3IHZlcnNpb25cbiAgICpcbiAgICogQHJldHVybiBtYXBwaW5nIGxvZ2ljYWxSZXNvdXJjZUlkIC0+IHJlc291cmNlRGlmZmVyZW5jZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpc2NvdmVySW1wb3J0YWJsZVJlc291cmNlcyhhbGxvd05vbkFkZGl0aW9ucyA9IGZhbHNlKTogUHJvbWlzZTxEaXNjb3ZlckltcG9ydGFibGVSZXNvdXJjZXNSZXN1bHQ+IHtcbiAgICBjb25zdCBjdXJyZW50VGVtcGxhdGUgPSBhd2FpdCB0aGlzLmN1cnJlbnRUZW1wbGF0ZSgpO1xuXG4gICAgY29uc3QgZGlmZiA9IGNmbkRpZmYuZnVsbERpZmYoY3VycmVudFRlbXBsYXRlLCB0aGlzLnN0YWNrLnRlbXBsYXRlKTtcblxuICAgIC8vIElnbm9yZSBjaGFuZ2VzIHRvIENES01ldGFkYXRhXG4gICAgY29uc3QgcmVzb3VyY2VDaGFuZ2VzID0gT2JqZWN0LmVudHJpZXMoZGlmZi5yZXNvdXJjZXMuY2hhbmdlcylcbiAgICAgIC5maWx0ZXIoKFtsb2dpY2FsSWQsIF9dKSA9PiBsb2dpY2FsSWQgIT09ICdDREtNZXRhZGF0YScpO1xuXG4gICAgLy8gU3BsaXQgdGhlIGNoYW5nZXMgaW50byBhZGRpdGlvbnMgYW5kIG5vbi1hZGRpdGlvbnMuIEltcG9ydHMgb25seSBtYWtlIHNlbnNlXG4gICAgLy8gZm9yIG5ld2x5LWFkZGVkIHJlc291cmNlcy5cbiAgICBjb25zdCBub25BZGRpdGlvbnMgPSByZXNvdXJjZUNoYW5nZXMuZmlsdGVyKChbXywgZGlmXSkgPT4gIWRpZi5pc0FkZGl0aW9uKTtcbiAgICBjb25zdCBhZGRpdGlvbnMgPSByZXNvdXJjZUNoYW5nZXMuZmlsdGVyKChbXywgZGlmXSkgPT4gZGlmLmlzQWRkaXRpb24pO1xuXG4gICAgaWYgKG5vbkFkZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9mZmVuZGluZ1Jlc291cmNlcyA9IG5vbkFkZGl0aW9ucy5tYXAoKFtsb2dJZCwgX10pID0+IHRoaXMuZGVzY3JpYmVSZXNvdXJjZShsb2dJZCkpO1xuXG4gICAgICBpZiAoYWxsb3dOb25BZGRpdGlvbnMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pb0hvc3Qubm90aWZ5KHdhcm4odGhpcy5hY3Rpb24sIGBJZ25vcmluZyB1cGRhdGVkL2RlbGV0ZWQgcmVzb3VyY2VzICgtLWZvcmNlKTogJHtvZmZlbmRpbmdSZXNvdXJjZXMuam9pbignLCAnKX1gKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdObyByZXNvdXJjZSB1cGRhdGVzIG9yIGRlbGV0ZXMgYXJlIGFsbG93ZWQgb24gaW1wb3J0IG9wZXJhdGlvbi4gTWFrZSBzdXJlIHRvIHJlc29sdmUgcGVuZGluZyBjaGFuZ2VzICcgK1xuICAgICAgICAgIGB0byBleGlzdGluZyByZXNvdXJjZXMsIGJlZm9yZSBhdHRlbXB0aW5nIGFuIGltcG9ydC4gVXBkYXRlZC9kZWxldGVkIHJlc291cmNlczogJHtvZmZlbmRpbmdSZXNvdXJjZXMuam9pbignLCAnKX0gKC0tZm9yY2UgdG8gb3ZlcnJpZGUpYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzb3VyY2VzIGluIHRoZSBuZXcgdGVtcGxhdGUsIHRoYXQgYXJlIG5vdCBwcmVzZW50IGluIHRoZSBjdXJyZW50IHRlbXBsYXRlLCBhcmUgYSBwb3RlbnRpYWwgaW1wb3J0IGNhbmRpZGF0ZXNcbiAgICByZXR1cm4ge1xuICAgICAgYWRkaXRpb25zOiBhZGRpdGlvbnMubWFwKChbbG9naWNhbElkLCByZXNvdXJjZURpZmZdKSA9PiAoe1xuICAgICAgICBsb2dpY2FsSWQsXG4gICAgICAgIHJlc291cmNlRGlmZixcbiAgICAgICAgcmVzb3VyY2VEZWZpbml0aW9uOiBhZGREZWZhdWx0RGVsZXRpb25Qb2xpY3kodGhpcy5zdGFjay50ZW1wbGF0ZT8uUmVzb3VyY2VzPy5bbG9naWNhbElkXSA/PyB7fSksXG4gICAgICB9KSksXG4gICAgICBoYXNOb25BZGRpdGlvbnM6IG5vbkFkZGl0aW9ucy5sZW5ndGggPiAwLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIGVudmlyb25tZW50IG9mIGEgc3RhY2suXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcmVzb2x2ZUVudmlyb25tZW50KCk6IFByb21pc2U8Y3hhcGkuRW52aXJvbm1lbnQ+IHtcbiAgICByZXR1cm4gdGhpcy5jZm4ucmVzb2x2ZUVudmlyb25tZW50KHRoaXMuc3RhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50bHkgZGVwbG95ZWQgdGVtcGxhdGUgb2YgdGhlIGdpdmVuIHN0YWNrIChTSU5HTEVUT04pXG4gICAqXG4gICAqIEByZXR1cm5zIEN1cnJlbnRseSBkZXBsb3llZCBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjdXJyZW50VGVtcGxhdGUoKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRUZW1wbGF0ZSkge1xuICAgICAgdGhpcy5fY3VycmVudFRlbXBsYXRlID0gYXdhaXQgdGhpcy5jZm4ucmVhZEN1cnJlbnRUZW1wbGF0ZSh0aGlzLnN0YWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgdGVtcGxhdGUsIHdpdGggdGhlIGdpdmVuIHJlc291cmNlcyBhZGRlZCB0byBpdFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjdXJyZW50VGVtcGxhdGVXaXRoQWRkaXRpb25zKGFkZGl0aW9uczogSW1wb3J0YWJsZVJlc291cmNlW10pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gYXdhaXQgdGhpcy5jdXJyZW50VGVtcGxhdGUoKTtcbiAgICBpZiAoIXRlbXBsYXRlLlJlc291cmNlcykge1xuICAgICAgdGVtcGxhdGUuUmVzb3VyY2VzID0ge307XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBhZGQgb2YgYWRkaXRpb25zKSB7XG4gICAgICB0ZW1wbGF0ZS5SZXNvdXJjZXNbYWRkLmxvZ2ljYWxJZF0gPSBhZGQucmVzb3VyY2VEZWZpbml0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGltcG9ydCBpZGVudGlmaWVycyBmb3IgYWxsIHJlc291cmNlIHR5cGVzIHVzZWQgaW4gdGhlIGdpdmVuXG4gICAqIHRlbXBsYXRlIHRoYXQgZG8gc3VwcG9ydCB0aGUgaW1wb3J0IG9wZXJhdGlvbiAoU0lOR0xFVE9OKVxuICAgKlxuICAgKiBAcmV0dXJucyBhIG1hcHBpbmcgZnJvbSBhIHJlc291cmNlIHR5cGUgdG8gYSBsaXN0IG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgdG9nZXRoZXIgaWRlbnRpZnkgdGhlIHJlc291cmNlIGZvciBpbXBvcnRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcmVzb3VyY2VJZGVudGlmaWVycygpOiBQcm9taXNlPFJlc291cmNlSWRlbnRpZmllcnM+IHtcbiAgICBjb25zdCByZXQ6IFJlc291cmNlSWRlbnRpZmllcnMgPSB7fTtcbiAgICBjb25zdCByZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJpZXMgPSBhd2FpdCB0aGlzLmNmbi5yZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJpZXModGhpcy5zdGFjayk7XG4gICAgZm9yIChjb25zdCBzdW1tYXJ5IG9mIHJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcykge1xuICAgICAgaWYgKCdSZXNvdXJjZVR5cGUnIGluIHN1bW1hcnkgJiYgc3VtbWFyeS5SZXNvdXJjZVR5cGUgJiYgJ1Jlc291cmNlSWRlbnRpZmllcnMnIGluIHN1bW1hcnkgJiYgc3VtbWFyeS5SZXNvdXJjZUlkZW50aWZpZXJzKSB7XG4gICAgICAgIHJldFtzdW1tYXJ5LlJlc291cmNlVHlwZV0gPSAoc3VtbWFyeS5SZXNvdXJjZUlkZW50aWZpZXJzID8/IFtdKT8ubWFwKHggPT4geC5zcGxpdCgnLCcpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc2sgZm9yIHRoZSBpbXBvcnRhYmxlIGlkZW50aWZpZXIgZm9yIHRoZSBnaXZlbiByZXNvdXJjZVxuICAgKlxuICAgKiBUaGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBpZGVudGlmaWVyIHVuZGVyIHdoaWNoIGEgcmVzb3VyY2UgY2FuIGJlIGltcG9ydGVkLiBUaGUgYGltcG9ydGBcbiAgICogb3BlcmF0aW9uIG5lZWRzIGV4YWN0bHkgb25lIG9mIHRoZW0uXG4gICAqXG4gICAqIC0gSWYgd2UgY2FuIGdldCBvbmUgZnJvbSB0aGUgdGVtcGxhdGUsIHdlIHdpbGwgdXNlIG9uZS5cbiAgICogLSBPdGhlcndpc2UsIHdlIHdpbGwgYXNrIHRoZSB1c2VyIGZvciBvbmUgb2YgdGhlbS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgYXNrRm9yUmVzb3VyY2VJZGVudGlmaWVyKFxuICAgIHJlc291cmNlSWRlbnRpZmllcnM6IFJlc291cmNlSWRlbnRpZmllcnMsXG4gICAgY2hnOiBJbXBvcnRhYmxlUmVzb3VyY2UsXG4gICk6IFByb21pc2U8UmVzb3VyY2VJZGVudGlmaWVyUHJvcGVydGllcyB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IHJlc291cmNlTmFtZSA9IHRoaXMuZGVzY3JpYmVSZXNvdXJjZShjaGcubG9naWNhbElkKTtcblxuICAgIC8vIFNraXAgcmVzb3VyY2VzIHRoYXQgZG8gbm90IHN1cHBvcnQgaW1wb3J0aW5nXG4gICAgY29uc3QgcmVzb3VyY2VUeXBlID0gY2hnLnJlc291cmNlRGlmZi5uZXdSZXNvdXJjZVR5cGU7XG4gICAgaWYgKHJlc291cmNlVHlwZSA9PT0gdW5kZWZpbmVkIHx8ICEocmVzb3VyY2VUeXBlIGluIHJlc291cmNlSWRlbnRpZmllcnMpKSB7XG4gICAgICBhd2FpdCB0aGlzLmlvSG9zdC5ub3RpZnkod2Fybih0aGlzLmFjdGlvbiwgYCR7cmVzb3VyY2VOYW1lfTogdW5zdXBwb3J0ZWQgcmVzb3VyY2UgdHlwZSAke3Jlc291cmNlVHlwZX0sIHNraXBwaW5nIGltcG9ydC5gKSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGlkUHJvcFNldHMgPSByZXNvdXJjZUlkZW50aWZpZXJzW3Jlc291cmNlVHlwZV07XG5cbiAgICAvLyBSZXRhaW4gb25seSBsaXRlcmFsIHN0cmluZ3M6IHN0cmlwIHBvdGVudGlhbCBDRk4gaW50cmluc2ljc1xuICAgIGNvbnN0IHJlc291cmNlUHJvcHMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY2hnLnJlc291cmNlRGVmaW5pdGlvbi5Qcm9wZXJ0aWVzID8/IHt9KVxuICAgICAgLmZpbHRlcigoW18sIHZdKSA9PiB0eXBlb2YgdiA9PT0gJ3N0cmluZycpKSBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG4gICAgLy8gRmluZCBwcm9wZXJ0eSBzZXRzIHRoYXQgYXJlIGZ1bGx5IHNhdGlzZmllZCBpbiB0aGUgdGVtcGxhdGUsIGFzayB0aGUgdXNlciB0byBjb25maXJtIHRoZW1cbiAgICBjb25zdCBzYXRpc2ZpZWRQcm9wU2V0cyA9IGlkUHJvcFNldHMuZmlsdGVyKHBzID0+IHBzLmV2ZXJ5KHAgPT4gcmVzb3VyY2VQcm9wc1twXSkpO1xuICAgIGZvciAoY29uc3Qgc2F0aXNmaWVkUHJvcFNldCBvZiBzYXRpc2ZpZWRQcm9wU2V0cykge1xuICAgICAgY29uc3QgY2FuZGlkYXRlUHJvcHMgPSBPYmplY3QuZnJvbUVudHJpZXMoc2F0aXNmaWVkUHJvcFNldC5tYXAocCA9PiBbcCwgcmVzb3VyY2VQcm9wc1twXV0pKTtcbiAgICAgIGNvbnN0IGRpc3BsYXlDYW5kaWRhdGVQcm9wcyA9IGZtdGRpY3QoY2FuZGlkYXRlUHJvcHMpO1xuXG4gICAgICBpZiAoYXdhaXQgcHJvbXB0bHkuY29uZmlybShcbiAgICAgICAgYCR7Y2hhbGsuYmx1ZShyZXNvdXJjZU5hbWUpfSAoJHtyZXNvdXJjZVR5cGV9KTogaW1wb3J0IHdpdGggJHtjaGFsay55ZWxsb3coZGlzcGxheUNhbmRpZGF0ZVByb3BzKX0gKHllcy9ubykgW2RlZmF1bHQ6IHllc10/IGAsXG4gICAgICAgIHsgZGVmYXVsdDogJ3llcycgfSxcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZVByb3BzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGdvdCBoZXJlIGFuZCB0aGUgdXNlciByZWplY3RlZCBhbnkgYXZhaWxhYmxlIGlkZW50aWZpZXJzLCB0aGVuIGFwcGFyZW50bHkgdGhleSBkb24ndCB3YW50IHRoZSByZXNvdXJjZSBhdCBhbGxcbiAgICBpZiAoc2F0aXNmaWVkUHJvcFNldHMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5pb0hvc3Qubm90aWZ5KGluZm8odGhpcy5hY3Rpb24sIGNoYWxrLmdyZXkoYFNraXBwaW5nIGltcG9ydCBvZiAke3Jlc291cmNlTmFtZX1gKSkpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBXZSBjYW5ub3QgYXV0by1pbXBvcnQgdGhpcywgYXNrIHRoZSB1c2VyIGZvciBvbmUgb2YgdGhlIHByb3BzXG4gICAgLy8gVGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZXNlIGNhc2VzIGlzIHdoYXQgd2UgcHJpbnQ6IGZvciBtdWx0aXBsZSBwcm9wZXJ0aWVzLCB3ZSBwcmludCBhIHByZWFtYmxlXG4gICAgY29uc3QgcHJlZml4ID0gYCR7Y2hhbGsuYmx1ZShyZXNvdXJjZU5hbWUpfSAoJHtyZXNvdXJjZVR5cGV9KWA7XG4gICAgbGV0IHByZWFtYmxlO1xuICAgIGxldCBwcm9tcHRQYXR0ZXJuO1xuICAgIGlmIChpZFByb3BTZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHByZWFtYmxlID0gYCR7cHJlZml4fTogZW50ZXIgb25lIG9mICR7aWRQcm9wU2V0cy5tYXAoeCA9PiBjaGFsay5ibHVlKHguam9pbignKycpKSkuam9pbignLCAnKX0gdG8gaW1wb3J0IChhbGwgZW1wdHkgdG8gc2tpcClgO1xuICAgICAgcHJvbXB0UGF0dGVybiA9IGAke3ByZWZpeH06IGVudGVyICVgO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9tcHRQYXR0ZXJuID0gYCR7cHJlZml4fTogZW50ZXIgJWA7XG4gICAgfVxuXG4gICAgLy8gRG8gdGhlIGlucHV0IGxvb3AgaGVyZVxuICAgIGlmIChwcmVhbWJsZSkge1xuICAgICAgYXdhaXQgdGhpcy5pb0hvc3Qubm90aWZ5KGluZm8odGhpcy5hY3Rpb24sIHByZWFtYmxlKSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaWRQcm9wcyBvZiBpZFByb3BTZXRzKSB7XG4gICAgICBjb25zdCBpbnB1dDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgICAgZm9yIChjb25zdCBpZFByb3Agb2YgaWRQcm9wcykge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgdmFsdWUgZnJvbSB0aGUgdGVtcGxhdGUsIHVzZSBpdCBhcyBkZWZhdWx0LiBUaGlzIHdpbGwgb25seSBiZSBhIHBhcnRpYWxcbiAgICAgICAgLy8gaWRlbnRpZmllciBpZiBwcmVzZW50LCBvdGhlcndpc2Ugd2Ugd291bGQgaGF2ZSBkb25lIHRoZSBpbXBvcnQgYWxyZWFkeSBhYm92ZS5cbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gcmVzb3VyY2VQcm9wc1tpZFByb3BdID8/ICcnO1xuXG4gICAgICAgIGNvbnN0IHByb21wdCA9IFtcbiAgICAgICAgICBwcm9tcHRQYXR0ZXJuLnJlcGxhY2UoLyUvZywgY2hhbGsuYmx1ZShpZFByb3ApKSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgID8gYFske2RlZmF1bHRWYWx1ZX1dYFxuICAgICAgICAgICAgOiAnKGVtcHR5IHRvIHNraXApJyxcbiAgICAgICAgXS5qb2luKCcgJykgKyAnOic7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcHJvbXB0bHkucHJvbXB0KHByb21wdCxcbiAgICAgICAgICB7IGRlZmF1bHQ6IGRlZmF1bHRWYWx1ZSwgdHJpbTogdHJ1ZSB9LFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0W2lkUHJvcF0gPSByZXNwb25zZTtcbiAgICAgICAgLy8gQWxzbyBzdGljayB0aGlzIHByb3BlcnR5IGludG8gJ3Jlc291cmNlUHJvcHMnLCBzbyB0aGF0IGl0IG1heSBiZSByZXVzZWQgYnkgYSBzdWJzZXF1ZW50IHF1ZXN0aW9uXG4gICAgICAgIC8vIChmb3IgYSBkaWZmZXJlbnQgY29tcG91bmQgaWRlbnRpZmllciB0aGF0IGludm9sdmVzIHRoZSBzYW1lIHByb3BlcnR5KS4gSnVzdCBhIHNtYWxsIFVYIGVuaGFuY2VtZW50LlxuICAgICAgICByZXNvdXJjZVByb3BzW2lkUHJvcF0gPSByZXNwb25zZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHVzZXIgZ2F2ZSBpbnB1dHMgZm9yIGFsbCB2YWx1ZXMsIHdlIGFyZSBjb21wbGV0ZVxuICAgICAgaWYgKE9iamVjdC5rZXlzKGlucHV0KS5sZW5ndGggPT09IGlkUHJvcHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmlvSG9zdC5ub3RpZnkoaW5mbyh0aGlzLmFjdGlvbiwgY2hhbGsuZ3JleShgU2tpcHBpbmcgaW1wb3J0IG9mICR7cmVzb3VyY2VOYW1lfWApKSk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBpbnRlcm5hbCBcInJlc291cmNlIG1hcHBpbmdcIiBzdHJ1Y3R1cmUgdG8gQ2xvdWRGb3JtYXRpb24gYWNjZXB0ZWQgXCJSZXNvdXJjZXNUb0ltcG9ydFwiIHN0cnVjdHVyZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBtYWtlUmVzb3VyY2VzVG9JbXBvcnQocmVzb3VyY2VNYXA6IEltcG9ydE1hcCk6IFByb21pc2U8UmVzb3VyY2VzVG9JbXBvcnQ+IHtcbiAgICByZXR1cm4gcmVzb3VyY2VNYXAuaW1wb3J0UmVzb3VyY2VzLm1hcChyZXMgPT4gKHtcbiAgICAgIExvZ2ljYWxSZXNvdXJjZUlkOiByZXMubG9naWNhbElkLFxuICAgICAgUmVzb3VyY2VUeXBlOiByZXMucmVzb3VyY2VEaWZmLm5ld1Jlc291cmNlVHlwZSEsXG4gICAgICBSZXNvdXJjZUlkZW50aWZpZXI6IHJlc291cmNlTWFwLnJlc291cmNlTWFwW3Jlcy5sb2dpY2FsSWRdLFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IENsb3VkRm9ybWF0aW9uIGxvZ2ljYWwgcmVzb3VyY2UgSUQgdG8gQ0RLIGNvbnN0cnVjdCB0cmVlIHBhdGhcbiAgICpcbiAgICogQHBhcmFtIGxvZ2ljYWxJZCBDbG91ZEZvcm1hdGlvbiBsb2dpY2FsIElEIG9mIHRoZSByZXNvdXJjZSAodGhlIGtleSBpbiB0aGUgdGVtcGxhdGUncyBSZXNvdXJjZXMgc2VjdGlvbilcbiAgICogQHJldHVybnMgRm9yd2FyZC1zbGFzaCBzZXBhcmF0ZWQgcGF0aCBvZiB0aGUgcmVzb3VyY2UgaW4gQ0RLIGNvbnN0cnVjdCB0cmVlLCBlLmcuIE15U3RhY2svTXlCdWNrZXQvUmVzb3VyY2VcbiAgICovXG4gIHByaXZhdGUgZGVzY3JpYmVSZXNvdXJjZShsb2dpY2FsSWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2sudGVtcGxhdGU/LlJlc291cmNlcz8uW2xvZ2ljYWxJZF0/Lk1ldGFkYXRhPy5bJ2F3czpjZGs6cGF0aCddID8/IGxvZ2ljYWxJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIENES01ldGFkYXRhIGFuZCBPdXRwdXRzIGluIHRoZSB0ZW1wbGF0ZSBzbyB0aGF0IG9ubHkgcmVzb3VyY2VzIGZvciBpbXBvcnRpbmcgYXJlIGxlZnQuXG4gICAqIEByZXR1cm5zIHRlbXBsYXRlIHdpdGggaW1wb3J0IHJlc291cmNlcyBvbmx5XG4gICAqL1xuICBwcml2YXRlIHJlbW92ZU5vbkltcG9ydFJlc291cmNlcygpIHtcbiAgICByZXR1cm4gcmVtb3ZlTm9uSW1wb3J0UmVzb3VyY2VzKHRoaXMuc3RhY2spO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBDREtNZXRhZGF0YSBhbmQgT3V0cHV0cyBpbiB0aGUgdGVtcGxhdGUgc28gdGhhdCBvbmx5IHJlc291cmNlcyBmb3IgaW1wb3J0aW5nIGFyZSBsZWZ0LlxuICogQHJldHVybnMgdGVtcGxhdGUgd2l0aCBpbXBvcnQgcmVzb3VyY2VzIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vbkltcG9ydFJlc291cmNlcyhzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KSB7XG4gIGNvbnN0IHRlbXBsYXRlID0gc3RhY2sudGVtcGxhdGU7XG4gIGRlbGV0ZSB0ZW1wbGF0ZS5SZXNvdXJjZXMuQ0RLTWV0YWRhdGE7XG4gIGRlbGV0ZSB0ZW1wbGF0ZS5PdXRwdXRzO1xuICByZXR1cm4gdGVtcGxhdGU7XG59XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgYSByZXNvdXJjZSBpbiB0aGUgdGVtcGxhdGUgdGhhdCBpcyBpbXBvcnRhYmxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1wb3J0YWJsZVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFRoZSBsb2dpY2FsIElEIG9mIHRoZSByZXNvdXJjZVxuICAgKi9cbiAgcmVhZG9ubHkgbG9naWNhbElkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByZXNvdXJjZSBkZWZpbml0aW9uIGluIHRoZSBuZXcgdGVtcGxhdGVcbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlRGVmaW5pdGlvbjogYW55O1xuXG4gIC8qKlxuICAgKiBUaGUgZGlmZiBhcyByZXBvcnRlZCBieSBgY2xvdWRmb3JtYXRpb24tZGlmZmAuXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZURpZmY6IFJlc291cmNlRGlmZmVyZW5jZTtcbn1cblxuLyoqXG4gKiBUaGUgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIGV4ZWN1dGUgYW4gaW1wb3J0IG9wZXJhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltcG9ydE1hcCB7XG4gIC8qKlxuICAgKiBNYXBwaW5nIGxvZ2ljYWwgSURzIHRvIHBoeXNpY2FsIG5hbWVzXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZU1hcDogUmVzb3VyY2VNYXA7XG5cbiAgLyoqXG4gICAqIFRoZSBzZWxlY3Rpb24gb2YgcmVzb3VyY2VzIHdlIGFyZSBhY3R1YWxseSBpbXBvcnRpbmdcbiAgICpcbiAgICogRm9yIGVhY2ggb2YgdGhlIHJlc291cmNlcyBpbiB0aGlzIGxpc3QsIHRoZXJlIGlzIGEgY29ycmVzcG9uZGluZyBlbnRyeSBpblxuICAgKiB0aGUgYHJlc291cmNlTWFwYCBtYXAuXG4gICAqL1xuICByZWFkb25seSBpbXBvcnRSZXNvdXJjZXM6IEltcG9ydGFibGVSZXNvdXJjZVtdO1xufVxuXG5mdW5jdGlvbiBmbXRkaWN0PEE+KHhzOiBSZWNvcmQ8c3RyaW5nLCBBPikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoeHMpLm1hcCgoW2ssIHZdKSA9PiBgJHtrfT0ke3Z9YCkuam9pbignLCAnKTtcbn1cblxuLyoqXG4gKiBBZGQgYSBkZWZhdWx0IGBEZWxldGlvblBvbGljeWAgcG9saWN5LlxuICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgc2V0IHRvICdSZXRhaW4nLCB0byBsb3dlciByaXNrIG9mIHVuaW50ZW50aW9uYWxseVxuICogZGVsZXRpbmcgc3RhdGVmdWwgcmVzb3VyY2VzIGluIHRoZSBwcm9jZXNzIG9mIGltcG9ydGluZyB0byBDREsuXG4gKi9cbmZ1bmN0aW9uIGFkZERlZmF1bHREZWxldGlvblBvbGljeShyZXNvdXJjZTogYW55KTogYW55IHtcbiAgaWYgKHJlc291cmNlLkRlbGV0aW9uUG9saWN5KSB7IHJldHVybiByZXNvdXJjZTsgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ucmVzb3VyY2UsXG4gICAgRGVsZXRpb25Qb2xpY3k6ICdSZXRhaW4nLFxuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERpc2NvdmVySW1wb3J0YWJsZVJlc291cmNlc1Jlc3VsdCB7XG4gIHJlYWRvbmx5IGFkZGl0aW9uczogSW1wb3J0YWJsZVJlc291cmNlW107XG4gIHJlYWRvbmx5IGhhc05vbkFkZGl0aW9uczogYm9vbGVhbjtcbn1cbiJdfQ==