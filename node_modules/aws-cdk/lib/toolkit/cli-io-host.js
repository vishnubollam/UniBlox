"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CliIoHost = exports.levelPriority = void 0;
exports.isCI = isCI;
const util = require("node:util");
const chalk = require("chalk");
const promptly = require("promptly");
const error_1 = require("./error");
exports.levelPriority = {
    error: 0,
    result: 1,
    warn: 2,
    info: 3,
    debug: 4,
    trace: 5,
};
/**
 * A simple IO host for the CLI that writes messages to the console.
 */
class CliIoHost {
    /**
     * Returns the singleton instance
     */
    static instance(props = {}, forceNew = false) {
        if (forceNew || !CliIoHost._instance) {
            CliIoHost._instance = new CliIoHost(props);
        }
        return CliIoHost._instance;
    }
    constructor(props = {}) {
        var _a, _b, _c, _d, _e;
        // Corked Logging
        this.corkedCounter = 0;
        this.corkedLoggingBuffer = [];
        this._currentAction = (_a = props.currentAction) !== null && _a !== void 0 ? _a : 'none';
        this._isTTY = (_c = (_b = props.isTTY) !== null && _b !== void 0 ? _b : process.stdout.isTTY) !== null && _c !== void 0 ? _c : false;
        this._logLevel = (_d = props.logLevel) !== null && _d !== void 0 ? _d : 'info';
        this._isCI = (_e = props.isCI) !== null && _e !== void 0 ? _e : isCI();
    }
    /**
     * Returns the singleton instance
     */
    registerIoHost(ioHost) {
        if (ioHost !== this) {
            this._internalIoHost = ioHost;
        }
    }
    /**
     * The current action being performed by the CLI.
     */
    get currentAction() {
        return this._currentAction;
    }
    /**
     * Sets the current action being performed by the CLI.
     *
     * @param action The action being performed by the CLI.
     */
    set currentAction(action) {
        this._currentAction = action;
    }
    /**
     * Whether the host can use interactions and message styling.
     */
    get isTTY() {
        return this._isTTY;
    }
    /**
     * Set TTY mode, i.e can the host use interactions and message styling.
     *
     * @param value set TTY mode
     */
    set isTTY(value) {
        this._isTTY = value;
    }
    /**
     * Whether the CliIoHost is running in CI mode. In CI mode, all non-error output goes to stdout instead of stderr.
     */
    get isCI() {
        return this._isCI;
    }
    /**
     * Set the CI mode. In CI mode, all non-error output goes to stdout instead of stderr.
     * @param value set the CI mode
     */
    set isCI(value) {
        this._isCI = value;
    }
    /**
     * The current threshold. Messages with a lower priority level will be ignored.
     */
    get logLevel() {
        return this._logLevel;
    }
    /**
     * Sets the current threshold. Messages with a lower priority level will be ignored.
     * @param level The new log level threshold
     */
    set logLevel(level) {
        this._logLevel = level;
    }
    /**
     * Executes a block of code with corked logging. All log messages during execution
     * are buffered and only written when all nested cork blocks complete (when CORK_COUNTER reaches 0).
     * The corking is bound to the specific instance of the CliIoHost.
     *
     * @param block - Async function to execute with corked logging
     * @returns Promise that resolves with the block's return value
     */
    async withCorkedLogging(block) {
        this.corkedCounter++;
        try {
            return await block();
        }
        finally {
            this.corkedCounter--;
            if (this.corkedCounter === 0) {
                // Process each buffered message through notify
                for (const ioMessage of this.corkedLoggingBuffer) {
                    await this.notify(ioMessage);
                }
                // remove all buffered messages in-place
                this.corkedLoggingBuffer.splice(0);
            }
        }
    }
    /**
     * Notifies the host of a message.
     * The caller waits until the notification completes.
     */
    async notify(msg) {
        if (this._internalIoHost) {
            return this._internalIoHost.notify(msg);
        }
        if (exports.levelPriority[msg.level] > exports.levelPriority[this.logLevel]) {
            return;
        }
        if (this.corkedCounter > 0) {
            this.corkedLoggingBuffer.push(msg);
            return;
        }
        const output = this.formatMessage(msg);
        const stream = this.selectStream(msg.level);
        stream.write(output);
    }
    /**
     * Determines the output stream, based on message level and configuration.
     */
    selectStream(level) {
        // The stream selection policy for the CLI is the following:
        //
        //   (1) Messages of level `result` always go to `stdout`
        //   (2) Messages of level `error` always go to `stderr`.
        //   (3a) All remaining messages go to `stderr`.
        //   (3b) If we are in CI mode, all remaining messages go to `stdout`.
        //
        switch (level) {
            case 'error':
                return process.stderr;
            case 'result':
                return process.stdout;
            default:
                return this.isCI ? process.stdout : process.stderr;
        }
    }
    /**
     * Notifies the host of a message that requires a response.
     *
     * If the host does not return a response the suggested
     * default response from the input message will be used.
     */
    async requestResponse(msg) {
        // First call out to a registered instance if we have one
        if (this._internalIoHost) {
            return this._internalIoHost.requestResponse(msg);
        }
        // If the request cannot be prompted for by the CliIoHost, we just accept the default
        if (!isPromptableRequest(msg)) {
            await this.notify(msg);
            return msg.defaultResponse;
        }
        const response = await this.withCorkedLogging(async () => {
            var _a, _b, _c;
            // prepare prompt data
            // @todo this format is not defined anywhere, probably should be
            const data = (_a = msg.data) !== null && _a !== void 0 ? _a : {};
            const motivation = (_b = data.motivation) !== null && _b !== void 0 ? _b : 'User input is needed';
            const concurrency = (_c = data.concurrency) !== null && _c !== void 0 ? _c : 0;
            // only talk to user if STDIN is a terminal (otherwise, fail)
            if (!this.isTTY) {
                throw new error_1.ToolkitError(`${motivation}, but terminal (TTY) is not attached so we are unable to get a confirmation from the user`);
            }
            // only talk to user if concurrency is 1 (otherwise, fail)
            if (concurrency > 1) {
                throw new error_1.ToolkitError(`${motivation}, but concurrency is greater than 1 so we are unable to get a confirmation from the user`);
            }
            // Basic confirmation prompt
            // We treat all requests with a boolean response as confirmation prompts
            if (isConfirmationPrompt(msg)) {
                const confirmed = await promptly.confirm(`${chalk.cyan(msg.message)} (y/n)`);
                if (!confirmed) {
                    throw new error_1.ToolkitError('Aborted by user');
                }
                return confirmed;
            }
            // Asking for a specific value
            const prompt = extractPromptInfo(msg);
            const answer = await promptly.prompt(`${chalk.cyan(msg.message)} (${prompt.default})`, {
                default: prompt.default,
            });
            return prompt.convertAnswer(answer);
        });
        // We need to cast this because it is impossible to narrow the generic type
        // isPromptableRequest ensures that the response type is one we can prompt for
        // the remaining code ensure we are indeed returning the correct type
        return response;
    }
    /**
     * Formats a message for console output with optional color support
     */
    formatMessage(msg) {
        // apply provided style or a default style if we're in TTY mode
        let message_text = this._isTTY
            ? styleMap[msg.level](msg.message)
            : msg.message;
        // prepend timestamp if IoMessageLevel is DEBUG or TRACE. Postpend a newline.
        return ((msg.level === 'debug' || msg.level === 'trace')
            ? `[${this.formatTime(msg.time)}] ${message_text}`
            : message_text) + '\n';
    }
    /**
     * Formats date to HH:MM:SS
     */
    formatTime(d) {
        const pad = (n) => n.toString().padStart(2, '0');
        return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }
}
exports.CliIoHost = CliIoHost;
/**
 * This IoHost implementation considers a request promptable, if:
 * - it's a yes/no confirmation
 * - asking for a string or number value
 */
function isPromptableRequest(msg) {
    return isConfirmationPrompt(msg)
        || typeof msg.defaultResponse === 'string'
        || typeof msg.defaultResponse === 'number';
}
/**
 * Check if the request is a confirmation prompt
 * We treat all requests with a boolean response as confirmation prompts
 */
function isConfirmationPrompt(msg) {
    return typeof msg.defaultResponse === 'boolean';
}
/**
 * Helper to extract information for promptly from the request
 */
function extractPromptInfo(msg) {
    const isNumber = (typeof msg.defaultResponse === 'number');
    return {
        default: util.format(msg.defaultResponse),
        convertAnswer: isNumber ? (v) => Number(v) : (v) => String(v),
    };
}
const styleMap = {
    error: chalk.red,
    warn: chalk.yellow,
    result: chalk.white,
    info: chalk.white,
    debug: chalk.gray,
    trace: chalk.gray,
};
/**
 * Returns true if the current process is running in a CI environment
 * @returns true if the current process is running in a CI environment
 */
function isCI() {
    return process.env.CI !== undefined && process.env.CI !== 'false' && process.env.CI !== '0';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLWlvLWhvc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbGktaW8taG9zdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUF5ZEEsb0JBRUM7QUEzZEQsa0NBQWtDO0FBQ2xDLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMsbUNBQXVDO0FBaUUxQixRQUFBLGFBQWEsR0FBbUM7SUFDM0QsS0FBSyxFQUFFLENBQUM7SUFDUixNQUFNLEVBQUUsQ0FBQztJQUNULElBQUksRUFBRSxDQUFDO0lBQ1AsSUFBSSxFQUFFLENBQUM7SUFDUCxLQUFLLEVBQUUsQ0FBQztJQUNSLEtBQUssRUFBRSxDQUFDO0NBQ1QsQ0FBQztBQXdGRjs7R0FFRztBQUNILE1BQWEsU0FBUztJQUNwQjs7T0FFRztJQUNILE1BQU0sQ0FBQyxRQUFRLENBQUMsUUFBd0IsRUFBRSxFQUFFLFFBQVEsR0FBRyxLQUFLO1FBQzFELElBQUksUUFBUSxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ3JDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDN0MsQ0FBQztRQUNELE9BQU8sU0FBUyxDQUFDLFNBQVMsQ0FBQztJQUM3QixDQUFDO0lBa0JELFlBQW9CLFFBQXdCLEVBQUU7O1FBSjlDLGlCQUFpQjtRQUNULGtCQUFhLEdBQUcsQ0FBQyxDQUFDO1FBQ1Qsd0JBQW1CLEdBQXFCLEVBQUUsQ0FBQztRQUcxRCxJQUFJLENBQUMsY0FBYyxHQUFHLE1BQUEsS0FBSyxDQUFDLGFBQWEsbUNBQUksTUFBdUIsQ0FBQztRQUNyRSxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQUEsTUFBQSxLQUFLLENBQUMsS0FBSyxtQ0FBSSxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssbUNBQUksS0FBSyxDQUFDO1FBQzNELElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBQSxLQUFLLENBQUMsUUFBUSxtQ0FBSSxNQUFNLENBQUM7UUFDMUMsSUFBSSxDQUFDLEtBQUssR0FBRyxNQUFBLEtBQUssQ0FBQyxJQUFJLG1DQUFJLElBQUksRUFBRSxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7T0FFRztJQUNJLGNBQWMsQ0FBQyxNQUFlO1FBQ25DLElBQUksTUFBTSxLQUFLLElBQUksRUFBRSxDQUFDO1lBQ3BCLElBQUksQ0FBQyxlQUFlLEdBQUcsTUFBTSxDQUFDO1FBQ2hDLENBQUM7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLGFBQWE7UUFDdEIsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQzdCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsSUFBVyxhQUFhLENBQUMsTUFBcUI7UUFDNUMsSUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFNLENBQUM7SUFDL0IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxLQUFLO1FBQ2QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsSUFBVyxLQUFLLENBQUMsS0FBYztRQUM3QixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztJQUN0QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLElBQUk7UUFDYixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDcEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILElBQVcsSUFBSSxDQUFDLEtBQWM7UUFDNUIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDckIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxRQUFRO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUN4QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBVyxRQUFRLENBQUMsS0FBcUI7UUFDdkMsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxLQUFLLENBQUMsaUJBQWlCLENBQUksS0FBdUI7UUFDdkQsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQztZQUNILE9BQU8sTUFBTSxLQUFLLEVBQUUsQ0FBQztRQUN2QixDQUFDO2dCQUFTLENBQUM7WUFDVCxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDckIsSUFBSSxJQUFJLENBQUMsYUFBYSxLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUM3QiwrQ0FBK0M7Z0JBQy9DLEtBQUssTUFBTSxTQUFTLElBQUksSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7b0JBQ2pELE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDL0IsQ0FBQztnQkFDRCx3Q0FBd0M7Z0JBQ3hDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckMsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksS0FBSyxDQUFDLE1BQU0sQ0FBSSxHQUFpQjtRQUN0QyxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUN6QixPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzFDLENBQUM7UUFFRCxJQUFJLHFCQUFhLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLHFCQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7WUFDNUQsT0FBTztRQUNULENBQUM7UUFFRCxJQUFJLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDM0IsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNuQyxPQUFPO1FBQ1QsQ0FBQztRQUVELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdkMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDNUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7O09BRUc7SUFDSyxZQUFZLENBQUMsS0FBcUI7UUFDeEMsNERBQTREO1FBQzVELEVBQUU7UUFDRix5REFBeUQ7UUFDekQseURBQXlEO1FBQ3pELGdEQUFnRDtRQUNoRCxzRUFBc0U7UUFDdEUsRUFBRTtRQUNGLFFBQVEsS0FBSyxFQUFFLENBQUM7WUFDZCxLQUFLLE9BQU87Z0JBQ1YsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDO1lBQ3hCLEtBQUssUUFBUTtnQkFDWCxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUM7WUFDeEI7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDO1FBQ3ZELENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxLQUFLLENBQUMsZUFBZSxDQUF5QixHQUFzQztRQUN6Rix5REFBeUQ7UUFDekQsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDekIsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNuRCxDQUFDO1FBRUQscUZBQXFGO1FBQ3JGLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQzlCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN2QixPQUFPLEdBQUcsQ0FBQyxlQUFlLENBQUM7UUFDN0IsQ0FBQztRQUVELE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssSUFBcUMsRUFBRTs7WUFDeEYsc0JBQXNCO1lBQ3RCLGdFQUFnRTtZQUNoRSxNQUFNLElBQUksR0FHTixNQUFBLEdBQUcsQ0FBQyxJQUFJLG1DQUFJLEVBQUUsQ0FBQztZQUVuQixNQUFNLFVBQVUsR0FBRyxNQUFBLElBQUksQ0FBQyxVQUFVLG1DQUFJLHNCQUFzQixDQUFDO1lBQzdELE1BQU0sV0FBVyxHQUFHLE1BQUEsSUFBSSxDQUFDLFdBQVcsbUNBQUksQ0FBQyxDQUFDO1lBRTFDLDZEQUE2RDtZQUM3RCxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUNoQixNQUFNLElBQUksb0JBQVksQ0FBQyxHQUFHLFVBQVUsMkZBQTJGLENBQUMsQ0FBQztZQUNuSSxDQUFDO1lBRUQsMERBQTBEO1lBQzFELElBQUksV0FBVyxHQUFHLENBQUMsRUFBRSxDQUFDO2dCQUNwQixNQUFNLElBQUksb0JBQVksQ0FBQyxHQUFHLFVBQVUsMEZBQTBGLENBQUMsQ0FBQztZQUNsSSxDQUFDO1lBRUQsNEJBQTRCO1lBQzVCLHdFQUF3RTtZQUN4RSxJQUFJLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7Z0JBQzlCLE1BQU0sU0FBUyxHQUFHLE1BQU0sUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDN0UsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO29CQUNmLE1BQU0sSUFBSSxvQkFBWSxDQUFDLGlCQUFpQixDQUFDLENBQUM7Z0JBQzVDLENBQUM7Z0JBQ0QsT0FBTyxTQUFTLENBQUM7WUFDbkIsQ0FBQztZQUVELDhCQUE4QjtZQUM5QixNQUFNLE1BQU0sR0FBRyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN0QyxNQUFNLE1BQU0sR0FBRyxNQUFNLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxNQUFNLENBQUMsT0FBTyxHQUFHLEVBQUU7Z0JBQ3JGLE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBTzthQUN4QixDQUFDLENBQUM7WUFDSCxPQUFPLE1BQU0sQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdEMsQ0FBQyxDQUFDLENBQUM7UUFFSCwyRUFBMkU7UUFDM0UsOEVBQThFO1FBQzlFLHFFQUFxRTtRQUNyRSxPQUFPLFFBQXdCLENBQUM7SUFDbEMsQ0FBQztJQUVEOztPQUVHO0lBQ0ssYUFBYSxDQUFDLEdBQW1CO1FBQ3ZDLCtEQUErRDtRQUMvRCxJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsTUFBTTtZQUM1QixDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDO1lBQ2xDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDO1FBRWhCLDZFQUE2RTtRQUM3RSxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxLQUFLLE9BQU8sSUFBSSxHQUFHLENBQUMsS0FBSyxLQUFLLE9BQU8sQ0FBQztZQUN0RCxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxZQUFZLEVBQUU7WUFDbEQsQ0FBQyxDQUFDLFlBQVksQ0FBQyxHQUFHLElBQUksQ0FBQztJQUMzQixDQUFDO0lBRUQ7O09BRUc7SUFDSyxVQUFVLENBQUMsQ0FBTztRQUN4QixNQUFNLEdBQUcsR0FBRyxDQUFDLENBQVMsRUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDakUsT0FBTyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLFVBQVUsRUFBRSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLENBQUM7SUFDOUUsQ0FBQztDQUNGO0FBblFELDhCQW1RQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFTLG1CQUFtQixDQUFDLEdBQXdCO0lBQ25ELE9BQU8sb0JBQW9CLENBQUMsR0FBRyxDQUFDO1dBQzNCLE9BQU8sR0FBRyxDQUFDLGVBQWUsS0FBSyxRQUFRO1dBQ3ZDLE9BQU8sR0FBRyxDQUFDLGVBQWUsS0FBSyxRQUFRLENBQUM7QUFDL0MsQ0FBQztBQUVEOzs7R0FHRztBQUNILFNBQVMsb0JBQW9CLENBQUMsR0FBd0I7SUFDcEQsT0FBTyxPQUFPLEdBQUcsQ0FBQyxlQUFlLEtBQUssU0FBUyxDQUFDO0FBQ2xELENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsaUJBQWlCLENBQUMsR0FBd0I7SUFJakQsTUFBTSxRQUFRLEdBQUcsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxlQUFlLEtBQUssUUFBUSxDQUFDLENBQUM7SUFDM0QsT0FBTztRQUNMLE9BQU8sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUM7UUFDekMsYUFBYSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7S0FDOUQsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLFFBQVEsR0FBb0Q7SUFDaEUsS0FBSyxFQUFFLEtBQUssQ0FBQyxHQUFHO0lBQ2hCLElBQUksRUFBRSxLQUFLLENBQUMsTUFBTTtJQUNsQixNQUFNLEVBQUUsS0FBSyxDQUFDLEtBQUs7SUFDbkIsSUFBSSxFQUFFLEtBQUssQ0FBQyxLQUFLO0lBQ2pCLEtBQUssRUFBRSxLQUFLLENBQUMsSUFBSTtJQUNqQixLQUFLLEVBQUUsS0FBSyxDQUFDLElBQUk7Q0FDbEIsQ0FBQztBQUVGOzs7R0FHRztBQUNILFNBQWdCLElBQUk7SUFDbEIsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxTQUFTLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssT0FBTyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsQ0FBQztBQUM5RixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXRpbCBmcm9tICdub2RlOnV0aWwnO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0ICogYXMgcHJvbXB0bHkgZnJvbSAncHJvbXB0bHknO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yIH0gZnJvbSAnLi9lcnJvcic7XG5cbmV4cG9ydCB0eXBlIElvTWVzc2FnZUNvZGVDYXRlZ29yeSA9ICdUT09MS0lUJyB8ICdTREsnIHwgJ0FTU0VUUyc7XG5leHBvcnQgdHlwZSBJb0NvZGVMZXZlbCA9ICdFJyB8ICdXJyB8ICdJJztcbmV4cG9ydCB0eXBlIElvTWVzc2FnZVNwZWNpZmljQ29kZTxMIGV4dGVuZHMgSW9Db2RlTGV2ZWw+ID0gYENES18ke0lvTWVzc2FnZUNvZGVDYXRlZ29yeX1fJHtMfSR7bnVtYmVyfSR7bnVtYmVyfSR7bnVtYmVyfSR7bnVtYmVyfWA7XG5leHBvcnQgdHlwZSBJb01lc3NhZ2VDb2RlID0gSW9NZXNzYWdlU3BlY2lmaWNDb2RlPElvQ29kZUxldmVsPjtcblxuLyoqXG4gKiBCYXNpYyBtZXNzYWdlIHN0cnVjdHVyZSBmb3IgdG9vbGtpdCBub3RpZmljYXRpb25zLlxuICogTWVzc2FnZXMgYXJlIGVtaXR0ZWQgYnkgdGhlIHRvb2xraXQgYW5kIGhhbmRsZWQgYnkgdGhlIElvSG9zdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJb01lc3NhZ2U8VD4ge1xuICAvKipcbiAgICogVGhlIHRpbWUgdGhlIG1lc3NhZ2Ugd2FzIGVtaXR0ZWQuXG4gICAqL1xuICByZWFkb25seSB0aW1lOiBEYXRlO1xuXG4gIC8qKlxuICAgKiBUaGUgbG9nIGxldmVsIG9mIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgcmVhZG9ubHkgbGV2ZWw6IElvTWVzc2FnZUxldmVsO1xuXG4gIC8qKlxuICAgKiBUaGUgYWN0aW9uIHRoYXQgdHJpZ2dlcmVkIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgcmVhZG9ubHkgYWN0aW9uOiBUb29sa2l0QWN0aW9uO1xuXG4gIC8qKlxuICAgKiBBIHNob3J0IG1lc3NhZ2UgY29kZSB1bmlxdWVseSBpZGVudGlmeWluZyBhIG1lc3NhZ2UgdHlwZSB1c2luZyB0aGUgZm9ybWF0IENES19bQ0FURUdPUlldX1tFL1cvSV1bMDAwLTk5OV0uXG4gICAqXG4gICAqIFRoZSBsZXZlbCBpbmRpY2F0b3IgZm9sbG93cyB0aGVzZSBydWxlczpcbiAgICogLSAnRScgZm9yIGVycm9yIGxldmVsIG1lc3NhZ2VzXG4gICAqIC0gJ1cnIGZvciB3YXJuaW5nIGxldmVsIG1lc3NhZ2VzXG4gICAqIC0gJ0knIGZvciBpbmZvL2RlYnVnL3RyYWNlIGxldmVsIG1lc3NhZ2VzXG4gICAqXG4gICAqIENvZGVzIGVuZGluZyBpbiAwMDAgYXJlIGdlbmVyaWMgbWVzc2FnZXMsIHdoaWxlIGNvZGVzIGVuZGluZyBpbiAwMDEtOTk5IGFyZSBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgbWVzc2FnZS5cbiAgICogVGhlIGZvbGxvd2luZyBhcmUgZXhhbXBsZXMgb2YgdmFsaWQgYW5kIGludmFsaWQgbWVzc2FnZSBjb2RlczpcbiAgICogYGBgdHNcbiAgICogJ0NES19BU1NFVFNfSTAwMCcgICAgICAgLy8gdmFsaWQ6IGdlbmVyaWMgYXNzZXRzIGluZm8gbWVzc2FnZVxuICAgKiAnQ0RLX1RPT0xLSVRfRTAwMicgICAgICAvLyB2YWxpZDogc3BlY2lmaWMgdG9vbGtpdCBlcnJvciBtZXNzYWdlXG4gICAqICdDREtfU0RLX1cwMjMnICAgICAgICAgIC8vIHZhbGlkOiBzcGVjaWZpYyBzZGsgd2FybmluZyBtZXNzYWdlXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZG9ubHkgY29kZTogSW9NZXNzYWdlQ29kZTtcblxuICAvKipcbiAgICogVGhlIG1lc3NhZ2UgdGV4dC5cbiAgICovXG4gIHJlYWRvbmx5IG1lc3NhZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGRhdGEgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UuXG4gICAqL1xuICByZWFkb25seSBkYXRhPzogVDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJb1JlcXVlc3Q8VCwgVT4gZXh0ZW5kcyBJb01lc3NhZ2U8VD4ge1xuICAvKipcbiAgICogVGhlIGRlZmF1bHQgcmVzcG9uc2UgdGhhdCB3aWxsIGJlIHVzZWQgaWYgbm8gZGF0YSBpcyByZXR1cm5lZC5cbiAgICovXG4gIHJlYWRvbmx5IGRlZmF1bHRSZXNwb25zZTogVTtcbn1cblxuZXhwb3J0IHR5cGUgSW9NZXNzYWdlTGV2ZWwgPSAnZXJyb3InIHwgJ3Jlc3VsdCcgfCAnd2FybicgfCAnaW5mbycgfCAnZGVidWcnIHwgJ3RyYWNlJztcblxuZXhwb3J0IGNvbnN0IGxldmVsUHJpb3JpdHk6IFJlY29yZDxJb01lc3NhZ2VMZXZlbCwgbnVtYmVyPiA9IHtcbiAgZXJyb3I6IDAsXG4gIHJlc3VsdDogMSxcbiAgd2FybjogMixcbiAgaW5mbzogMyxcbiAgZGVidWc6IDQsXG4gIHRyYWNlOiA1LFxufTtcblxuLyoqXG4gKiBUZW1wb3JhcnkgaGVscGVyIHRvIGdyb3VwIHJlcXVpcmVkIHByb3BzIGZvciBJb01lc3NhZ2VzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW9NZXNzYWdpbmcge1xuICBpb0hvc3Q6IElJb0hvc3Q7XG4gIGFjdGlvbjogVG9vbGtpdEFjdGlvbjtcbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudCBhY3Rpb24gYmVpbmcgcGVyZm9ybWVkIGJ5IHRoZSBDTEkuICdub25lJyByZXByZXNlbnRzIHRoZSBhYnNlbmNlIG9mIGFuIGFjdGlvbi5cbiAqL1xuZXhwb3J0IHR5cGUgVG9vbGtpdEFjdGlvbiA9XG58ICdhc3NlbWJseSdcbnwgJ2Jvb3RzdHJhcCdcbnwgJ3N5bnRoJ1xufCAnbGlzdCdcbnwgJ2RpZmYnXG58ICdkZXBsb3knXG58ICdyb2xsYmFjaydcbnwgJ3dhdGNoJ1xufCAnZGVzdHJveSdcbnwgJ2NvbnRleHQnXG58ICdkb2NzJ1xufCAnZG9jdG9yJ1xufCAnZ2MnXG58ICdpbXBvcnQnXG58ICdtZXRhZGF0YSdcbnwgJ25vdGljZXMnXG58ICdpbml0J1xufCAnbWlncmF0ZSdcbnwgJ3ZlcnNpb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIElJb0hvc3Qge1xuICAvKipcbiAgICogTm90aWZpZXMgdGhlIGhvc3Qgb2YgYSBtZXNzYWdlLlxuICAgKiBUaGUgY2FsbGVyIHdhaXRzIHVudGlsIHRoZSBub3RpZmljYXRpb24gY29tcGxldGVzLlxuICAgKi9cbiAgbm90aWZ5PFQ+KG1zZzogSW9NZXNzYWdlPFQ+KTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogTm90aWZpZXMgdGhlIGhvc3Qgb2YgYSBtZXNzYWdlIHRoYXQgcmVxdWlyZXMgYSByZXNwb25zZS5cbiAgICpcbiAgICogSWYgdGhlIGhvc3QgZG9lcyBub3QgcmV0dXJuIGEgcmVzcG9uc2UgdGhlIHN1Z2dlc3RlZFxuICAgKiBkZWZhdWx0IHJlc3BvbnNlIGZyb20gdGhlIGlucHV0IG1lc3NhZ2Ugd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgcmVxdWVzdFJlc3BvbnNlPFQsIFU+KG1zZzogSW9SZXF1ZXN0PFQsIFU+KTogUHJvbWlzZTxVPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDbGlJb0hvc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgaW5pdGlhbCBUb29sa2l0IGFjdGlvbiB0aGUgaG9zdHMgc3RhcnRzIHdpdGguXG4gICAqXG4gICAqIEBkZWZhdWx0ICdub25lJ1xuICAgKi9cbiAgcmVhZG9ubHkgY3VycmVudEFjdGlvbj86IFRvb2xraXRBY3Rpb247XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHZlcmJvc2l0eSBvZiB0aGUgb3V0cHV0LlxuICAgKlxuICAgKiBUaGUgQ2xpSW9Ib3N0IHdpbGwgc3RpbGwgcmVjZWl2ZSBhbGwgbWVzc2FnZXMgYW5kIHJlcXVlc3RzLFxuICAgKiBidXQgb25seSB0aGUgbWVzc2FnZXMgaW5jbHVkZWQgaW4gdGhpcyBsZXZlbCB3aWxsIGJlIHByaW50ZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0ICdpbmZvJ1xuICAgKi9cbiAgcmVhZG9ubHkgbG9nTGV2ZWw/OiBJb01lc3NhZ2VMZXZlbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIHRoZSBhdXRvbWF0aWMgVFRZIGRldGVjdGlvbi5cbiAgICpcbiAgICogV2hlbiBUVFkgaXMgZGlzYWJsZWQsIHRoZSBDTEkgd2lsbCBoYXZlIG5vIGludGVyYWN0aW9ucyBvciBjb2xvci5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBkZXRlcm1pbmVkIGZyb20gdGhlIGN1cnJlbnQgcHJvY2Vzc1xuICAgKi9cbiAgcmVhZG9ubHkgaXNUVFk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBDbGlJb0hvc3QgaXMgcnVubmluZyBpbiBDSSBtb2RlLlxuICAgKlxuICAgKiBJbiBDSSBtb2RlLCBhbGwgbm9uLWVycm9yIG91dHB1dCBnb2VzIHRvIHN0ZG91dCBpbnN0ZWFkIG9mIHN0ZGVyci5cbiAgICogU2V0IHRvIGZhbHNlIGluIHRoZSBDbGlJb0hvc3QgY29uc3RydWN0b3IgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBpZiB0aGUgQ0xJIENJIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGRldGVybWluZWQgZnJvbSB0aGUgZW52aXJvbm1lbnQsIHNwZWNpZmljYWxseSBiYXNlZCBvbiBgcHJvY2Vzcy5lbnYuQ0lgXG4gICAqL1xuICByZWFkb25seSBpc0NJPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBJTyBob3N0IGZvciB0aGUgQ0xJIHRoYXQgd3JpdGVzIG1lc3NhZ2VzIHRvIHRoZSBjb25zb2xlLlxuICovXG5leHBvcnQgY2xhc3MgQ2xpSW9Ib3N0IGltcGxlbWVudHMgSUlvSG9zdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaW5nbGV0b24gaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBpbnN0YW5jZShwcm9wczogQ2xpSW9Ib3N0UHJvcHMgPSB7fSwgZm9yY2VOZXcgPSBmYWxzZSk6IENsaUlvSG9zdCB7XG4gICAgaWYgKGZvcmNlTmV3IHx8ICFDbGlJb0hvc3QuX2luc3RhbmNlKSB7XG4gICAgICBDbGlJb0hvc3QuX2luc3RhbmNlID0gbmV3IENsaUlvSG9zdChwcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBDbGlJb0hvc3QuX2luc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGUgQ2xpSW9Ib3N0XG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBfaW5zdGFuY2U6IENsaUlvSG9zdCB8IHVuZGVmaW5lZDtcblxuICAvLyBpbnRlcm5hbCBzdGF0ZSBmb3IgZ2V0dGVycy9zZXR0ZXJcbiAgcHJpdmF0ZSBfY3VycmVudEFjdGlvbjogVG9vbGtpdEFjdGlvbjtcbiAgcHJpdmF0ZSBfaXNDSTogYm9vbGVhbjtcbiAgcHJpdmF0ZSBfaXNUVFk6IGJvb2xlYW47XG4gIHByaXZhdGUgX2xvZ0xldmVsOiBJb01lc3NhZ2VMZXZlbDtcbiAgcHJpdmF0ZSBfaW50ZXJuYWxJb0hvc3Q/OiBJSW9Ib3N0O1xuXG4gIC8vIENvcmtlZCBMb2dnaW5nXG4gIHByaXZhdGUgY29ya2VkQ291bnRlciA9IDA7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29ya2VkTG9nZ2luZ0J1ZmZlcjogSW9NZXNzYWdlPGFueT5bXSA9IFtdO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IocHJvcHM6IENsaUlvSG9zdFByb3BzID0ge30pIHtcbiAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gcHJvcHMuY3VycmVudEFjdGlvbiA/PyAnbm9uZScgYXMgVG9vbGtpdEFjdGlvbjtcbiAgICB0aGlzLl9pc1RUWSA9IHByb3BzLmlzVFRZID8/IHByb2Nlc3Muc3Rkb3V0LmlzVFRZID8/IGZhbHNlO1xuICAgIHRoaXMuX2xvZ0xldmVsID0gcHJvcHMubG9nTGV2ZWwgPz8gJ2luZm8nO1xuICAgIHRoaXMuX2lzQ0kgPSBwcm9wcy5pc0NJID8/IGlzQ0koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaW5nbGV0b24gaW5zdGFuY2VcbiAgICovXG4gIHB1YmxpYyByZWdpc3RlcklvSG9zdChpb0hvc3Q6IElJb0hvc3QpIHtcbiAgICBpZiAoaW9Ib3N0ICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLl9pbnRlcm5hbElvSG9zdCA9IGlvSG9zdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgYWN0aW9uIGJlaW5nIHBlcmZvcm1lZCBieSB0aGUgQ0xJLlxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50QWN0aW9uKCk6IFRvb2xraXRBY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50QWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgYWN0aW9uIGJlaW5nIHBlcmZvcm1lZCBieSB0aGUgQ0xJLlxuICAgKlxuICAgKiBAcGFyYW0gYWN0aW9uIFRoZSBhY3Rpb24gYmVpbmcgcGVyZm9ybWVkIGJ5IHRoZSBDTEkuXG4gICAqL1xuICBwdWJsaWMgc2V0IGN1cnJlbnRBY3Rpb24oYWN0aW9uOiBUb29sa2l0QWN0aW9uKSB7XG4gICAgdGhpcy5fY3VycmVudEFjdGlvbiA9IGFjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBob3N0IGNhbiB1c2UgaW50ZXJhY3Rpb25zIGFuZCBtZXNzYWdlIHN0eWxpbmcuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzVFRZKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9pc1RUWTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgVFRZIG1vZGUsIGkuZSBjYW4gdGhlIGhvc3QgdXNlIGludGVyYWN0aW9ucyBhbmQgbWVzc2FnZSBzdHlsaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgc2V0IFRUWSBtb2RlXG4gICAqL1xuICBwdWJsaWMgc2V0IGlzVFRZKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5faXNUVFkgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBDbGlJb0hvc3QgaXMgcnVubmluZyBpbiBDSSBtb2RlLiBJbiBDSSBtb2RlLCBhbGwgbm9uLWVycm9yIG91dHB1dCBnb2VzIHRvIHN0ZG91dCBpbnN0ZWFkIG9mIHN0ZGVyci5cbiAgICovXG4gIHB1YmxpYyBnZXQgaXNDSSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faXNDSTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIENJIG1vZGUuIEluIENJIG1vZGUsIGFsbCBub24tZXJyb3Igb3V0cHV0IGdvZXMgdG8gc3Rkb3V0IGluc3RlYWQgb2Ygc3RkZXJyLlxuICAgKiBAcGFyYW0gdmFsdWUgc2V0IHRoZSBDSSBtb2RlXG4gICAqL1xuICBwdWJsaWMgc2V0IGlzQ0kodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9pc0NJID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgdGhyZXNob2xkLiBNZXNzYWdlcyB3aXRoIGEgbG93ZXIgcHJpb3JpdHkgbGV2ZWwgd2lsbCBiZSBpZ25vcmVkLlxuICAgKi9cbiAgcHVibGljIGdldCBsb2dMZXZlbCgpOiBJb01lc3NhZ2VMZXZlbCB7XG4gICAgcmV0dXJuIHRoaXMuX2xvZ0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgdGhyZXNob2xkLiBNZXNzYWdlcyB3aXRoIGEgbG93ZXIgcHJpb3JpdHkgbGV2ZWwgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0gbGV2ZWwgVGhlIG5ldyBsb2cgbGV2ZWwgdGhyZXNob2xkXG4gICAqL1xuICBwdWJsaWMgc2V0IGxvZ0xldmVsKGxldmVsOiBJb01lc3NhZ2VMZXZlbCkge1xuICAgIHRoaXMuX2xvZ0xldmVsID0gbGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBibG9jayBvZiBjb2RlIHdpdGggY29ya2VkIGxvZ2dpbmcuIEFsbCBsb2cgbWVzc2FnZXMgZHVyaW5nIGV4ZWN1dGlvblxuICAgKiBhcmUgYnVmZmVyZWQgYW5kIG9ubHkgd3JpdHRlbiB3aGVuIGFsbCBuZXN0ZWQgY29yayBibG9ja3MgY29tcGxldGUgKHdoZW4gQ09SS19DT1VOVEVSIHJlYWNoZXMgMCkuXG4gICAqIFRoZSBjb3JraW5nIGlzIGJvdW5kIHRvIHRoZSBzcGVjaWZpYyBpbnN0YW5jZSBvZiB0aGUgQ2xpSW9Ib3N0LlxuICAgKlxuICAgKiBAcGFyYW0gYmxvY2sgLSBBc3luYyBmdW5jdGlvbiB0byBleGVjdXRlIHdpdGggY29ya2VkIGxvZ2dpbmdcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGJsb2NrJ3MgcmV0dXJuIHZhbHVlXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgd2l0aENvcmtlZExvZ2dpbmc8VD4oYmxvY2s6ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICB0aGlzLmNvcmtlZENvdW50ZXIrKztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGJsb2NrKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuY29ya2VkQ291bnRlci0tO1xuICAgICAgaWYgKHRoaXMuY29ya2VkQ291bnRlciA9PT0gMCkge1xuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggYnVmZmVyZWQgbWVzc2FnZSB0aHJvdWdoIG5vdGlmeVxuICAgICAgICBmb3IgKGNvbnN0IGlvTWVzc2FnZSBvZiB0aGlzLmNvcmtlZExvZ2dpbmdCdWZmZXIpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLm5vdGlmeShpb01lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgYnVmZmVyZWQgbWVzc2FnZXMgaW4tcGxhY2VcbiAgICAgICAgdGhpcy5jb3JrZWRMb2dnaW5nQnVmZmVyLnNwbGljZSgwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm90aWZpZXMgdGhlIGhvc3Qgb2YgYSBtZXNzYWdlLlxuICAgKiBUaGUgY2FsbGVyIHdhaXRzIHVudGlsIHRoZSBub3RpZmljYXRpb24gY29tcGxldGVzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIG5vdGlmeTxUPihtc2c6IElvTWVzc2FnZTxUPik6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLl9pbnRlcm5hbElvSG9zdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsSW9Ib3N0Lm5vdGlmeShtc2cpO1xuICAgIH1cblxuICAgIGlmIChsZXZlbFByaW9yaXR5W21zZy5sZXZlbF0gPiBsZXZlbFByaW9yaXR5W3RoaXMubG9nTGV2ZWxdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29ya2VkQ291bnRlciA+IDApIHtcbiAgICAgIHRoaXMuY29ya2VkTG9nZ2luZ0J1ZmZlci5wdXNoKG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5mb3JtYXRNZXNzYWdlKG1zZyk7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5zZWxlY3RTdHJlYW0obXNnLmxldmVsKTtcbiAgICBzdHJlYW0ud3JpdGUob3V0cHV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBvdXRwdXQgc3RyZWFtLCBiYXNlZCBvbiBtZXNzYWdlIGxldmVsIGFuZCBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBzZWxlY3RTdHJlYW0obGV2ZWw6IElvTWVzc2FnZUxldmVsKSB7XG4gICAgLy8gVGhlIHN0cmVhbSBzZWxlY3Rpb24gcG9saWN5IGZvciB0aGUgQ0xJIGlzIHRoZSBmb2xsb3dpbmc6XG4gICAgLy9cbiAgICAvLyAgICgxKSBNZXNzYWdlcyBvZiBsZXZlbCBgcmVzdWx0YCBhbHdheXMgZ28gdG8gYHN0ZG91dGBcbiAgICAvLyAgICgyKSBNZXNzYWdlcyBvZiBsZXZlbCBgZXJyb3JgIGFsd2F5cyBnbyB0byBgc3RkZXJyYC5cbiAgICAvLyAgICgzYSkgQWxsIHJlbWFpbmluZyBtZXNzYWdlcyBnbyB0byBgc3RkZXJyYC5cbiAgICAvLyAgICgzYikgSWYgd2UgYXJlIGluIENJIG1vZGUsIGFsbCByZW1haW5pbmcgbWVzc2FnZXMgZ28gdG8gYHN0ZG91dGAuXG4gICAgLy9cbiAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHJldHVybiBwcm9jZXNzLnN0ZGVycjtcbiAgICAgIGNhc2UgJ3Jlc3VsdCc6XG4gICAgICAgIHJldHVybiBwcm9jZXNzLnN0ZG91dDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmlzQ0kgPyBwcm9jZXNzLnN0ZG91dCA6IHByb2Nlc3Muc3RkZXJyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZmllcyB0aGUgaG9zdCBvZiBhIG1lc3NhZ2UgdGhhdCByZXF1aXJlcyBhIHJlc3BvbnNlLlxuICAgKlxuICAgKiBJZiB0aGUgaG9zdCBkb2VzIG5vdCByZXR1cm4gYSByZXNwb25zZSB0aGUgc3VnZ2VzdGVkXG4gICAqIGRlZmF1bHQgcmVzcG9uc2UgZnJvbSB0aGUgaW5wdXQgbWVzc2FnZSB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcmVxdWVzdFJlc3BvbnNlPERhdGFUeXBlLCBSZXNwb25zZVR5cGU+KG1zZzogSW9SZXF1ZXN0PERhdGFUeXBlLCBSZXNwb25zZVR5cGU+KTogUHJvbWlzZTxSZXNwb25zZVR5cGU+IHtcbiAgICAvLyBGaXJzdCBjYWxsIG91dCB0byBhIHJlZ2lzdGVyZWQgaW5zdGFuY2UgaWYgd2UgaGF2ZSBvbmVcbiAgICBpZiAodGhpcy5faW50ZXJuYWxJb0hvc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbElvSG9zdC5yZXF1ZXN0UmVzcG9uc2UobXNnKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgcmVxdWVzdCBjYW5ub3QgYmUgcHJvbXB0ZWQgZm9yIGJ5IHRoZSBDbGlJb0hvc3QsIHdlIGp1c3QgYWNjZXB0IHRoZSBkZWZhdWx0XG4gICAgaWYgKCFpc1Byb21wdGFibGVSZXF1ZXN0KG1zZykpIHtcbiAgICAgIGF3YWl0IHRoaXMubm90aWZ5KG1zZyk7XG4gICAgICByZXR1cm4gbXNnLmRlZmF1bHRSZXNwb25zZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud2l0aENvcmtlZExvZ2dpbmcoYXN5bmMgKCk6IFByb21pc2U8c3RyaW5nIHwgbnVtYmVyIHwgdHJ1ZT4gPT4ge1xuICAgICAgLy8gcHJlcGFyZSBwcm9tcHQgZGF0YVxuICAgICAgLy8gQHRvZG8gdGhpcyBmb3JtYXQgaXMgbm90IGRlZmluZWQgYW55d2hlcmUsIHByb2JhYmx5IHNob3VsZCBiZVxuICAgICAgY29uc3QgZGF0YToge1xuICAgICAgICBtb3RpdmF0aW9uPzogc3RyaW5nO1xuICAgICAgICBjb25jdXJyZW5jeT86IG51bWJlcjtcbiAgICAgIH0gPSBtc2cuZGF0YSA/PyB7fTtcblxuICAgICAgY29uc3QgbW90aXZhdGlvbiA9IGRhdGEubW90aXZhdGlvbiA/PyAnVXNlciBpbnB1dCBpcyBuZWVkZWQnO1xuICAgICAgY29uc3QgY29uY3VycmVuY3kgPSBkYXRhLmNvbmN1cnJlbmN5ID8/IDA7XG5cbiAgICAgIC8vIG9ubHkgdGFsayB0byB1c2VyIGlmIFNURElOIGlzIGEgdGVybWluYWwgKG90aGVyd2lzZSwgZmFpbClcbiAgICAgIGlmICghdGhpcy5pc1RUWSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGAke21vdGl2YXRpb259LCBidXQgdGVybWluYWwgKFRUWSkgaXMgbm90IGF0dGFjaGVkIHNvIHdlIGFyZSB1bmFibGUgdG8gZ2V0IGEgY29uZmlybWF0aW9uIGZyb20gdGhlIHVzZXJgKTtcbiAgICAgIH1cblxuICAgICAgLy8gb25seSB0YWxrIHRvIHVzZXIgaWYgY29uY3VycmVuY3kgaXMgMSAob3RoZXJ3aXNlLCBmYWlsKVxuICAgICAgaWYgKGNvbmN1cnJlbmN5ID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGAke21vdGl2YXRpb259LCBidXQgY29uY3VycmVuY3kgaXMgZ3JlYXRlciB0aGFuIDEgc28gd2UgYXJlIHVuYWJsZSB0byBnZXQgYSBjb25maXJtYXRpb24gZnJvbSB0aGUgdXNlcmApO1xuICAgICAgfVxuXG4gICAgICAvLyBCYXNpYyBjb25maXJtYXRpb24gcHJvbXB0XG4gICAgICAvLyBXZSB0cmVhdCBhbGwgcmVxdWVzdHMgd2l0aCBhIGJvb2xlYW4gcmVzcG9uc2UgYXMgY29uZmlybWF0aW9uIHByb21wdHNcbiAgICAgIGlmIChpc0NvbmZpcm1hdGlvblByb21wdChtc2cpKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1lZCA9IGF3YWl0IHByb21wdGx5LmNvbmZpcm0oYCR7Y2hhbGsuY3lhbihtc2cubWVzc2FnZSl9ICh5L24pYCk7XG4gICAgICAgIGlmICghY29uZmlybWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignQWJvcnRlZCBieSB1c2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmZpcm1lZDtcbiAgICAgIH1cblxuICAgICAgLy8gQXNraW5nIGZvciBhIHNwZWNpZmljIHZhbHVlXG4gICAgICBjb25zdCBwcm9tcHQgPSBleHRyYWN0UHJvbXB0SW5mbyhtc2cpO1xuICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgcHJvbXB0bHkucHJvbXB0KGAke2NoYWxrLmN5YW4obXNnLm1lc3NhZ2UpfSAoJHtwcm9tcHQuZGVmYXVsdH0pYCwge1xuICAgICAgICBkZWZhdWx0OiBwcm9tcHQuZGVmYXVsdCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb21wdC5jb252ZXJ0QW5zd2VyKGFuc3dlcik7XG4gICAgfSk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGNhc3QgdGhpcyBiZWNhdXNlIGl0IGlzIGltcG9zc2libGUgdG8gbmFycm93IHRoZSBnZW5lcmljIHR5cGVcbiAgICAvLyBpc1Byb21wdGFibGVSZXF1ZXN0IGVuc3VyZXMgdGhhdCB0aGUgcmVzcG9uc2UgdHlwZSBpcyBvbmUgd2UgY2FuIHByb21wdCBmb3JcbiAgICAvLyB0aGUgcmVtYWluaW5nIGNvZGUgZW5zdXJlIHdlIGFyZSBpbmRlZWQgcmV0dXJuaW5nIHRoZSBjb3JyZWN0IHR5cGVcbiAgICByZXR1cm4gcmVzcG9uc2UgYXMgUmVzcG9uc2VUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdHMgYSBtZXNzYWdlIGZvciBjb25zb2xlIG91dHB1dCB3aXRoIG9wdGlvbmFsIGNvbG9yIHN1cHBvcnRcbiAgICovXG4gIHByaXZhdGUgZm9ybWF0TWVzc2FnZShtc2c6IElvTWVzc2FnZTxhbnk+KTogc3RyaW5nIHtcbiAgICAvLyBhcHBseSBwcm92aWRlZCBzdHlsZSBvciBhIGRlZmF1bHQgc3R5bGUgaWYgd2UncmUgaW4gVFRZIG1vZGVcbiAgICBsZXQgbWVzc2FnZV90ZXh0ID0gdGhpcy5faXNUVFlcbiAgICAgID8gc3R5bGVNYXBbbXNnLmxldmVsXShtc2cubWVzc2FnZSlcbiAgICAgIDogbXNnLm1lc3NhZ2U7XG5cbiAgICAvLyBwcmVwZW5kIHRpbWVzdGFtcCBpZiBJb01lc3NhZ2VMZXZlbCBpcyBERUJVRyBvciBUUkFDRS4gUG9zdHBlbmQgYSBuZXdsaW5lLlxuICAgIHJldHVybiAoKG1zZy5sZXZlbCA9PT0gJ2RlYnVnJyB8fCBtc2cubGV2ZWwgPT09ICd0cmFjZScpXG4gICAgICA/IGBbJHt0aGlzLmZvcm1hdFRpbWUobXNnLnRpbWUpfV0gJHttZXNzYWdlX3RleHR9YFxuICAgICAgOiBtZXNzYWdlX3RleHQpICsgJ1xcbic7XG4gIH1cblxuICAvKipcbiAgICogRm9ybWF0cyBkYXRlIHRvIEhIOk1NOlNTXG4gICAqL1xuICBwcml2YXRlIGZvcm1hdFRpbWUoZDogRGF0ZSk6IHN0cmluZyB7XG4gICAgY29uc3QgcGFkID0gKG46IG51bWJlcik6IHN0cmluZyA9PiBuLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICByZXR1cm4gYCR7cGFkKGQuZ2V0SG91cnMoKSl9OiR7cGFkKGQuZ2V0TWludXRlcygpKX06JHtwYWQoZC5nZXRTZWNvbmRzKCkpfWA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIElvSG9zdCBpbXBsZW1lbnRhdGlvbiBjb25zaWRlcnMgYSByZXF1ZXN0IHByb21wdGFibGUsIGlmOlxuICogLSBpdCdzIGEgeWVzL25vIGNvbmZpcm1hdGlvblxuICogLSBhc2tpbmcgZm9yIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZVxuICovXG5mdW5jdGlvbiBpc1Byb21wdGFibGVSZXF1ZXN0KG1zZzogSW9SZXF1ZXN0PGFueSwgYW55Pik6IG1zZyBpcyBJb1JlcXVlc3Q8YW55LCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuPiB7XG4gIHJldHVybiBpc0NvbmZpcm1hdGlvblByb21wdChtc2cpXG4gICAgfHwgdHlwZW9mIG1zZy5kZWZhdWx0UmVzcG9uc2UgPT09ICdzdHJpbmcnXG4gICAgfHwgdHlwZW9mIG1zZy5kZWZhdWx0UmVzcG9uc2UgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSByZXF1ZXN0IGlzIGEgY29uZmlybWF0aW9uIHByb21wdFxuICogV2UgdHJlYXQgYWxsIHJlcXVlc3RzIHdpdGggYSBib29sZWFuIHJlc3BvbnNlIGFzIGNvbmZpcm1hdGlvbiBwcm9tcHRzXG4gKi9cbmZ1bmN0aW9uIGlzQ29uZmlybWF0aW9uUHJvbXB0KG1zZzogSW9SZXF1ZXN0PGFueSwgYW55Pik6IG1zZyBpcyBJb1JlcXVlc3Q8YW55LCBib29sZWFuPiB7XG4gIHJldHVybiB0eXBlb2YgbXNnLmRlZmF1bHRSZXNwb25zZSA9PT0gJ2Jvb2xlYW4nO1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBleHRyYWN0IGluZm9ybWF0aW9uIGZvciBwcm9tcHRseSBmcm9tIHRoZSByZXF1ZXN0XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm9tcHRJbmZvKG1zZzogSW9SZXF1ZXN0PGFueSwgYW55Pik6IHtcbiAgZGVmYXVsdDogc3RyaW5nO1xuICBjb252ZXJ0QW5zd2VyOiAoaW5wdXQ6IHN0cmluZykgPT4gc3RyaW5nIHwgbnVtYmVyO1xufSB7XG4gIGNvbnN0IGlzTnVtYmVyID0gKHR5cGVvZiBtc2cuZGVmYXVsdFJlc3BvbnNlID09PSAnbnVtYmVyJyk7XG4gIHJldHVybiB7XG4gICAgZGVmYXVsdDogdXRpbC5mb3JtYXQobXNnLmRlZmF1bHRSZXNwb25zZSksXG4gICAgY29udmVydEFuc3dlcjogaXNOdW1iZXIgPyAodikgPT4gTnVtYmVyKHYpIDogKHYpID0+IFN0cmluZyh2KSxcbiAgfTtcbn1cblxuY29uc3Qgc3R5bGVNYXA6IFJlY29yZDxJb01lc3NhZ2VMZXZlbCwgKHN0cjogc3RyaW5nKSA9PiBzdHJpbmc+ID0ge1xuICBlcnJvcjogY2hhbGsucmVkLFxuICB3YXJuOiBjaGFsay55ZWxsb3csXG4gIHJlc3VsdDogY2hhbGsud2hpdGUsXG4gIGluZm86IGNoYWxrLndoaXRlLFxuICBkZWJ1ZzogY2hhbGsuZ3JheSxcbiAgdHJhY2U6IGNoYWxrLmdyYXksXG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBwcm9jZXNzIGlzIHJ1bm5pbmcgaW4gYSBDSSBlbnZpcm9ubWVudFxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBwcm9jZXNzIGlzIHJ1bm5pbmcgaW4gYSBDSSBlbnZpcm9ubWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDSSgpOiBib29sZWFuIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkNJICE9PSB1bmRlZmluZWQgJiYgcHJvY2Vzcy5lbnYuQ0kgIT09ICdmYWxzZScgJiYgcHJvY2Vzcy5lbnYuQ0kgIT09ICcwJztcbn1cbiJdfQ==